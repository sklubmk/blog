<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JK&#39;s Devlog</title>
    <link>https://sklubmk.github.io/</link>
    
    <atom:link href="https://sklubmk.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Jinki Kim&#39;s Front End Devlog</description>
    <pubDate>Mon, 23 Aug 2021 10:44:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[프로그래머스] (LV2) 직업군 추천하기</title>
      <link>https://sklubmk.github.io/2021/08/23/f67283951ab9/</link>
      <guid>https://sklubmk.github.io/2021/08/23/f67283951ab9/</guid>
      <pubDate>Mon, 23 Aug 2021 10:31:01 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>개발자가 사용하는 언어와 <code>언어 선호도</code>를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.</p><p>아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 <code>직업군 언어 점수</code>를 부여한 표입니다.</p><div class="table-container"><table><thead><tr><th>점수</th><th>SI</th><th>CONTENTS</th><th>HARDWARE</th><th>PORTAL</th><th>GAME</th></tr></thead><tbody><tr><td>5</td><td>JAVA</td><td>JAVASCRIPT</td><td>C</td><td>JAVA</td><td>C++</td></tr><tr><td>4</td><td>JAVASCRIPT</td><td>JAVA</td><td>C++</td><td>JAVASCRIPT</td><td>C#</td></tr><tr><td>3</td><td>SQL</td><td>PYTHON</td><td>PYTHON</td><td>PYTHON</td><td>JAVASCRIPT</td></tr><tr><td>2</td><td>PYTHON</td><td>SQL</td><td>JAVA</td><td>KOTLIN</td><td>C</td></tr><tr><td>1</td><td>C#</td><td>C++</td><td>JAVASCRIPT</td><td>PHP</td><td>JAVA</td></tr></tbody></table></div><p>예를 들면, SQL의 SI <code>직업군 언어 점수</code>는 3점이지만 CONTENTS <code>직업군 언어 점수</code>는 2점입니다. SQL의 HARDWARE, PORTAL, GAME <code>직업군 언어 점수</code>는 0점입니다.</p><p><code>직업군 언어 점수</code>를 정리한 문자열 배열 <code>table</code>, 개발자가 사용하는 언어를 담은 문자열 배열 <code>languages</code>, <code>언어 선호도</code>를 담은 정수 배열 <code>preference</code>가 매개변수로 주어집니다. 개발자가 사용하는 언어의 <code>언어 선호도</code> x <code>직업군 언어 점수</code>의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요. 총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.</p><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li><code>table</code>의 길이 = 5<ul><li><code>table</code>의 원소는 <code>&quot;직업군 5점언어 4점언어 3점언어 2점언어 1점언어&quot;</code>형식의 문자열입니다. <code>직업군</code>, <code>5점언어</code>, <code>4언어</code>, <code>3점언어</code>, <code>2점언어</code>, <code>1점언어</code>는 하나의 공백으로 구분되어 있습니다.</li><li><code>table</code>은 모든 테스트케이스에서 동일합니다.</li></ul></li><li>1 ≤ <code>languages</code>의 길이 ≤ 9<ul><li><code>languages</code>의 원소는 <code>&quot;JAVA&quot;</code>, <code>&quot;JAVASCRIPT&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;C++&quot;</code> ,<code>&quot;C#&quot;</code> , <code>&quot;SQL&quot;</code>, <code>&quot;PYTHON&quot;</code>, <code>&quot;KOTLIN&quot;</code>, <code>&quot;PHP&quot;</code> 중 한 개 이상으로 이루어져 있습니다.</li><li><code>languages</code>의 원소는 중복되지 않습니다.</li></ul></li><li><code>preference</code>의 길이 = <code>languages</code>의 길이<ul><li>1 ≤ <code>preference</code>의 원소 ≤ 10</li></ul></li><li><code>preference</code>의 i번째 원소는 <code>languages</code>의 i번째 원소의 <code>언어 선호도</code>입니다.</li><li>return 할 문자열은 <code>&quot;SI&quot;</code>, <code>&quot;CONTENTS&quot;</code>, <code>&quot;HARDWARE&quot;</code>, <code>&quot;PORTAL&quot;</code>, <code>&quot;GAME&quot;</code> 중 하나입니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>table</th><th>languages</th><th>preference</th><th>result</th></tr></thead><tbody><tr><td><code>[&quot;SI JAVA JAVASCRIPT SQL PYTHON C#&quot;, &quot;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++&quot;, &quot;HARDWARE C C++ PYTHON JAVA JAVASCRIPT&quot;, &quot;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP&quot;, &quot;GAME C++ C# JAVASCRIPT C JAVA&quot;]</code></td><td><code>[&quot;PYTHON&quot;, &quot;C++&quot;, &quot;SQL&quot;]</code></td><td>[7, 5, 5]</td><td><code>&quot;HARDWARE&quot;</code></td></tr><tr><td><code>[&quot;SI JAVA JAVASCRIPT SQL PYTHON C#&quot;, &quot;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++&quot;, &quot;HARDWARE C C++ PYTHON JAVA JAVASCRIPT&quot;, &quot;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP&quot;, &quot;GAME C++ C# JAVASCRIPT C JAVA&quot;]</code></td><td><code>[&quot;JAVA&quot;, &quot;JAVASCRIPT&quot;]</code></td><td>[7, 5]</td><td><code>&quot;PORTAL&quot;</code></td></tr></tbody></table></div><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>각 직업군 별로 점수를 계산해보면 아래와 같습니다.</p><p>아래 사진은 <code>개발자 언어 선호도</code> 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9a711ad6-4a8e-4028-b100-0280a4e3a7dd/tc1_preference.PNG" alt="tc1_preference.PNG"></p><p>아래 사진은 개발자가 선호하는 언어의 <code>직업군 언어 점수</code>를 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/1ef5a88a-8109-415d-b611-a6320410b1e1/tc1_score.PNG" alt="tc1_score.PNG"></p><p>따라서 점수 총합이 41로 가장 높은 <code>&quot;HARDWARE&quot;</code>를 return 해야 합니다.</p><p>입출력 예 #2</p><p>각 직업군 별로 점수를 계산해보면 아래와 같습니다.</p><p>아래 사진은 <code>개발자 언어 선호도</code> 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e49d818b-938a-4cc3-8d2a-27783f2e1af5/tc2_preference.PNG" alt="tc2_preference.PNG"></p><p>아래 사진은 개발자가 선호하는 언어의 <code>직업군 언어 점수</code>를 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0624156e-e1d3-4299-b554-470815322a79/tc2_score.PNG" alt="tc2_score.PNG">\<br>점수 총합이 55로 가장 높은 직업군은 “SI” 와 “PORTAL”입니다.\<br>따라서 사전 순으로 먼저 오는 <code>&quot;PORTAL&quot;</code>을 return 해야 합니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">table, languages, preference</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    table_hash = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):</span><br><span class="line">        t_s = table[i].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        table_hash[t_s[<span class="number">0</span>]] = &#123;t:<span class="number">5</span>-i <span class="keyword">for</span> i,t <span class="keyword">in</span> <span class="built_in">enumerate</span>(t_s[<span class="number">1</span>:])&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> table_hash.items():</span><br><span class="line">        h.heappush(answer,(-<span class="built_in">sum</span>(t[<span class="number">1</span>][l]*preference[l_i] <span class="keyword">for</span> l_i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(languages) <span class="keyword">if</span> l <span class="keyword">in</span> t[<span class="number">1</span>]),t[<span class="number">0</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> h.heappop(answer)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/23/f67283951ab9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 디스크 컨트롤러</title>
      <link>https://sklubmk.github.io/2021/08/22/3f56f3c9af6f/</link>
      <guid>https://sklubmk.github.io/2021/08/22/3f56f3c9af6f/</guid>
      <pubDate>Sun, 22 Aug 2021 07:51:32 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.</p><p>예를들어</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 0ms 시점에 3ms가 소요되는 A작업 요청</span><br><span class="line">- 1ms 시점에 9ms가 소요되는 B작업 요청</span><br><span class="line">- 2ms 시점에 6ms가 소요되는 C작업 요청</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.\<br><img src="https://grepp-programmers.s3.amazonaws.com/files/production/b68eb5cec6/38dc6a53-2d21-4c72-90ac-f059729c51d5.png" alt="Screen Shot 2018-09-13 at 6.34.58 PM.png"></p><p>한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.\<br><img src="https://grepp-programmers.s3.amazonaws.com/files/production/5e677b4646/90b91fde-cac4-42c1-98b8-8f8431c52dcf.png" alt="Screen Shot 2018-09-13 at 6.38.52 PM.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)</span><br><span class="line">- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)</span><br><span class="line">- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.</p><p>하지만 A → C → B 순서대로 처리하면\<br><img src="https://grepp-programmers.s3.amazonaws.com/files/production/9eb7c5a6f1/a6cff04d-86bb-4b5b-98bf-6359158940ac.png" alt="Screen Shot 2018-09-13 at 6.41.42 PM.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)</span><br><span class="line">- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)</span><br><span class="line">- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.</p><p>각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)</p><h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><ul><li>jobs의 길이는 1 이상 500 이하입니다.</li><li>jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.</li><li>각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.</li><li>각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.</li><li>하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>jobs</th><th>return</th></tr></thead><tbody><tr><td>[[0, 3], [1, 9], [2, 6]]</td><td>9</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>문제에 주어진 예와 같습니다.</p><ul><li>0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.</li><li>1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.</li><li>2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">jobs</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(jobs)</span><br><span class="line">    jobs.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]);</span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> jobs:</span><br><span class="line">        hq = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(jobs) <span class="keyword">and</span> jobs[i][<span class="number">0</span>] &lt;= time:</span><br><span class="line">            h.heappush(hq,(jobs[i][<span class="number">1</span>],time-jobs[i][<span class="number">0</span>]+jobs[i][<span class="number">1</span>], i))</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(hq) == <span class="number">0</span>:</span><br><span class="line">            time = jobs[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_job = h.heappop(hq)</span><br><span class="line">            time += next_job[<span class="number">0</span>]</span><br><span class="line">            answer += next_job[<span class="number">1</span>]</span><br><span class="line">            jobs.pop(next_job[<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer//n</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>현재 시점 기준으로 요청된 작업들 중 가장 수행시간이 짧은 작업을 매번 선택하면 되고, 이는 <code>그리디</code> 처럼 작동한다.</p><p><br/></p><p><code>heap queue</code>를 활용하는 문제인데, 처음에 어떤 값을 넣어야 할지 혼동스러웠다. 결과 값으로 저장해야하는 값(처음 요청된 시간 ~ 요청 종료까지 시간)을 기준으로 <code>heap queue</code>에 담았는데, 이러다보니 작업시간이 짧지만 대기한 시간이 긴 작업들의 우선권이 뒤로 밀려버렸다.</p><p><br/></p><p>이내 수행시간을 기준으로 <code>heap queue</code>에 담아 문제를 푸니 정상적으로 풀이 되었다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/22/3f56f3c9af6f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 순위</title>
      <link>https://sklubmk.github.io/2021/08/21/583bf6e35728/</link>
      <guid>https://sklubmk.github.io/2021/08/21/583bf6e35728/</guid>
      <pubDate>Sat, 21 Aug 2021 12:57:25 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.</p><p>선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>선수의 수는 1명 이상 100명 이하입니다.</li><li>경기 결과는 1개 이상 4,500개 이하입니다.</li><li>results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.</li><li>모든 경기 결과에는 모순이 없습니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>results</th><th>return</th></tr></thead><tbody><tr><td>5</td><td>[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]</td><td>2</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.\<br>5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.</p><p><a href="http://contest.usaco.org/JAN08.htm">출처</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, results</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    wins = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">        winner, loser = r</span><br><span class="line">        wins[winner][loser] = <span class="number">1</span></span><br><span class="line">        wins[loser][winner] = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> visit <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> wins[start][end] == <span class="number">0</span> <span class="keyword">and</span> wins[start][visit] == wins[visit][end]:</span><br><span class="line">                    wins[start][end] = wins[start][visit]</span><br><span class="line">                    wins[end][start] = -<span class="number">1</span>*wins[start][visit]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> wins[i].count(<span class="number">0</span>) == <span class="number">2</span>: </span><br><span class="line">            answer+=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p> <code>1</code>. <code>A</code>가 <code>B</code>를 이겼다<br> <code>2</code>. <code>B</code>가 <code>C</code>를 이겼다<br> <code>3</code>. 따라서 <code>A</code>는 <code>C</code>를 이긴다</p><p>풀이를 위해선 <code>3</code>번의 간접적인 순위를 직접적인 순위관계로 변화시켜야한다.</p><p><br/></p><p>각 <strong>시작</strong>, <strong>방문</strong>, <strong>목적지</strong> 노드를 뜻하는 세 번의 반복문을 수행한다.</p><ol><li>시작 -&gt; 목적지 노드의 순위관계가 정해져 있지 않고,</li><li>시작 -&gt; 방문 노드의 순위 관계가 정해져있고,</li><li>방문 -&gt; 목적지 노드의 순위관계가 2번의 관계와 동일하다면, 이를 1번에 할당한다.</li></ol><p><br/></p><p>위 과정을 거치면 확실히 순위관계를 나타낼 수 있는 항목의 값들은 모두 값이 체워진다. 따라서 이러한 노드의 개수를 반환하면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/21/583bf6e35728/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 입국심사</title>
      <link>https://sklubmk.github.io/2021/08/20/79376bb85650/</link>
      <guid>https://sklubmk.github.io/2021/08/20/79376bb85650/</guid>
      <pubDate>Fri, 20 Aug 2021 14:04:36 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.</p><p>처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.</p><p>모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.</p><p>입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.</li><li>각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.</li><li>심사관은 1명 이상 100,000명 이하입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>times</th><th>return</th></tr></thead><tbody><tr><td>6</td><td>[7, 10]</td><td>28</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>가장 첫 두 사람은 바로 심사를 받으러 갑니다.</p><p>7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.</p><p>10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.</p><p>14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.</p><p>20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.</p><p><a href="http://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf">출처</a></p><p>※ 공지 - 2019년 9월 4일 문제에 새로운 테스트 케이스를 추가하였습니다. 도움을 주신 weaver9651 님께 감사드립니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, times</span>):</span></span><br><span class="line">    answer = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    left, right = <span class="number">1</span>, n*<span class="built_in">max</span>(times)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        cur_times= <span class="built_in">sum</span>(mid//t <span class="keyword">for</span> t <span class="keyword">in</span> times)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_times &gt;= n:</span><br><span class="line">            answer = <span class="built_in">min</span>(answer, mid)</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cur_times &lt; n:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>결과 값은 반드시 <code>times</code>에 포함된 한 값의 <strong>공배수</strong>가 되므로, <code>times</code>내의 값들을 탐색하며 정답을 찾으면 된다. <code>left</code>는 문제 조건의 최소값인 1을, <code>right</code>는 주어진 <code>times</code>의 최대값 x n을 할당한다. 정답은 반드시 이 두 범위 안에 존재하므로, 이분탐색을 활용하여 정답을 구한다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/20/79376bb85650/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 퍼즐 조각 채우기</title>
      <link>https://sklubmk.github.io/2021/08/18/8c559b93b60c/</link>
      <guid>https://sklubmk.github.io/2021/08/18/8c559b93b60c/</guid>
      <pubDate>Wed, 18 Aug 2021 11:08:19 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;퍼즐-조각-채우기&quot;&gt;&lt;a href=&quot;#퍼즐-조각-채우기&quot; class=&quot;headerlink&quot; title=&quot;퍼즐 조각 채우기&quot;&gt;&lt;/a&gt;퍼즐 조각 채우기&lt;/h1&gt;&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="퍼즐-조각-채우기"><a href="#퍼즐-조각-채우기" class="headerlink" title="퍼즐 조각 채우기"></a>퍼즐 조각 채우기</h1><p>Python3<br><span id="more"></span></p><p><br/></p><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><blockquote><p>테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.</p><ul><li>조각은 한 번에 하나씩 채워 넣습니다.</li><li>조각을 회전시킬 수 있습니다.</li><li>조각을 뒤집을 수는 없습니다.</li><li>게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.</li></ul><p>다음은 퍼즐 조각을 채우는 예시입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ab4d8aa2-f282-4764-bb46-84d405464b90/puzzle_5.png" alt="puzzle_5.png"></p><p>위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다.</p><p>이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/70e371ad-4306-412b-b53b-25208e52a513/puzzle_6.png" alt="puzzle_6.png"></p><ul><li>3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.</li><li>5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.</li></ul><p>다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dadd0bc1-8e38-4689-a480-26afa799a5a3/puzzle_7.png" alt="puzzle_7.png"></p><p>최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다.</p><p>현재 게임 보드의 상태 <code>game_board</code>, 테이블 위에 놓인 퍼즐 조각의 상태 <code>table</code>이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요.</p><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>3 ≤ <code>game_board</code>의 행 길이 ≤ 50</li><li><code>game_board</code>의 각 열 길이 = <code>game_board</code>의 행 길이<ul><li>즉, 게임 보드는 정사각 격자 모양입니다.</li><li><code>game_board</code>의 모든 원소는 0 또는 1입니다.</li><li>0은 빈칸, 1은 이미 채워진 칸을 나타냅니다.</li><li>퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.</li></ul></li><li><code>table</code>의 행 길이 = <code>game_board</code>의 행 길이</li><li><code>table</code>의 각 열 길이 = <code>table</code>의 행 길이<ul><li>즉, 테이블은 <code>game_board</code>와 같은 크기의 정사각 격자 모양입니다.</li><li><code>table</code>의 모든 원소는 0 또는 1입니다.</li><li>0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다.</li><li>퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.</li></ul></li><li><code>game_board</code>에는 반드시 하나 이상의 빈칸이 있습니다.</li><li><code>table</code>에는 반드시 하나 이상의 블록이 놓여 있습니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>game_board</th><th>table</th><th>result</th></tr></thead><tbody><tr><td>[[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]]</td><td>[[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]]</td><td>14</td></tr><tr><td>[[0,0,0],[1,1,0],[1,1,1]]</td><td>[[1,1,1],[1,0,0],[0,0,0]]</td><td>0</td></tr></tbody></table></div><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>입력은 다음과 같은 형태이며, 문제의 예시와 같습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/653b44d8-0fa6-42f8-aa9d-ceca639b0ad4/puzzle_9.png" alt="puzzle_9.png"></p><p>입출력 예 #2</p><p>블록의 회전은 가능하지만, 뒤집을 수는 없습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">game_board, table</span>):</span></span><br><span class="line">    directions = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    N = <span class="built_in">len</span>(table)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 저장 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkingPuzzle</span>(<span class="params">pos,blocks,checkValue,board</span>):</span></span><br><span class="line">        x,y = pos</span><br><span class="line">        <span class="keyword">if</span> board[y][x] == checkValue:</span><br><span class="line">            blocks.append((x,y))</span><br><span class="line">            board[y][x] = <span class="number">0</span> <span class="keyword">if</span> checkValue == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="keyword">if</span> -<span class="number">1</span> &lt; x+d[<span class="number">0</span>] &lt; N <span class="keyword">and</span> -<span class="number">1</span> &lt; y+d[<span class="number">1</span>] &lt; N:</span><br><span class="line">                    checkingPuzzle((x+d[<span class="number">0</span>],y+d[<span class="number">1</span>]),blocks,checkValue,board)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 좌표 변환 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">syncBlocks</span>(<span class="params">blocks</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(blocks) == <span class="number">1</span>: <span class="keyword">return</span> [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        blocks = <span class="built_in">sorted</span>(blocks)        </span><br><span class="line">        sync_x, sync_y = blocks[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> [ (b[<span class="number">0</span>]-sync_x,b[<span class="number">1</span>]-sync_y) <span class="keyword">for</span> b <span class="keyword">in</span> blocks]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 회전 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatingPuzzle</span>(<span class="params">blocks</span>):</span></span><br><span class="line">        result = [blocks,[],[],[]]</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> blocks:</span><br><span class="line">            x,y = b</span><br><span class="line">            result[<span class="number">1</span>].append((N-y,x))</span><br><span class="line">            result[<span class="number">2</span>].append((N-x,N-y))</span><br><span class="line">            result[<span class="number">3</span>].append((y,N-x))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 및 게임보드 빈 공간 저장</span></span><br><span class="line">    puzzles = []</span><br><span class="line">    blanks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N*N):</span><br><span class="line">        <span class="keyword">if</span> table[i//N][i%N] == <span class="number">1</span>: <span class="comment"># 테이블 위 퍼즐 저장</span></span><br><span class="line">            puzzles.append([])</span><br><span class="line">            checkingPuzzle( (i%N,i//N), puzzles[-<span class="number">1</span>], <span class="number">1</span>, table)</span><br><span class="line">        <span class="keyword">if</span> game_board[i//N][i%N] == <span class="number">0</span>: <span class="comment"># 게임보드 빈 공간 저장</span></span><br><span class="line">            blanks.append([])</span><br><span class="line">            checkingPuzzle( (i%N,i//N), blanks[-<span class="number">1</span>], <span class="number">0</span>, game_board)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 회전체 추가 및 좌표 변환</span></span><br><span class="line">    <span class="keyword">for</span> p_i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(puzzles):</span><br><span class="line">        puzzles[p_i] = []</span><br><span class="line">        <span class="keyword">for</span> r_i, r <span class="keyword">in</span> <span class="built_in">enumerate</span>(rotatingPuzzle(p)):</span><br><span class="line">            puzzles[p_i].append(syncBlocks(r))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 게임 보드 빈 공간 좌표 변환</span></span><br><span class="line">    <span class="keyword">for</span> b_i,b <span class="keyword">in</span> <span class="built_in">enumerate</span>(blanks):</span><br><span class="line">        blanks[b_i] = syncBlocks(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 두 값 비교</span></span><br><span class="line">    <span class="keyword">for</span> p_i,p <span class="keyword">in</span> <span class="built_in">enumerate</span>( (puzzles) ):</span><br><span class="line">        <span class="keyword">for</span> rotate <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span> rotate <span class="keyword">in</span> blanks:</span><br><span class="line">                answer += <span class="built_in">len</span>(rotate)</span><br><span class="line">                blanks.remove(rotate)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/18/8c559b93b60c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 상호 평가</title>
      <link>https://sklubmk.github.io/2021/08/16/5a27c5948dfc/</link>
      <guid>https://sklubmk.github.io/2021/08/16/5a27c5948dfc/</guid>
      <pubDate>Sun, 15 Aug 2021 16:19:45 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;상호-평가&quot;&gt;&lt;a href=&quot;#상호-평가&quot; class=&quot;headerlink&quot; title=&quot;상호 평가&quot;&gt;&lt;/a&gt;상호 평가&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="상호-평가"><a href="#상호-평가" class="headerlink" title="상호 평가"></a>상호 평가</h1><p>Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td><del>100</del></td><td>90</td><td>98</td><td>88</td><td>65</td></tr><tr><td>1</td><td>50</td><td><del>45</del></td><td>99</td><td>85</td><td>77</td></tr><tr><td>2</td><td>47</td><td>88</td><td>95</td><td>80</td><td>67</td></tr><tr><td>3</td><td>61</td><td>57</td><td>100</td><td>80</td><td>65</td></tr><tr><td>4</td><td>24</td><td>90</td><td>94</td><td>75</td><td>65</td></tr><tr><td>평균</td><td>45.5</td><td>81.25</td><td>97.2</td><td>81.6</td><td>67.8</td></tr><tr><td>학점</td><td>F</td><td>B</td><td>A</td><td>B</td><td>D</td></tr></tbody></table></div><p>위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.</p><ul><li>0번 학생이 평가한 점수는 0번 <code>행</code>에담긴 [100, 90, 98, 88, 65]입니다.<ul><li>0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.</li></ul></li><li>2번 학생이 평가한 점수는 2번 <code>행</code>에담긴 [47, 88, 95, 80, 67]입니다.<ul><li>2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.</li></ul></li></ul><p>당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.\<br>만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.</p><ul><li>0번 학생이 받은 점수는 0번 <code>열</code>에 담긴 [<code>100</code>, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.<ul><li>0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.</li></ul></li><li>4번 학생이 받은 점수는 4번 <code>열</code>에 담긴 [65, 77, 67, 65, <code>65</code>]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.<ul><li>4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.</li></ul></li></ul><p>제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.</p><div class="table-container"><table><thead><tr><th>평균</th><th>학점</th></tr></thead><tbody><tr><td>90점 이상</td><td>A</td></tr><tr><td>80점 이상 90점 미만</td><td>B</td></tr><tr><td>70점 이상 80점 미만</td><td>C</td></tr><tr><td>50점 이상 70점 미만</td><td>D</td></tr><tr><td>50점 미만</td><td>F</td></tr></tbody></table></div><p>학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.</p><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>2 ≤ <code>scores</code>의 행의 길이(학생 수) ≤ 10</li><li><p><code>scores</code>의 열의 길이 = <code>scores</code>의 행의 길이</p><ul><li>즉, <code>scores</code>는 행과 열의 길이가 같은 2차원 배열입니다.</li></ul></li><li><p>0 ≤ <code>scores</code>의 원소 ≤ 100</p></li><li>return 값 형식<ul><li>0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.</li></ul></li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>scores</th><th>result</th></tr></thead><tbody><tr><td>[[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]</td><td><code>&quot;FBABD&quot;</code></td></tr><tr><td>[[50,90],[50,87]]</td><td><code>&quot;DA&quot;</code></td></tr><tr><td>[[70,49,90],[68,50,38],[73,31,100]]</td><td><code>&quot;CFD&quot;</code></td></tr></tbody></table></div><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>문제 예시와 같습니다.</p><p>입출력 예 #2</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td></tr><tr><td>0</td><td>50</td><td>90</td></tr><tr><td>1</td><td>50</td><td><del>87</del></td></tr><tr><td>평균</td><td>50</td><td>90</td></tr><tr><td>학점</td><td>D</td><td>A</td></tr></tbody></table></div><ul><li>1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.</li></ul><p>입출력 예 #3</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td></tr><tr><td>0</td><td>70</td><td>49</td><td>90</td></tr><tr><td>1</td><td>68</td><td><del>50</del></td><td>38</td></tr><tr><td>2</td><td>73</td><td>31</td><td><del>100</del></td></tr><tr><td>평균</td><td>70.33…</td><td>40</td><td>64</td></tr><tr><td>학점</td><td>C</td><td>F</td><td>D</td></tr></tbody></table></div><ul><li>1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.</li><li>2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">scores</span>):</span></span><br><span class="line">    scores = [[score[r] <span class="keyword">for</span> score <span class="keyword">in</span> scores] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores))]</span><br><span class="line">    grade = [(<span class="number">90</span>,<span class="string">&#x27;A&#x27;</span>),(<span class="number">80</span>,<span class="string">&#x27;B&#x27;</span>),(<span class="number">70</span>,<span class="string">&#x27;C&#x27;</span>),(<span class="number">50</span>,<span class="string">&#x27;D&#x27;</span>),(<span class="number">0</span>,<span class="string">&#x27;F&#x27;</span>)]</span><br><span class="line">    grading = <span class="keyword">lambda</span> x: <span class="built_in">next</span>(v[<span class="number">1</span>] <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(grade) <span class="keyword">if</span> x &gt;= v[<span class="number">0</span>])</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> idx, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(scores):</span><br><span class="line">        without_self = [s <span class="keyword">for</span> i,s <span class="keyword">in</span> <span class="built_in">enumerate</span>(score) <span class="keyword">if</span> i != idx]</span><br><span class="line">        <span class="keyword">if</span> score[idx] &gt; <span class="built_in">max</span>(without_self) <span class="keyword">or</span> score[idx] &lt; <span class="built_in">min</span>(without_self):</span><br><span class="line">            answer += grading(<span class="built_in">sum</span>(without_self) / <span class="built_in">len</span>(without_self))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += grading(<span class="built_in">sum</span>(score) / <span class="built_in">len</span>(score))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><br/></p><h2 id="풀이-과정"><a href="#풀이-과정" class="headerlink" title="풀이 과정"></a>풀이 과정</h2><ol><li>행열 전환</li><li>성적 산출 함수 구현</li><li>결과 도출</li></ol><p><br/></p><h2 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h2><h3 id="행열-전환하기-행-lt-gt-열"><a href="#행열-전환하기-행-lt-gt-열" class="headerlink" title="[ 행열 전환하기 (행 &lt;-&gt; 열) ]"></a><code>[ 행열 전환하기 (행 &lt;-&gt; 열) ]</code></h3><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores = [[score[r] <span class="keyword">for</span> score <span class="keyword">in</span> scores] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores))]</span><br></pre></td></tr></table></figure></div><p><br/></p><h3 id="성적-산출"><a href="#성적-산출" class="headerlink" title="[ 성적 산출 ]"></a><code>[ 성적 산출 ]</code></h3><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grade = [(<span class="number">90</span>,<span class="string">&#x27;A&#x27;</span>),(<span class="number">80</span>,<span class="string">&#x27;B&#x27;</span>),(<span class="number">70</span>,<span class="string">&#x27;C&#x27;</span>),(<span class="number">50</span>,<span class="string">&#x27;D&#x27;</span>),(<span class="number">0</span>,<span class="string">&#x27;F&#x27;</span>)]</span><br><span class="line">grading = <span class="keyword">lambda</span> x: <span class="built_in">next</span>(v[<span class="number">1</span>] <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(grade) <span class="keyword">if</span> x &gt;= v[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li><code>python</code>의 <code>tuple</code>을 이용해 성적 산출을 리스트로 구현했다.</li></ul><p><br/></p><h3 id="결과-도출"><a href="#결과-도출" class="headerlink" title="[ 결과 도출 ]"></a><code>[ 결과 도출 ]</code></h3><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> idx, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(scores):</span><br><span class="line">    without_self = [s <span class="keyword">for</span> i,s <span class="keyword">in</span> <span class="built_in">enumerate</span>(score) <span class="keyword">if</span> i != idx]</span><br><span class="line">    <span class="keyword">if</span> score[idx] &gt; <span class="built_in">max</span>(without_self) <span class="keyword">or</span> score[idx] &lt; <span class="built_in">min</span>(without_self):</span><br><span class="line">        answer += grading(<span class="built_in">sum</span>(without_self) / <span class="built_in">len</span>(without_self))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer += grading(<span class="built_in">sum</span>(score) / <span class="built_in">len</span>(score))</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>자신의 점수를 제외한 <code>without_self</code> 리스트를 만든다.</li><li>현재 값이 <code>without_self</code>의 <strong>최대값</strong>보다 크거나 <strong>최소값</strong>보다 작으면 제외한다.<ul><li>자신의 점수가 제외된 <code>without_self</code>로 평균 점수와 성적을 산출한다.</li></ul></li><li>그게 아니면 전체 값으로 성적을 산출한다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/16/5a27c5948dfc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 부족한 금액 계산하기</title>
      <link>https://sklubmk.github.io/2021/08/16/ce5d6cfa269c/</link>
      <guid>https://sklubmk.github.io/2021/08/16/ce5d6cfa269c/</guid>
      <pubDate>Sun, 15 Aug 2021 16:19:17 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;부족한-금액-계산하기&quot;&gt;&lt;a href=&quot;#부족한-금액-계산하기&quot; class=&quot;headerlink&quot; title=&quot;부족한 금액 계산하기&quot;&gt;&lt;/a&gt;부족한 금액 계산하기&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="부족한-금액-계산하기"><a href="#부족한-금액-계산하기" class="headerlink" title="부족한 금액 계산하기"></a>부족한 금액 계산하기</h1><p>Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\<br>놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.\<br>단, 금액이 부족하지 않으면 0을 return 하세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수</li><li>처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수</li><li>놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>price</th><th>money</th><th>count</th><th>result</th></tr></thead><tbody><tr><td>3</td><td>20</td><td>4</td><td>10</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1\<br>이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">price, money, count</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, (price * count * (count+<span class="number">1</span>) / <span class="number">2</span>) - money )</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/16/ce5d6cfa269c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 뉴스 클러스터링</title>
      <link>https://sklubmk.github.io/2021/08/13/dec5e25d4d7a/</link>
      <guid>https://sklubmk.github.io/2021/08/13/dec5e25d4d7a/</guid>
      <pubDate>Fri, 13 Aug 2021 08:37:51 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;1차-뉴스-클러스터링&quot;&gt;&lt;a href=&quot;#1차-뉴스-클러스터링&quot; class=&quot;headerlink&quot; title=&quot;[1차] 뉴스 클러스터링&quot;&gt;&lt;/a&gt;[1차] 뉴스 클러스터링&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="1차-뉴스-클러스터링"><a href="#1차-뉴스-클러스터링" class="headerlink" title="[1차] 뉴스 클러스터링"></a>[1차] 뉴스 클러스터링</h1><p>Python3</p><span id="more"></span><p><br/></p><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><blockquote><h2 id="뉴스-클러스터링"><a href="#뉴스-클러스터링" class="headerlink" title="뉴스 클러스터링"></a>뉴스 클러스터링</h2><p>여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.</p><p>개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 “카카오 신입 개발자 공채” 관련 기사를 검색해보았다.</p><ul><li>카카오 첫 공채..’블라인드’ 방식 채용</li><li>카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용</li><li>카카오, 블라인드 전형으로 신입 개발자 공채</li><li>카카오 공채, 신입 개발자 코딩 능력만 본다</li><li>카카오, 신입 공채.. “코딩 실력만 본다”</li><li>카카오 “코딩 능력만으로 2018 신입 개발자 뽑는다”</li></ul><p>기사의 제목을 기준으로 “블라인드 전형”에 주목하는 기사와 “코딩 테스트”에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.</p><p>유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 “자카드 유사도”라는 방법을 찾아냈다.</p><p>자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 <code>A</code>, <code>B</code> 사이의 자카드 유사도 <code>J(A, B)</code>는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.</p><p>예를 들어 집합 <code>A</code> = {1, 2, 3}, 집합 <code>B</code> = {2, 3, 4}라고 할 때, 교집합 <code>A ∩ B</code> = {2, 3}, 합집합 <code>A ∪ B</code> = {1, 2, 3, 4}이 되므로, 집합 <code>A</code>, <code>B</code> 사이의 자카드 유사도 <code>J(A, B)</code> = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 <code>J(A, B)</code> = 1로 정의한다.</p><p>자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 <code>A</code>는 원소 “1”을 3개 가지고 있고, 다중집합 <code>B</code>는 원소 “1”을 5개 가지고 있다고 하자. 이 다중집합의 교집합 <code>A ∩ B</code>는 원소 “1”을 min(3, 5)인 3개, 합집합 <code>A ∪ B</code>는 원소 “1”을 max(3, 5)인 5개 가지게 된다. 다중집합 <code>A</code> = {1, 1, 2, 2, 3}, 다중집합 <code>B</code> = {1, 2, 2, 4, 5}라고 하면, 교집합 <code>A ∩ B</code> = {1, 2, 2}, 합집합 <code>A ∪ B</code> = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 <code>J(A, B)</code> = 3/7, 약 0.42가 된다.</p><p>이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 “FRANCE”와 “FRENCH”가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 <code>J(&quot;FRANCE&quot;, &quot;FRENCH&quot;)</code> = 2/8 = 0.25가 된다.</p><h2 id="입력-형식"><a href="#입력-형식" class="headerlink" title="입력 형식"></a>입력 형식</h2><ul><li>입력으로는 <code>str1</code>과 <code>str2</code>의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.</li><li>입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 “ab+”가 입력으로 들어오면, “ab”만 다중집합의 원소로 삼고, “b+”는 버린다.</li><li>다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. “AB”와 “Ab”, “ab”는 같은 원소로 취급한다.</li></ul><h2 id="출력-형식"><a href="#출력-형식" class="headerlink" title="출력 형식"></a>출력 형식</h2><p>입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.</p><h2 id="예제-입출력"><a href="#예제-입출력" class="headerlink" title="예제 입출력"></a>예제 입출력</h2><div class="table-container"><table><thead><tr><th>str1</th><th>str2</th><th>answer</th></tr></thead><tbody><tr><td>FRANCE</td><td>french</td><td>16384</td></tr><tr><td>handshake</td><td>shake hands</td><td>65536</td></tr><tr><td>aa1+aa2</td><td>AAAA12</td><td>43690</td></tr><tr><td>E=M*C^2</td><td>e=m*c^2</td><td>65536</td></tr></tbody></table></div><p><a href="http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/">해설 보러가기</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    split = <span class="keyword">lambda</span> x:[x[i:i+<span class="number">2</span>].lower() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)-<span class="number">1</span>) <span class="keyword">if</span> x[i:i+<span class="number">2</span>].isalpha()]</span><br><span class="line">    summary = <span class="keyword">lambda</span> arr: &#123;i:arr.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> arr&#125;</span><br><span class="line">    a_sum, b_sum = summary(split(str1)), summary(split(str2))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a_sum) + <span class="built_in">len</span>(b_sum) == <span class="number">0</span> : <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line">    </span><br><span class="line">    intersection = <span class="built_in">sum</span>([<span class="built_in">min</span>(a_sum[a],b_sum[a]) <span class="keyword">for</span> a <span class="keyword">in</span> a_sum <span class="keyword">if</span> a <span class="keyword">in</span> b_sum]);</span><br><span class="line">    union = <span class="built_in">sum</span>(a_sum.values()) + <span class="built_in">sum</span>(b_sum.values()) - intersection;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(intersection/union * <span class="number">65536</span>);</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><h2 id="풀이-전략"><a href="#풀이-전략" class="headerlink" title="풀이 전략"></a>풀이 전략</h2><p><br/></p><p>문제의 조건을 구현할 수 있는 피지컬을 요하는 <code>구현</code> 문제다.</p><p>문제는 크게 2가지 과정으로 풀이 된다.</p><ol><li>주어진 두 배열을 각각 2글자로 이루어진 원소의 집합으로 만들기</li><li>두 집합으로 교집합과 합집합 계산 및 결과 반환하기</li></ol><p><br/></p><h2 id="2글자-집합-만들기"><a href="#2글자-집합-만들기" class="headerlink" title="2글자 집합 만들기"></a>2글자 집합 만들기</h2><p><br/></p><p>문제의 조건대로 2글자씩 배열을 나눈 뒤, 이를 <code>알파벳</code>인지 검사한다. 이 때 python 내장함수 <code>isalpha()</code>를 사용한다. 만약 알파벳이 맞다면 <code>lower()</code> 함수를 이용해 소문자 단어로 변환하여 배열에 저장한다. 결과적으로 소문자 2개로 이루어진 원소들을 가지는 집합이 된다.</p><p>예시 : [<code>fr</code>, <code>ra</code>, <code>an</code>, <code>nc</code>, <code>ce</code>, <code>fr</code>, <code>re</code>, <code>en</code>, <code>nc</code>, <code>ch</code>]</p><p><br/></p><p>여기서 각 단어 개수를 카운팅하여 <code>dictionary</code>로 저장한다. 이때 <code>count</code> 함수를 활용한다.</p><p>예시 : {<code>fr</code>:<code>2</code>, <code>nc</code>:<code>2</code>, <code>ra</code>:<code>1</code>,<code>an</code>:<code>1</code> , …}</p><p><br/></p><h2 id="교집합-intersection"><a href="#교집합-intersection" class="headerlink" title="교집합 (intersection)"></a>교집합 (intersection)</h2><p><br/></p><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intersection = <span class="built_in">sum</span>([<span class="built_in">min</span>(a_sum[a],b_sum[a]) <span class="keyword">for</span> a <span class="keyword">in</span> a_sum <span class="keyword">if</span> a <span class="keyword">in</span> b_sum])</span><br></pre></td></tr></table></figure></div><p>두 집합에 동시에 속한 단어가 있다면 해당 단어 <code>counting</code>의 최소 값을 모아 합산 한다.</p><p><br/></p><h2 id="합집합-union"><a href="#합집합-union" class="headerlink" title="합집합 (union)"></a>합집합 (union)</h2><p><br/></p><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union = <span class="built_in">sum</span>(a_sum.values()) + <span class="built_in">sum</span>(b_sum.values()) - intersection</span><br></pre></td></tr></table></figure></div><p>합집합은 두 집합의 전체 값 - 교집합으로 계산할 수 있다. 따라서 각 집합 결과의 <code>sum</code>을 더해 앞서 계산한 교집합 값을 빼면 된다.</p><p>이후, 교집합 값과 합집합 값을 문제 조건대로 계산하여 반환하면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B5%AC%ED%98%84/">구현</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/13/dec5e25d4d7a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[알고리즘] 정렬 알고리즘</title>
      <link>https://sklubmk.github.io/2021/08/13/54aee196b995/</link>
      <guid>https://sklubmk.github.io/2021/08/13/54aee196b995/</guid>
      <pubDate>Thu, 12 Aug 2021 15:34:18 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;버블 정렬 (&lt;code&gt;Bubble Sort&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;선택 정렬 (&lt;code&gt;Selection Sort&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;삽입 정렬 (&lt;code&gt;Insertion Sort&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;그외 정렬 알고리즘들&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>버블 정렬 (<code>Bubble Sort</code>)</li><li>선택 정렬 (<code>Selection Sort</code>)</li><li>삽입 정렬 (<code>Insertion Sort</code>)</li><li>그외 정렬 알고리즘들</li></ul><span id="more"></span><p><br/></p><h1 id="버블정렬-Bubble-Sort"><a href="#버블정렬-Bubble-Sort" class="headerlink" title="버블정렬 (Bubble Sort)"></a>버블정렬 (Bubble Sort)</h1><hr><h2 id="동작원리"><a href="#동작원리" class="headerlink" title="동작원리"></a>동작원리</h2><ul><li>배열의 <code>0</code>번부터 <code>N-1</code>번까지 탐색을 하면서 인접한 칸과 비교하여 <code>swap</code> 하는 방식</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="https://t1.daumcdn.net/cfile/tistory/9999CE475CC465A407" /></p><p><img style="margin: 1rem auto; width:80%; display: block;" src="https://t1.daumcdn.net/cfile/tistory/99587F465CC465D501" /></p><p><br/></p><ul><li>Bubble 정렬을 오름차순으로 1회 실시하고 나서의 결과</li><li><code>j</code>번째 값과 <code>j+1</code>번째 값을 비교해서 만약 <code>j</code>번째의 값이 더 크다면 <code>swap</code> 해주는 식으로 동작</li><li>위의 과정을 첫번째는 <code>0</code> ~ <code>N-1</code>번까지, 두 번째는 <code>0</code> ~ <code>N-2</code>번까지, 세 번째는 <code>0</code> ~ <code>N-3</code>번까지 … 식으로 진행되는데 이유는 위의 과정을 보면 알겠지만, 1회 실시하고 나게 되면 최댓값이 가장 마지막으로 가게 된다는 것을 알 수 있다.</li><li>즉, 2번째 과정에서는 이미 최댓값 위치에 저장되어있는 가장 마지막 값을 건드릴 필요가 없다.</li></ul><p><br/></p><h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a><strong>시간복잡도</strong></h2><ul><li>처음에는 <code>N-1</code>번탐색, 두 번째는 <code>N-2</code>번 탐색, … 이런식으로 진행되므로<br>총 <code>N-1</code> + <code>N-2</code> + <code>N-3</code> + <code>N-4</code> + <code>...</code> + <code>1</code> 번 진행 = <script type="math/tex">\cfrac{N(N-1)}2</script></li><li><p>식의 유도</p><ul><li>1, 2, 3, 4, 5 가 존재할 때, 1회 탐색할때 총 1부터 5까지 4번 탐색을 하게된다.</li><li>2회 탐색할 때에는 1부터 4까지 3번탐색, 3회는 2번, 4회는 1번 … 총 4 + 3 + 2 + 1 = 10회 탐색을 하게된다.</li><li>이 10을 식을 이용해서 도출해 내면 (5 x 4) / 2로 표현할 수 있게 된다. 따라서 위의 식 만큼의 탐색을 하게 된다.</li><li>따라서  <script type="math/tex">\cfrac12N^2 - \cfrac12N</script> 이라는 시간복잡도를 갖게 되고, <script type="math/tex">O(N^2)</script> 으로 표기할 수 있다.</li></ul></li><li><p><strong>worst case</strong></p><ul><li>역방향으로 정렬이 되어 있는 경우</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li><strong>best case</strong><ul><li>이미 정렬이 되어 있는 경우</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li>즉, Bubble정렬의 경우 최악이든 최선이든 똑같이 <strong><script type="math/tex">O(N^2)</script></strong>만큼의 시간복잡도를 갖게 된다.</li></ul><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%209.png" /></p><p><br/></p><p><br/></p><h1 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬 (Selection Sort)"></a>선택 정렬 (Selection Sort)</h1><hr><h2 id="동작-원리"><a href="#동작-원리" class="headerlink" title="동작 원리"></a>동작 원리</h2><ul><li>가장 먼저 제일 앞에 값을 ‘최소값을 가진 Index’ 라고 가정을 하고 탐색 시작.</li><li>탐색 진행 중, 만약 ‘최소값을 가진 Index’보다 더 작은 값을 가진 값이 나오면, ‘최소값을 가진 Index’를 더 작은 값을가진 Index번호로 변경. 이 과정을 <code>N-1</code>번까지 진행.</li><li>이후에, 제일 앞 Index 번호와, 최소값을 가진 Index번호가 다르다면 <code>swap</code> 해주면 되는 방식</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%2010.png" /></p><ul><li>위 그림은 1회전 시켰을 때의 결과값이다.</li><li>그렇다면 2회전 시킬 때 시작점을 어디로 잡으면될까?<ul><li>1번으로 시작하면 된다.</li><li>왜냐하면 0번에는 이미 최소값이 자기 자리를 찾아서 정렬되어 있기 때문에 더 이상 관리할 필요가 없기 때문이다.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선택정렬 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 0부터 끝까지 전체탐색</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAX; i++)&#123;</span><br><span class="line">    <span class="comment">// 가장 작은 값이 저장된 Index를 탐색을 시작하는 Index로 가정하고 탐색시작.</span></span><br><span class="line">    <span class="keyword">int</span> Min_Index = i;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// i + 1번부터 끝까지 탐색을 하는데</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i  + <span class="number">1</span>; i j &lt; MAX; j++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 만약 더 작은 값이 나오면 Min_Index값 변경</span></span><br><span class="line">        <span class="keyword">if</span>(Arr[j] &lt; Arr[Min_Index]) Min_Index = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 변화가 있었다면 swap.</span></span><br><span class="line">    <span class="keyword">if</span>(i != Min_Index) <span class="built_in">swap</span>(Arr[i], Arr[Min_Index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ul><li>선택정렬의 경우, 가장 처음에 총 <code>N-1</code>번의 탐색을 하게 된다.</li><li>2회전 때는 정렬된 가장 첫번째 값(최소값)을 빼고 <code>N-2</code>번 탐색을 하게된다.</li><li>즉, 끝까지 탐색을 하게되면 결과적으로 <code>N-1</code> + <code>N-2</code> + <code>N-3</code> + <code>...</code> + <code>1</code> 번 탐색.</li><li>이를 수식으로 나타내면  <script type="math/tex">\cfrac12N^2 - \cfrac12N</script> 번 탐색을 하게되고, <script type="math/tex">O(N^2)</script>이 된다.</li><li><strong>worst case</strong><ul><li>역방향으로 정렬되어 있는 경우</li><li><code>N-1</code> + <code>N-2</code> + <code>N-3</code> + <code>...</code> + <code>1</code>번 탐색</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li><strong>best case</strong><ul><li>이미 정렬이 되어 있는 경우</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li></ul><p><br/></p><p><br/></p><h1 id="삽입-정렬-Insertion-Sort"><a href="#삽입-정렬-Insertion-Sort" class="headerlink" title="삽입 정렬 (Insertion Sort)"></a>삽입 정렬 (Insertion Sort)</h1><hr><h2 id="동작-원리-1"><a href="#동작-원리-1" class="headerlink" title="동작 원리"></a>동작 원리</h2><ul><li>삽입정렬은 앞으로 가면서 탐색을 진행한다.</li><li><code>N</code>만큼의 크기의 배열을 선언하고 <code>0</code>부터 <code>N-1</code> 번까지의 배열을 사용할때, Index 1번부터 탐색을 진행한다.</li><li>왜냐하면 앞으로 가면서 탐색을 하는 방식이기 때문에 0번 Index는 의미가 없기 때문</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%2011.png" /></p><ul><li>앞부분에 대해서만 정렬하는 과정</li><li>시작 Index를 기점으로 앞으로 쭉 탐색을 진행하는데, 2가지 조건이 있다.<ol><li>Index가 0보다 크거나 같을때<ul><li>0보다 작은 Index는 존재하지 않기 때문에 아무리 탐색을 많이 하더라도 0보다 크거나 같을 때 까지만 탐색이 가능하다.</li></ul></li><li>비교하는 값이 더 클때<ul><li>앞의 값이 더 크다면 <strong>특정한 과정</strong>을 진행한 후 탐색을 계속하지만, 값이 더 작으면 앞쪽 배열은 이미 정렬이 완료된 상태 그대로 탐색을 종료한다.</li></ul></li></ol></li><li>특별한 과정<ul><li>현재 값을 Temp 에 저장하고, 비교 값(Temp보다 작은 값)을 현재 index에 복사.</li><li>만약 비교값이 같거나 크다면 해당 비교 index에 Temp값 삽입</li><li>비교값의 index가 0보다 작아지기 전까지 위 과정 반복</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1번 Index부터 마지막 Index까지 탐색. 0번 Index는 탐색 X</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> Cur_Index = <span class="number">1</span>; Cur_Index &lt; MAX; Cur_Index++)&#123;</span><br><span class="line">    <span class="comment">// 현재의 값을 Temp라는 임시 저장 변수에 저장.</span></span><br><span class="line">    <span class="keyword">int</span> Temp = Arr[Cur_Index];</span><br><span class="line">    <span class="comment">// Index를 관리하는 변수. 현재 Index - 1번부터 탐색 시작.</span></span><br><span class="line">    <span class="keyword">int</span> Before_Index = Cur_Index <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Index번호가 0보다 크거나 같고, 이전 값이 더 큰 경우만</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( Before_Index &gt;= <span class="number">0</span> &amp;&amp; Arr[Before_Index] &gt; Temp &#123;</span><br><span class="line">      <span class="comment">// 값을 그대로 복사해서 넣어주고</span></span><br><span class="line">      Arr[Before_Index + <span class="number">1</span>] = Arr[Befored_Index];</span><br><span class="line">      <span class="comment">// 탐색 계속해서 진행</span></span><br><span class="line">      Before_Index = Before_Index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 탐색이 종료되면, 올바른 배열을 만들어 주기 위해서 값 삽입.</span></span><br><span class="line">    Arr[Before_Index + <span class="number">1</span>] = Temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="시간-복잡도-1"><a href="#시간-복잡도-1" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ul><li>삽입정렬은 최악의 경우와 최선의 경우 시간의 차이가 많이 정렬법이다.</li><li><strong>worst case</strong><ul><li>역정렬 되어있는 경우</li><li><script type="math/tex">\cfrac{N(N-1)}2</script> 번 시행</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li><strong>best case</strong><ul><li>이미 정렬이 되어있는 경우</li><li>모든 현재값이 비교값보다 같거나 크므로 1번씩 x N 번 시행</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li></ul><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%2012.png" /></p><p><br/></p><p><br/></p><h1 id="다른-정렬-알고리즘"><a href="#다른-정렬-알고리즘" class="headerlink" title="다른 정렬 알고리즘"></a>다른 정렬 알고리즘</h1><hr><h2 id="퀵소트-quick-sort-알고리즘"><a href="#퀵소트-quick-sort-알고리즘" class="headerlink" title="퀵소트(quick sort) 알고리즘"></a>퀵소트(quick sort) 알고리즘</h2><ul><li>최악의 경우 <script type="math/tex">O(N^2)</script>, 하지만 평균 시간복잡도는 <strong><script type="math/tex">O(Nlog_2{N})</script></strong></li></ul><p><br/></p><h2 id="합병정렬-merge-sort"><a href="#합병정렬-merge-sort" class="headerlink" title="합병정렬(merge sort)"></a>합병정렬(merge sort)</h2><p>최악의 경우 <strong><script type="math/tex">O(Nlog_2{N})</script></strong></p><p><br/></p><h2 id="힙-정렬-heap-sort"><a href="#힙-정렬-heap-sort" class="headerlink" title="힙 정렬(heap sort)"></a>힙 정렬(heap sort)</h2><p>최악의 경우 <strong><script type="math/tex">O(Nlog_2{N})</script></strong></p><p><br/></p><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><p><a href="https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C/da">영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠) - 인프런</a></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B0%9C%EB%85%90/">개념</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B0%9C%EB%85%90/">개념</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/13/54aee196b995/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[알고리즘] 시간복잡도와 점근적 표기법</title>
      <link>https://sklubmk.github.io/2021/08/12/ddfce68ef73c/</link>
      <guid>https://sklubmk.github.io/2021/08/12/ddfce68ef73c/</guid>
      <pubDate>Wed, 11 Aug 2021 15:31:02 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시간복잡도&lt;/li&gt;
&lt;li&gt;점근적 표기법&lt;/li&gt;
&lt;li&gt;복잡도 비교&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>시간복잡도</li><li>점근적 표기법</li><li>복잡도 비교</li></ul><span id="more"></span><p><br/></p><p><br/></p><h1 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h1><hr><ul><li>실행시간의 분석 : 실행시간은 실행환경에 따라 달라짐<ul><li>하드웨어, 운영체제, 언어, 컴파일러 등</li></ul></li><li>실행 시간을 측정하는 대신 연산의 실행 횟수를 카운트</li><li>연산의 실행 횟수는 입력 데이터의 크기에 관한 함수로 표현</li><li>데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐<ul><li>최악의 경우 시간복잡도 (<code>worst-case analysis</code>)</li><li>평균 시간복잡도 (<code>average-case analysis</code>)</li></ul></li></ul><p><br/></p><p><br/></p><h1 id="점근적-표기법"><a href="#점근적-표기법" class="headerlink" title="점근적 표기법"></a>점근적 표기법</h1><hr><ul><li>점근적 표기법을 사용<ul><li>데이터의 개수 n→∞일때 수행시간이 증가하는 <code>growth rate</code>로 시간복잡도를 표현<br>하는 기법</li><li><code>Θ</code>-표기, <code>Ο</code>-표기 등을 사용</li></ul></li><li>유일한 분석법도 아니고 가장 좋은 분석법도 아님<ul><li>다만(상대적으로) 가장 간단하며</li><li>알고리즘의 실행환경에 비의존적임</li><li>그래서 가장 광범위하게 사용됨</li></ul></li><li>알고리즘에 포함된 연산들의 실행 횟수를 표기하는 하나의 기법</li><li>최고차항의 차수만으로 표시</li><li>따라서 가장 자주 실행되는 연산 혹은 문장의 실행횟수를 고려하는 것으로 충분</li></ul><p><br/></p><h2 id="점근표기법-Ο-표기"><a href="#점근표기법-Ο-표기" class="headerlink" title="점근표기법: Ο-표기"></a>점근표기법: Ο-표기</h2><hr><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled.png" /></p><p><br/></p><h2 id="점근표기법-Ω-표기"><a href="#점근표기법-Ω-표기" class="headerlink" title="점근표기법: Ω-표기"></a>점근표기법: Ω-표기</h2><hr><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%201.png" /></p><p><br/></p><h2 id="점근표기법-Θ-표기"><a href="#점근표기법-Θ-표기" class="headerlink" title="점근표기법:Θ-표기"></a>점근표기법:Θ-표기</h2><hr><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%202.png" /></p><ul><li>f(n) ∈ O(g(n))을 f(n) = O(g(n))으로 쓰는 경우가 많음</li><li>차수가 k≥0인 모든 다항식은 O(nᵏ)이다.</li></ul><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%203.png" /></p><p><br/></p><h2 id="차수가-p인-다항식과-q인-다항식의-합"><a href="#차수가-p인-다항식과-q인-다항식의-합" class="headerlink" title="차수가 p인 다항식과 q인 다항식의 합"></a>차수가 p인 다항식과 q인 다항식의 합</h2><hr><p><img style="margin: 1rem auto; min-width: 150px; width:20%; display: block;" src="/img/post_images/algorithm/base/Untitled%204.png" /></p><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%205.png" /></p><p><br/></p><p><br/></p><h1 id="복잡도-비교"><a href="#복잡도-비교" class="headerlink" title="복잡도 비교"></a>복잡도 비교</h1><hr><ul><li>알고리즘은 실행 시간이 다항식 인 경우 효율적</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%206.png" /></p><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%207.png" /></p><p><br/></p><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><p><a href="https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C/da">영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠) - 인프런</a></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B0%9C%EB%85%90/">개념</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B0%9C%EB%85%90/">개념</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/">시간복잡도</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/12/ddfce68ef73c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 피보나치 수</title>
      <link>https://sklubmk.github.io/2021/08/12/b5f9f208b449/</link>
      <guid>https://sklubmk.github.io/2021/08/12/b5f9f208b449/</guid>
      <pubDate>Wed, 11 Aug 2021 15:24:24 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;피보나치-수&quot;&gt;&lt;a href=&quot;#피보나치-수&quot; class=&quot;headerlink&quot; title=&quot;피보나치 수&quot;&gt;&lt;/a&gt;피보나치 수&lt;/h1&gt;&lt;p&gt;JavaScript&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="피보나치-수"><a href="#피보나치-수" class="headerlink" title="피보나치 수"></a>피보나치 수</h1><p>JavaScript</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.</p><p>예를들어</p><ul><li>F(2) = F(0) + F(1) = 0 + 1 = 1</li><li>F(3) = F(1) + F(2) = 1 + 1 = 2</li><li>F(4) = F(2) + F(3) = 1 + 2 = 3</li><li>F(5) = F(3) + F(4) = 2 + 3 = 5</li></ul><p>와 같이 이어집니다.</p><p>2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.</p><h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><ul><li>n은 1이상, 100000이하인 자연수입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>return</th></tr></thead><tbody><tr><td>3</td><td>2</td></tr><tr><td>5</td><td>5</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, … 와 같이 이어집니다.</p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> answer = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        answer.push( (answer[i-<span class="number">1</span>] + answer[i-<span class="number">2</span>]) % <span class="number">1234567</span> )</span><br><span class="line">    <span class="keyword">return</span> answer[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n</span>):</span></span><br><span class="line">    pbnc_list = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        pbnc_list.append( (pbnc_list[i-<span class="number">2</span>] + pbnc_list[i-<span class="number">1</span>]) % <span class="number">1234567</span> )</span><br><span class="line">    <span class="keyword">return</span> pbnc_list[-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>피보나치 수열 문제를 풀 수 있는 가장 쉬운 방법은 재귀(<code>recursion</code>)일 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span> || n===<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pibonacci(n-<span class="number">2</span>) + pibonacci(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><p>그러나 위 풀이에는 많은 계산들이 중복되어 효율성이 매우 떨어진다.</p><p>이 때, 배열을 이용한 동적계획법 (Dynamic Programming)을 활용해 풀 수 있다.</p><p>배열에 저장하며 사용하면 중복되는 계산없이 풀 수 있고, 이때 복잡도는 <script type="math/tex">O(N)</script>을 따른다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/DP/">DP</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/12/b5f9f208b449/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 프린터</title>
      <link>https://sklubmk.github.io/2021/08/11/539b25284767/</link>
      <guid>https://sklubmk.github.io/2021/08/11/539b25284767/</guid>
      <pubDate>Tue, 10 Aug 2021 15:05:04 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;프린터&quot;&gt;&lt;a href=&quot;#프린터&quot; class=&quot;headerlink&quot; title=&quot;프린터&quot;&gt;&lt;/a&gt;프린터&lt;/h1&gt;&lt;p&gt;JavaScript, Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="프린터"><a href="#프린터" class="headerlink" title="프린터"></a>프린터</h1><p>JavaScript, Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1\. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.</span><br><span class="line">&gt;2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.</span><br><span class="line">&gt;3. 그렇지 않으면 J를 인쇄합니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.</p><p>내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.</p><p>현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.</li><li>인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.</li><li>location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>priorities</th><th>location</th><th>return</th></tr></thead><tbody><tr><td>[2, 1, 3, 2]</td><td>2</td><td>1</td></tr><tr><td>[1, 1, 9, 1, 1, 1]</td><td>0</td><td>5</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>예제 #1</p><p>문제에 나온 예와 같습니다.</p><p>예제 #2</p><p>6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다.</p><p><a href="http://www.csc.kth.se/contest/nwerc/2006/problems/nwerc06.pdf">출처</a></p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">priorities, location</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> currentIndex = location;</span><br><span class="line">    <span class="keyword">var</span> n = priorities.length</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        answer++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> max = priorities.indexOf(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,priorities))</span><br><span class="line">        <span class="keyword">if</span>(max === currentIndex)</span><br><span class="line">            <span class="keyword">return</span> answer;</span><br><span class="line">        </span><br><span class="line">        priorities[max] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> head = priorities.splice(<span class="number">0</span>, max)</span><br><span class="line">        max &lt; currentIndex ? currentIndex -= max : currentIndex += (n-max);</span><br><span class="line">        priorities.push.apply(priorities,head);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">priorities, location</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    <span class="keyword">while</span> priorities:</span><br><span class="line">        p_max = <span class="built_in">max</span>(priorities)</span><br><span class="line">        <span class="keyword">while</span> priorities[<span class="number">0</span>] != p_max:</span><br><span class="line">            priorities.append(priorities.pop(<span class="number">0</span>))</span><br><span class="line">            location = <span class="built_in">len</span>(priorities)-<span class="number">1</span> <span class="keyword">if</span> location == <span class="number">0</span> <span class="keyword">else</span> location-<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> location == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(queue) +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue.append(priorities.pop(<span class="number">0</span>))</span><br><span class="line">            location -= <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><code>queue</code> 자료구조를 활용하여 푸는 시물레이션 문제다.</p><p>문제에서 주어진 조건의 함수를 <code>queue</code>를 활용해 구현하면 쉽게 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/11/539b25284767/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 튜플</title>
      <link>https://sklubmk.github.io/2021/08/10/4ee95b87b24f/</link>
      <guid>https://sklubmk.github.io/2021/08/10/4ee95b87b24f/</guid>
      <pubDate>Tue, 10 Aug 2021 12:56:12 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;튜플&quot;&gt;&lt;a href=&quot;#튜플&quot; class=&quot;headerlink&quot; title=&quot;튜플&quot;&gt;&lt;/a&gt;튜플&lt;/h1&gt;&lt;p&gt;Javascript, Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="튜플"><a href="#튜플" class="headerlink" title="튜플"></a>튜플</h1><p>Javascript, Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.</p><ul><li>(a1, a2, a3, …, an)</li></ul><p>튜플은 다음과 같은 성질을 가지고 있습니다.</p><ol><li>중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)</li><li>원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)</li><li>튜플의 원소 개수는 유한합니다.</li></ol><p>원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 <code>(a1, a2, a3, ..., an)</code>이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다.</p><ul><li><code>&#123;&#123;a1&#125;, &#123;a1, a2&#125;, &#123;a1, a2, a3&#125;, &#123;a1, a2, a3, a4&#125;, ... &#123;a1, a2, a3, a4, ..., an&#125;&#125;</code></li></ul><p>예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는</p><ul><li><code>&#123;&#123;2&#125;, &#123;2, 1&#125;, &#123;2, 1, 3&#125;, &#123;2, 1, 3, 4&#125;&#125;</code></li></ul><p>와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로</p><ul><li><code>&#123;&#123;2&#125;, &#123;2, 1&#125;, &#123;2, 1, 3&#125;, &#123;2, 1, 3, 4&#125;&#125;</code></li><li><code>&#123;&#123;2, 1, 3, 4&#125;, &#123;2&#125;, &#123;2, 1, 3&#125;, &#123;2, 1&#125;&#125;</code></li><li><code>&#123;&#123;1, 2, 3&#125;, &#123;2, 1&#125;, &#123;1, 2, 4, 3&#125;, &#123;2&#125;&#125;</code></li></ul><p>는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.</p><p>특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="[제한사항]"></a>[제한사항]</h2><ul><li>s의 길이는 5 이상 1,000,000 이하입니다.</li><li>s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다.</li><li>숫자가 0으로 시작하는 경우는 없습니다.</li><li>s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.</li><li>s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.</li><li>return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="[입출력 예]"></a>[입출력 예]</h2><div class="table-container"><table><thead><tr><th>s</th><th>result</th></tr></thead><tbody><tr><td><code>&quot;&#123;&#123;2&#125;,&#123;2,1&#125;,&#123;2,1,3&#125;,&#123;2,1,3,4&#125;&#125;&quot;</code></td><td>[2, 1, 3, 4]</td></tr><tr><td><code>&quot;&#123;&#123;1,2,3&#125;,&#123;2,1&#125;,&#123;1,2,4,3&#125;,&#123;2&#125;&#125;&quot;</code></td><td>[2, 1, 3, 4]</td></tr><tr><td><code>&quot;&#123;&#123;20,111&#125;,&#123;111&#125;&#125;&quot;</code></td><td>[111, 20]</td></tr><tr><td><code>&quot;&#123;&#123;123&#125;&#125;&quot;</code></td><td>[123]</td></tr><tr><td><code>&quot;&#123;&#123;4,2,3&#125;,&#123;3&#125;,&#123;2,3,4,1&#125;,&#123;2,3&#125;&#125;&quot;</code></td><td>[3, 2, 4, 1]</td></tr></tbody></table></div><h2 id="입출력-예에-대한-설명"><a href="#입출력-예에-대한-설명" class="headerlink" title="입출력 예에 대한 설명"></a>입출력 예에 대한 설명</h2><h3 id="입출력-예-1"><a href="#입출력-예-1" class="headerlink" title="입출력 예 #1"></a>입출력 예 #1</h3><p>문제 예시와 같습니다.</p><h3 id="입출력-예-2"><a href="#입출력-예-2" class="headerlink" title="입출력 예 #2"></a>입출력 예 #2</h3><p>문제 예시와 같습니다.</p><h3 id="입출력-예-3"><a href="#입출력-예-3" class="headerlink" title="입출력 예 #3"></a>입출력 예 #3</h3><p>(111, 20)을 집합 기호를 이용해 표현하면 <code>&#123;&#123;111&#125;, &#123;111,20&#125;&#125;</code>이 되며, 이는 <code>&#123;&#123;20,111&#125;,&#123;111&#125;&#125;</code>과 같습니다.</p><h3 id="입출력-예-4"><a href="#입출력-예-4" class="headerlink" title="입출력 예 #4"></a>입출력 예 #4</h3><p>(123)을 집합 기호를 이용해 표현하면 <code>&#123;&#123;123&#125;&#125;</code> 입니다.</p><h3 id="입출력-예-5"><a href="#입출력-예-5" class="headerlink" title="입출력 예 #5"></a>입출력 예 #5</h3><p>(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 <code>&#123;&#123;3&#125;,&#123;3,2&#125;,&#123;3,2,4&#125;,&#123;3,2,4,1&#125;&#125;</code>이 되며, 이는 <code>&#123;&#123;4,2,3&#125;,&#123;3&#125;,&#123;2,3,4,1&#125;,&#123;2,3&#125;&#125;</code>과 같습니다.</p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&quot;&#123;&#123;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;&#125;&#125;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        .split(<span class="string">&quot;&#125;,&#123;&quot;</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        .sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a.length-b.length)</span><br><span class="line">        .reduce(<span class="function">(<span class="params">list,cur</span>)=&gt;</span>[...new <span class="built_in">Set</span>(list.concat(cur))])</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">s</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">sorted</span>([i.split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> re.split(<span class="string">&#x27;&#123;&#123;|&#125;&#125;|&#125;,&#123;&#x27;</span>,s)[<span class="number">1</span>:-<span class="number">1</span>]],key=<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(d) <span class="keyword">not</span> <span class="keyword">in</span> answer:</span><br><span class="line">                answer.append(<span class="built_in">int</span>(d))</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>다음과 같은 풀이 과정을 따른다.</p><ol><li>주어진 문자열을 2차원 배열로 정제한다.</li><li>배열 안의 내부 배열들을 각 길이의 오름차순으로 정렬한다.</li><li>반복문을 돌며 다음 배열에서 현재 배열에 없는 값을 현재 배열에 추가한다.</li></ol><p><br/></p><p>1번의 과정은 정규표현식을 통해 간략화 할 수 있다.<br>3번의 과정은 <code>reduce</code> 함수와 <code>Set</code> 자료구조를 통해 쉽게 표현 할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/10/4ee95b87b24f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 타겟 넘버</title>
      <link>https://sklubmk.github.io/2021/08/09/9bb8d3343a89/</link>
      <guid>https://sklubmk.github.io/2021/08/09/9bb8d3343a89/</guid>
      <pubDate>Sun, 08 Aug 2021 16:08:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;타겟-넘버&quot;&gt;&lt;a href=&quot;#타겟-넘버&quot; class=&quot;headerlink&quot; title=&quot;타겟 넘버&quot;&gt;&lt;/a&gt;타겟 넘버&lt;/h1&gt;&lt;p&gt;JavaScript, Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="타겟-넘버"><a href="#타겟-넘버" class="headerlink" title="타겟 넘버"></a>타겟 넘버</h1><p>JavaScript, Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br></pre></td></tr></table></figure><p>사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>주어지는 숫자의 개수는 2개 이상 20개 이하입니다.</li><li>각 숫자는 1 이상 50 이하인 자연수입니다.</li><li>타겟 넘버는 1 이상 1000 이하인 자연수입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>numbers</th><th>target</th><th>return</th></tr></thead><tbody><tr><td>[1, 1, 1, 1, 1]</td><td>3</td><td>5</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>문제에 나온 예와 같습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> returnArray = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">i=<span class="number">0</span>,curArray=[]</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i === numbers.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curArray.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b,<span class="number">0</span>) === target)</span><br><span class="line">                answer++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        calc(i+<span class="number">1</span>,[numbers[i], ...curArray])</span><br><span class="line">        calc(i+<span class="number">1</span>,[-<span class="number">1</span>*numbers[i], ...curArray])</span><br><span class="line">    &#125;</span><br><span class="line">    calc()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python-DFS"><a href="#python-DFS" class="headerlink" title="python DFS"></a>python DFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">numbers, target</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>([ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>&lt;&lt;n) <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: [<span class="number">1</span>,-<span class="number">1</span>][<span class="built_in">int</span>(x[<span class="number">1</span>])]*numbers[x[<span class="number">0</span>]], <span class="built_in">enumerate</span>(<span class="built_in">list</span>(<span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(n))))) == target ])</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python-recursion"><a href="#python-recursion" class="headerlink" title="python recursion"></a>python recursion</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">numbers, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">and</span> target == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> numbers:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> solution(numbers[<span class="number">1</span>:], target - numbers[<span class="number">0</span>]) + solution(numbers[<span class="number">1</span>:], target+numbers[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><br/></p><h2 id="DFS-풀이-javascript-python"><a href="#DFS-풀이-javascript-python" class="headerlink" title="DFS 풀이 (javascript, python)"></a>DFS 풀이 (javascript, python)</h2><p><br/></p><p>카운트를 세는 방식의 재귀함수 DFS 풀이다. </p><p>가장 일반적으로 떠올릴 수 있는 풀이 방법으로, <code>numbers</code>의 길이만큼 재귀함수의 뎁스를 가진다. 매 재귀함수마다 늘어나는 계산은 2가지 (-1을 곱할때와 +1을 곱할때) 이므로 2배씩 늘어난다.</p><p>따라서 <code>numbers</code>의 길이가 <code>n</code> 일때 모든 <code>time complexity</code>는</p><p><script type="math/tex">1 + 2 + 4 + 8 + 2^{n} = \sum_{k=1}^{n} {2^k}</script> 이므로 <strong>등비수열의 합</strong>이 된다.</p><p>따라서 이를 계산하면 <script type="math/tex">2(2^{n}-1)</script>이 되고, <script type="math/tex">O(2^n)</script>을 뜻한다.</p><p><br/></p><h2 id="DFS-bit-mask-python"><a href="#DFS-bit-mask-python" class="headerlink" title="DFS + bit_mask (python)"></a>DFS + bit_mask (python)</h2><p><br/></p><p>재귀함수 대신 비트마스크를 이용한 반복문으로 풀이하는 방법.</p><ol><li><code>i</code>에 <code>1</code> ~ <code>1&lt;&lt;n</code> (<code>numbers</code>의 길이 <code>n</code> 만큼의 비트를 가지는 값 / ex: <code>n = 4</code> ? <code>1&lt;&lt;n = 16</code>) 까지 반복문을 돌며 값을 할당한다.</li><li>할당된 <code>i</code>값을 <strong>비트화</strong> 한다. <code>n=4</code> 일때, { <code>0000</code>, <code>0001</code>, <code>0010</code>, <code>0011</code>, &nbsp; <strong>…</strong> &nbsp; , <code>1111</code> } 의 값을 가진다.</li><li>비트화된 <code>i</code>값을 리스트로 나누어 <strong>0</strong>일땐 <code>+1</code>을, <strong>1</strong>일땐 <code>-1</code>을 곱한뒤 이 값들을 모두 더하고, 더한 값이 <code>target</code>과 같은 것들을 필터링 한다.</li></ol><p><br/></p><p>비트마스크를 이용한 풀이를 연습하려고 의도적으로 사용했고, 코드를 돌리면 첫 번째 풀이보다도 효율성이 떨어지는 결과를 얻는다. </p><p>위 모든 과정에서 <strong>최소</strong> <script type="math/tex">O(nlog_{2}{n})</script>이 소요되는데, 특히나 3번 과정은 리스트를 나누고 값을 곱한뒤 더하는 계산으로 <strong>최소</strong> <script type="math/tex">O(n^3)</script>의 복잡도를 보인다. 전체 계산은 대략 <script type="math/tex">O(n^5log_{2}{n})</script>이 된다.</p><p><br/></p><p>여기서 재미있는 점은, 사실 아래 풀이의 효율성이 위 문제보다 좋다는 것이다. </p><p>문제에서 주어진 <code>n</code>의 조건은 <code>20</code> 이하다. 이 조건 내에서 위 <script type="math/tex">O(2^n)</script>에 접목시키면 대략 <code>100만</code>번의 풀이가 나온다. 아래 식에 <code>20</code>을 접목시키면 대략 <code>2000만</code>번의 풀이가 나온다. 해당 조건에서 아래 풀이가 더 효율성이 떨어지지만, 지수함수와 다항함수의 차이는 그 값이 커질수록 기하급수적으로 차이가 난다. </p><p><code>n</code>의 제한이 <code>40</code>까지만 되도 위 식의 풀이는 <code>1조번</code> 이상의 시간이 소요된다.  그러나 아래식은 대략 <code>10억번</code>의 시간으로 풀이가 가능하다.  풀이 시간 뿐만 아니라 DFS 풀이에서 반복되는 재귀함수의 <code>stack</code> 점유는 제한 조건이 조금만 상향되도 문제로 다가올 것이다.</p><p><br/></p><p>따라서 이런 점으로 미루어보아, 주어진 문제의 <strong>제한사항</strong>을 꼼꼼히 확인할 필요가 있다. 특히나 이 문제처럼 다소 가벼운 조건의 문제라면 시간복잡도가 높은 풀이 방법이 오히려 좋은 효율을 보일 수 있기 때문이다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/bit/">bit</category>
      
      <category domain="https://sklubmk.github.io/tags/DFS/">DFS</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/09/9bb8d3343a89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[운영체제] 시스템 구조 및 프로그램 실행</title>
      <link>https://sklubmk.github.io/2021/08/07/b0dd3c8bc4ba/</link>
      <guid>https://sklubmk.github.io/2021/08/07/b0dd3c8bc4ba/</guid>
      <pubDate>Sat, 07 Aug 2021 07:08:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터 시스템 구조&lt;/li&gt;
&lt;li&gt;입출력(&lt;code&gt;I/O&lt;/code&gt;)의 수행&lt;/li&gt;
&lt;li&gt;저장장치 계층 구조&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>컴퓨터 시스템 구조</li><li>입출력(<code>I/O</code>)의 수행</li><li>저장장치 계층 구조</li></ul><span id="more"></span><p><br/></p><h1 id="컴퓨터-시스템-구조"><a href="#컴퓨터-시스템-구조" class="headerlink" title="컴퓨터 시스템 구조"></a>컴퓨터 시스템 구조</h1><hr><p><img alt="컴퓨터 시스템 구조" style="width: 70%; margin: 1.0rem auto; display: block" src="/img/post_images/os/computer_structure.png" /></p><div style="margin: 0 auto !important;max-width: 100%; width: max-content; font-size:1.5rem"> <code>[ CPU ]</code> - <code>[ memory ]</code> - <code>[ I/O device ]</code></div><p><br/></p><h2 id="부트스트랩-bootstrap"><a href="#부트스트랩-bootstrap" class="headerlink" title="부트스트랩 (bootstrap)"></a>부트스트랩 (bootstrap)</h2><hr><ul><li>컴퓨터 전원을 켰을때 처음 실행되는 프로그램</li><li>부트스트랩 실행 후 운영 체제를 로드함</li></ul><p><br/></p><h2 id="CPU의-역할"><a href="#CPU의-역할" class="headerlink" title="CPU의 역할"></a>CPU의 역할</h2><hr><ul><li>메모리에서 명령어(<code>instruction</code>)를 불러와 실행</li><li>실행 후 <code>interrupt line</code>을 체크하여 <strong>인터럽트</strong>가 발생했는지 확인</li><li><code>OS</code>에게 <code>CPU</code> 권한을 할당<ul><li><code>timer</code>에 시간을 정해서 권한을 할당</li></ul></li></ul><p><br/></p><h2 id="인터럽트-Interrupts"><a href="#인터럽트-Interrupts" class="headerlink" title="인터럽트 (Interrupts)"></a>인터럽트 (Interrupts)</h2><hr><ul><li><code>CPU</code>가 프로그램을 실행 중일 때 <code>I/O</code>등의 예외상황이 발생하여 처리가 필요할 경우 <code>CPU</code>에게 알려 처리할 수 있도록 하는 것</li><li><code>CPU</code>와 <code>I/O device</code>가 서로 통신하는 방법 중 하나</li><li>하드웨어는 언제든지 인터럽트를 트리거 할 수 있음<ul><li>일반적으로 시스템 버스를 통해 <code>CPU</code>로 신호를 전송</li></ul></li><li>인터럽트 당한 시점의 레지스터와 <code>program counter</code>를 저장한 후 <code>CPU</code>의 제어를 인터럽트 처리 루틴에 넘김</li></ul><p><br/></p><h3 id="넓은-의미"><a href="#넓은-의미" class="headerlink" title="넓은 의미"></a>넓은 의미</h3><ul><li>하드웨어 인터럽트 : 하드웨어가 발생시킨 인터럽트</li><li>Trap (소프트웨어 인터럽트)<ul><li><code>Exception</code> : 프로그램이 오류를 범한 경우</li><li><code>System call</code> : 프로그램이 커널 함수를 호출하는 경우</li></ul></li></ul><p><br/></p><h2 id="OS의-역할"><a href="#OS의-역할" class="headerlink" title="OS의 역할"></a>OS의 역할</h2><hr><ul><li>인터럽트 관리<ul><li><code>I/O device</code>의 인터럽트가 발생하면 <code>CPU</code>로부터 권한을 받아 어떤 프로그램에서 인터럽트가 사용되었는지 확인 후 메모리 할당</li><li>그 후 기존 구동하던 프로그램에 <code>CPU</code> 권한을 할당</li></ul></li><li>프로그램 실행을 위한 환경 제공<ul><li>사용자 인터페이스</li><li>프로그램 실행</li><li>입출력 동작</li><li>파일 시스템 조작</li><li>커뮤니케이션</li><li>오류 감지</li><li>자원 할당</li><li>로깅</li><li>보호 및 보안</li><li>프로세스(<code>thread</code>)<ul><li>다중처리, 동기화, 교착 상태, 메모리, 가상 메모리, CPU 스케줄링 등등</li></ul></li></ul></li></ul><p><br/></p><h2 id="모드-비트-mode-bit"><a href="#모드-비트-mode-bit" class="headerlink" title="모드 비트 (mode bit)"></a>모드 비트 (mode bit)</h2><hr><p><img alt="모드 비트" style="width: 70%; margin: 1.0rem auto 0 auto; display: block" src="/img/post_images/os/modebits.png" /></p><ul><li>운영체제에는 <strong>사용자모드</strong>와 <strong>커널모드</strong>가 있는데, 모드 비트는 운영체제의 현재 모드를 표현하는 값이다.</li><li><code>1 - 사용자 모드</code> : 사용자 프로그램 수행<ul><li>제한된 명령어만 <code>CPU</code>에서 실행할 수 있음</li><li>사용자 프로그램의 잘못된 수행으로 피해를 막기 위한 <strong>보호 및 보안 장치</strong></li></ul></li><li><code>0 - 모니터 모드</code> : <code>OS</code> 코드 수행 (커널 모드)<ul><li>메모리 뿐만 아니라 <code>I/O device</code> 접근 등 모든 일을 할 수 있음</li></ul></li></ul><p><br/></p><h2 id="타이머-timer"><a href="#타이머-timer" class="headerlink" title="타이머 (timer)"></a>타이머 (timer)</h2><hr><ul><li>정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시키는 장치</li><li>값이 <code>0</code>이 되면 타이머 인터럽트 발생</li><li><code>CPU</code>를 특정 프로그램이 <strong>독점</strong>하는 것으로부터 보호</li><li>시분할(<code>time sharing</code>)을 구현하기 위해 널리 이용됨</li><li>타이머는 현재 시간을 계산하기 위해서도 사용</li></ul><p><br/></p><h2 id="장치-제어기-Device-Controller"><a href="#장치-제어기-Device-Controller" class="headerlink" title="장치 제어기 (Device Controller)"></a>장치 제어기 (Device Controller)</h2><hr><ul><li><code>bus</code>를 통해 <code>CPU</code>와 직접적인 통신을 하는 장치<ul><li>해당 <code>I/O</code> 장치유형을 관리하는 일종의 작은 <code>CPU</code></li><li>제어 정보를 위해 <code>control register</code>, <code>status register</code>를 가짐</li><li><code>local buffer</code>를 가짐 (일종의 <code>data register</code>)</li></ul></li><li><code>device driver</code>(소프트웨어)는 운영체제가 장치들과 호환되게 해주는 하나의 코드<ul><li>이를 디바이스 컨트롤러가 인식하는 것</li></ul></li><li><code>I/O</code>는 실제 <code>device</code>와 <code>local buffer</code> 사이에서 일어남</li><li>디바이스 컨트롤러는 <code>I/O</code>가 끝났을 경우 인터럽트로 <code>CPU</code>에 그 사실을 전달</li></ul><p><br/></p><h2 id="DMA-controller"><a href="#DMA-controller" class="headerlink" title="DMA controller"></a>DMA controller</h2><hr><ul><li>직접 메모리 접근 (<code>Direct Memory Access</code>)</li><li><code>CPU</code>처럼 직접 메모리에 접근할 수 있는 컨트롤러</li><li>메모리 교통정리 역할</li><li><code>I/O</code>의 <code>local buffer</code>복사작업을 수행하여 <code>CPU</code>의 <code>interrupt</code> 작업을 최소화 시킴</li></ul><p><br/></p><h2 id="SMP-Symmetric-multiprocessing"><a href="#SMP-Symmetric-multiprocessing" class="headerlink" title="SMP (Symmetric multiprocessing)"></a>SMP (Symmetric multiprocessing)</h2><hr><p><img alt="SMP" style="width: 70%; margin: 1.0rem auto 0 auto; display: block" src="/img/post_images/os/smp.png" /></p><ul><li><code>CPU</code>를 여러개 다는 구조 (각각의 레지스터와 캐시가 존재)</li><li>가장 일반적인 멀티 프로세서 시스템<ul><li>각 피어 <code>CPU</code> 프로세서가 모든 작업을 수행하는 경우</li></ul></li><li>ex) 슈퍼컴퓨터 </li></ul><p><br/></p><h2 id="멀티프로그래밍-Multiprogramming"><a href="#멀티프로그래밍-Multiprogramming" class="headerlink" title="멀티프로그래밍 (Multiprogramming)"></a>멀티프로그래밍 (Multiprogramming)</h2><hr><p><img alt="Multiprogramming" style="width: 30%; margin: 1.0rem auto 0 auto; display: block" src="/img/post_images/os/mp.png" /></p><ul><li>여러 프로그램을 메모리에 모두 올리고 동시에 실행 시키는 설계</li><li><code>CPU</code> 사용률을 높이기 위한 목적</li></ul><p><br/></p><h2 id="멀티-태스킹-멀티-프로세싱"><a href="#멀티-태스킹-멀티-프로세싱" class="headerlink" title="멀티 태스킹 (멀티 프로세싱)"></a>멀티 태스킹 (멀티 프로세싱)</h2><hr><ul><li><code>CPU</code> 입장에선 각 프로그램의 구동이 찰나의 사용에 불과하므로 여러 프로그램을 <code>시간을 쪼개</code> 사용하여 동시에 작동하게 하는 것</li><li><code>CPU scheduling</code><ul><li>여러 프로세스가 동시에 실행될 준비가 된 경우 세스템이 순서를 관리하는 것</li><li><code>CPU</code> 효율을 가장 좋게 만드는 것이 목표</li></ul></li></ul><p><br/></p><h2 id="가상화-Virtualization"><a href="#가상화-Virtualization" class="headerlink" title="가상화 (Virtualization)"></a>가상화 (Virtualization)</h2><hr><ul><li>단일 컴퓨터의 하드웨어를 여러 다른 실행 환경으로 추상화 하는 기술</li><li><code>VMM</code> : 가상 머신 매니저 (Virtual Machine Manager)<ul><li><code>VMware</code>, <code>XEN</code>, <code>WSL</code> 등</li></ul></li></ul><p><br/></p><h2 id="사용자와-OS의-상호작용"><a href="#사용자와-OS의-상호작용" class="headerlink" title="사용자와 OS의 상호작용"></a>사용자와 OS의 상호작용</h2><hr><ul><li>인터페이스를 이용한 상호작용<ul><li><code>CLI</code> (Command Line Interface)<ul><li>보통 쉘로 알려짐</li><li>sh, bash, csh, tcsh, zsh 등</li></ul></li><li><code>GUI</code> (Graphic User Interface)<ul><li><code>Windows</code>, <code>MacOS</code>, <code>Linux</code> 등</li></ul></li><li>Touch-Screen Interface<ul><li>Android, iOS 등</li></ul></li></ul></li><li>System calls<ul><li><code>API</code> (Application Programming Interface)</li><li>커널 함수 호출<ul><li>운영체제 프로그램의 함수</li><li>커널 영역의 code 부분에 속함</li><li>standard C library<br><img style="width: 50%;" src="/img/post_images/os/c.png" /></li></ul></li></ul></li></ul><p><br/></p><p><br/></p><h1 id="입출력-I-O-의-수행"><a href="#입출력-I-O-의-수행" class="headerlink" title="입출력(I/O)의 수행"></a>입출력(I/O)의 수행</h1><hr><p><img alt="I/O Structure" style="width: 70%; margin: 1.0rem auto 0 auto; display: block" src="/img/post_images/os/io.png" /></p><p><br/></p><ul><li>모든 입출력 명령은 특권 명령</li><li><code>OS</code> 코드의 상당 부분이 <code>I/O</code> 관리 전용</li></ul><p><br/></p><h2 id="DMA-Direct-Memory-Access"><a href="#DMA-Direct-Memory-Access" class="headerlink" title="DMA (Direct Memory Access)"></a>DMA (Direct Memory Access)</h2><hr><ul><li>빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용</li><li><code>CPU</code>의 중재 없이 <code>device controller가 device</code>의 <code>buffer storage</code>의 내용을 메모리에 <code>block</code> 단위로 직접 전송</li><li>바이트 단위가 아닌 <code>block</code> 단위로 인터럽트를 발생시킴</li><li>ex) 유투브 시청</li></ul><p><br/></p><h2 id="사용자-프로그램이-I-O를-하는-방법"><a href="#사용자-프로그램이-I-O를-하는-방법" class="headerlink" title="사용자 프로그램이 I/O를 하는 방법"></a>사용자 프로그램이 <code>I/O</code>를 하는 방법</h2><hr><ul><li>시스템콜 (<code>system call</code>)<ul><li>사용자 프로그램은 운영체제에게 <code>I/O</code> 요청</li></ul></li><li><code>trap</code>을 사용하여 인터럽트 벡터의 특정 위치로 이동</li><li>제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동</li><li>올바른 <code>I/O</code> 요청인지 확인 후 <code>I/O</code> 수행</li><li><code>I/O</code> 완료 시 제어권을 시스템콜 다음 명령으로 옮김</li></ul><p><br/></p><h2 id="I-O를-하기위해-필요한-인터럽트-종류는-hard-or-soft"><a href="#I-O를-하기위해-필요한-인터럽트-종류는-hard-or-soft" class="headerlink" title="I/O를 하기위해 필요한 인터럽트 종류는? (hard or soft)"></a><code>I/O</code>를 하기위해 필요한 인터럽트 종류는? (<code>hard</code> or <code>soft</code>)</h2><hr><ul><li>둘 다 필요</li><li>소프트웨어 인터럽트로 요청</li><li>끝났을 때는 하드웨어 인터럽트로 <code>controller</code>가 알려줌</li></ul><p><br/></p><h2 id="시스템-콜-System-Call"><a href="#시스템-콜-System-Call" class="headerlink" title="시스템 콜 (System Call)"></a>시스템 콜 (System Call)</h2><hr><ul><li>사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것</li><li>운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스</li><li>프로그래밍 언어에서 지원하지 않는 기능에 대하여 운영 체제의 루틴을 호출하여 이를 이용하는 것</li></ul><p><br/></p><h3 id="시스템-콜-system-call-or-syscall-의-3가지-기능"><a href="#시스템-콜-system-call-or-syscall-의-3가지-기능" class="headerlink" title="시스템 콜(system call or syscall)의 3가지 기능"></a>시스템 콜(<code>system call</code> or <code>syscall</code>)의 3가지 기능</h3><ol><li>사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다.</li><li>시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다.</li><li>커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다.</li></ol><h3 id="시스템-콜의-유형"><a href="#시스템-콜의-유형" class="headerlink" title="시스템 콜의 유형"></a>시스템 콜의 유형</h3><ul><li>프로세스 제어 (<code>Process Control</code>)</li><li>파일 조작 (<code>File Manipulation</code>)</li><li>장치 관리 (<code>Device Management</code>)</li><li>정보 유지 (<code>Information maintenance</code>)</li><li>통신 (<code>Communication</code>)</li></ul><p><br/></p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><hr><ul><li>프로그램 카운터라는 레지스터가 가르키는 메모리에서 인스트럭션을 하나 읽어와 실행</li><li>인터럽트가 들어온게 있는지 확인 뒤 있으면 하던 작업을 멈추고 <code>CPU</code> 제어권을 운영체제에게 넘김</li><li><code>OS</code>는 인터럽트 라인별로 있는 <strong>인터럽트 벡터</strong>의 주소로 찾아가 <strong>인터럽트 처리 루틴</strong>을 실행함</li></ul><p><br/></p><h3 id="인터럽트-벡터"><a href="#인터럽트-벡터" class="headerlink" title="인터럽트 벡터"></a>인터럽트 벡터</h3><ul><li>해당 인터럽트의 처리 루틴 주소를 가지고 있음</li><li>인터럽트 번호, 주소 쌍을 포함</li></ul><h3 id="인터럽트-처리-루틴"><a href="#인터럽트-처리-루틴" class="headerlink" title="인터럽트 처리 루틴"></a>인터럽트 처리 루틴</h3><ul><li>= Interrupt Service Routine, 인터럽트 핸들러</li><li>해당 인터럽트를 처리하는 커널 함수</li><li><code>disk controller</code>가 발생시킨 인터럽트에 대해서 <code>CPU</code>에서 실행시켜야할 커널 함수가 정의되어 있는 것</li></ul><p><br/></p><h2 id="동기식-입출력-synchronous-I-O"><a href="#동기식-입출력-synchronous-I-O" class="headerlink" title="동기식 입출력 (synchronous I/O)"></a>동기식 입출력 (synchronous I/O)</h2><hr><ul><li><code>I/O</code> 요청 후 입출력 작업이 오나료된 후에야 제어가 사용자 프로그램에 넘어감</li></ul><p><br/></p><h3 id="구현-방법-1"><a href="#구현-방법-1" class="headerlink" title="구현 방법 1"></a>구현 방법 1</h3><ul><li><code>I/O</code>가 끝날 때까지 <code>CPU</code>를 낭비시킴</li><li>매시점 하나의 <code>I/O</code>만 일어날 수 있음</li></ul><h3 id="구현-방법-2"><a href="#구현-방법-2" class="headerlink" title="구현 방법 2"></a>구현 방법 2</h3><ul><li><code>I/O</code>가 완료될 때까지 해당 프로그램에서 <code>CPU</code>를 빼앗음</li><li><code>I/O</code> 처리를 기다리는 줄에 그 프로그램을 줄 세움</li><li>다른 프로그램에게 <code>CPU</code>를 줌</li></ul><p><br/></p><h2 id="비동기식-입출력-asynchronous-I-O"><a href="#비동기식-입출력-asynchronous-I-O" class="headerlink" title="비동기식 입출력 (asynchronous I/O)"></a>비동기식 입출력 (asynchronous I/O)</h2><ul><li><code>I/O</code>가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감</li><li>동기식, 비동기식 입출력 모두 <code>I/O</code>의 완료는 인터럽트로 알려줌</li></ul><p><br/></p><p><br/></p><h1 id="저장장치-계층-구조-Memory-Hierarchy"><a href="#저장장치-계층-구조-Memory-Hierarchy" class="headerlink" title="저장장치 계층 구조 (Memory Hierarchy)"></a>저장장치 계층 구조 (Memory Hierarchy)</h1><hr><p><img alt="Memory  Structure" style="width: 90%; margin: 1.0rem auto 0 auto; display: block" src="https://ww.namu.la/s/893cc4cb9901911dd7fbf7e151f8768f0a10d00d6b50bc9ad2b634810c19723f7c5464bc7701d8cfbfa7a4c3027ec10198c1cfcb92b598bd0eccea6202beb28a459cc670770bdd7a32a533edb4cf09145ba380e7e2e5628ca3f07e9c8239f44b" /></p><p><br/></p><ul><li><strong>서로 다른 특징</strong>을 가진 여러 종류의 저장 장치를 <strong>함께 사용</strong>하여 <strong>최적의 효율</strong>을 내는 것</li><li>싸고 성능 좋은 컴퓨터를 구현하는 설계</li><li><strong>위</strong>로 올라갈수록 <strong>입출력 속력</strong>(대역폭)과 <strong>비용</strong> 증가</li><li><strong>아래</strong>로 내려갈수록 <strong>용량</strong> 증가</li></ul><p><br/></p><h2 id="주-기억장치"><a href="#주-기억장치" class="headerlink" title="주 기억장치"></a>주 기억장치</h2><hr><ul><li>컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치</li><li><code>CPU</code>에서 직접 접근이 가능</li><li>상수를 쓰는 것 이외의 연산은 <code>CPU</code>에서 바로 수행할 수 없음<ul><li>메모리 값을 레지스터로 로드, 연산, 결과 적용의 단계 필요</li></ul></li><li><strong>휘발성 메모리</strong><ul><li>저장된 정보를 관리하기 위해 전력이 요구되는 컴퓨터 메모리</li><li>전력이 없으면 손실됨</li></ul></li></ul><p><br/></p><h3 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h3><ul><li>컴퓨터에서 제일 빠른 메모리</li><li><code>CPU</code> 계산 과정에서 작동</li></ul><h3 id="Cache-Memory"><a href="#Cache-Memory" class="headerlink" title="Cache Memory"></a>Cache Memory</h3><ul><li>레지스터 다음으로 빠른 메모리</li><li>레지스터와 메인 메모리 간 속도 차이를 완충하기 위해 캐시 메모리 사용</li><li>메인 메모리보다 용량이 작으므로 당장 사용할 메모리만 올려서 사용</li><li>캐싱과 재사용 목적</li><li><strong>투명성 (<code>Transparent</code>)</strong><ul><li>캐시는 보통 프로그래머가 직접 제어할 수 없으며 <code>CPU</code>에 의해 자동으로 통제됨</li><li>캐시가 있든 없든 프로그래머와 외부 사용자에게 보이는 결과는 동일함</li><li>이러한 특성을 사용자에게 <strong>투명</strong>(<code>transparent</code>)하다고 한다.</li><li>캐시의 특성을 이해하고 프로그래밍하면 훨씬 효율 좋은 코드를 생성할 수 있다.</li></ul></li></ul><h3 id="메인-메모리"><a href="#메인-메모리" class="headerlink" title="메인 메모리"></a>메인 메모리</h3><ul><li><code>RAM</code> (Random Access Memory)이라 불림.<ul><li>어느 위치에든 똑같은 속도로 접근하여 읽고 쓸 수 있다는 의미</li></ul></li><li><code>CPU</code>나 메인보드와 분리되어 있는 메모리 중 최상위 메모리</li><li>프로그램을 직접 구동하는 데 사용되는 <code>주 기억 장치</code>의 최하위 메모리</li><li><code>CPU</code>와 캐시에 비하면 훨씬 느리지만, <code>HDD</code>나 <code>SSD</code>보다 차원이 다르게 빠름</li></ul><p><br/></p><h2 id="보조-기억장치"><a href="#보조-기억장치" class="headerlink" title="보조 기억장치"></a>보조 기억장치</h2><hr><ul><li>대용량의 자료를 영구적으로 보관하기 위해서 사용하는 저속, 저가, 대용량의 기억장치<ul><li>속도적 측면에서 레지스터가 머릿속에서 떠올리는 정보라면 보조기억장치는 지구를 한 바퀴 돌아 찾아오는 정보로 비유됨</li></ul></li><li><code>CPU</code>에서 직접 접근이 불가능한 메모리</li><li>접근하려면 디바이스 드라이버와 <strong>시스템 콜</strong>을 통해 주기억장치로 로드(<code>Load</code>) 필요</li><li><strong>비휘발성 메모리</strong><ul><li>전원이 공급되지 않아도 저장된 정보를 계속 유지하는 메모리</li></ul></li></ul><p><br/></p><h3 id="스토리지-SSD-HDD"><a href="#스토리지-SSD-HDD" class="headerlink" title="스토리지 (SSD, HDD)"></a>스토리지 (SSD, HDD)</h3><ul><li>보조 기억장치 중에서 성능적으로 최상위에 위치 (<code>SSD</code> &gt; <code>HDD</code>)</li><li>보통 <code>SSD</code>는 100GB ~ 1TB 정도, <code>HDD</code>는 1TB ~ 6TB 정도의 용량으로 구성</li><li>일반적으로 <code>ATA</code>라는 중간 계층을 따로 두어 통신</li><li><code>NVMe SSD</code>는 <code>CPU</code>와 직접 통신</li></ul><h3 id="이동식-저장장치"><a href="#이동식-저장장치" class="headerlink" title="이동식 저장장치"></a>이동식 저장장치</h3><ul><li><code>USB</code> 메모리, <code>ODD</code> 등</li><li>기업에선 <code>backup</code>용으로 <strong>자기테이프</strong>도 사용</li><li>때로는 키보드, 마우스 등의 입력장치나 <strong>클라우드 스토리지</strong> 등을 포함하기도 함</li></ul><p><br/></p><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><ul><li><a href="https://ko.wikipedia.org/wiki/%EC%8B%9C%EC%8A%A4%ED%85%9C_%ED%98%B8%EC%B6%9C">시스템 호출 - 위키백과</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8">인터럽트 - 위키백과</a></li><li><a href="https://namu.wiki/w/%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B3%84%EC%B8%B5%20%EA%B5%AC%EC%A1%B0">메모리 계층 구조 - 나무위키</a></li><li><a href="https://namu.wiki/w/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98">기억장치 - 나무위키</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%A3%BC%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98">주기억장치 - 위키백과</a></li><li><a href="https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98">운영체제 공룡책 강의(주니온) - 인프런</a></li><li><a href="http://www.kocw.net/home/cview.do?lid=af8e05c97c6d60de">Introduction to Operating Systems - 반효경</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/">운영체제</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%BB%B4%ED%93%A8%ED%84%B0/">컴퓨터</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/">프로그램</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%BB%A4%EB%84%90/">커널</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/07/b0dd3c8bc4ba/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[타입스크립트] 타입스크립트의 기본 타입</title>
      <link>https://sklubmk.github.io/2021/08/05/f3a2b4b29950/</link>
      <guid>https://sklubmk.github.io/2021/08/05/f3a2b4b29950/</guid>
      <pubDate>Thu, 05 Aug 2021 08:40:12 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;지원 타입 목록&lt;/li&gt;
&lt;li&gt;타입 선언 (Type Declaration)&lt;/li&gt;
&lt;li&gt;타입 추론 (Type Inference)&lt;/li&gt;
&lt;li&gt;타입 단언 (Type Assertions)&lt;/li&gt;
&lt;li&gt;타입 가드 (Type Guards)&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>지원 타입 목록</li><li>타입 선언 (Type Declaration)</li><li>타입 추론 (Type Inference)</li><li>타입 단언 (Type Assertions)</li><li>타입 가드 (Type Guards)</li></ul><span id="more"></span><p><br/></p><p><br/></p><h1 id="지원-타입-목록"><a href="#지원-타입-목록" class="headerlink" title="지원 타입 목록"></a>지원 타입 목록</h1><hr><ul><li>Typescript는 Javascript의 타입 외에도 고유의 타입이 추가로 제공된다.</li></ul><div class="table-container"><table><thead><tr><th>Type</th><th>JS</th><th>TS</th><th>Description</th></tr></thead><tbody><tr><td>boolean</td><td>✅</td><td>✅</td><td>true와 false</td></tr><tr><td>null</td><td>✅</td><td>✅</td><td>값이 없다는 것을 명시</td></tr><tr><td>undefined</td><td>✅</td><td>✅</td><td>값을 할당하지 않은 변수의 초기값</td></tr><tr><td>number</td><td>✅</td><td>✅</td><td>숫자(정수와 실수, Infinity, NaN)</td></tr><tr><td>string</td><td>✅</td><td>✅</td><td>문자열</td></tr><tr><td>symbol</td><td>✅</td><td>✅</td><td>고유하고 수정 불가능한 데이터 타입이며 주로 객체 프로퍼티들의 식별자로 사용(ES6에서 추가)</td></tr><tr><td>object</td><td>✅</td><td>✅</td><td>객체형(참조형)</td></tr><tr><td>array</td><td></td><td>✅</td><td>배열</td></tr><tr><td>tuple</td><td></td><td>✅</td><td>고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현</td></tr><tr><td>enum</td><td></td><td>✅</td><td>열거형. 숫자값 집합에 이름을 지정한 것</td></tr><tr><td>any</td><td></td><td>✅</td><td>타입 추론(type inference)할 수 없거나 타입 체크가 필요없는 변수에 사용, var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능</td></tr><tr><td>void</td><td></td><td>✅</td><td>일반적으로 함수에서 반환값이 없을 경우 사용</td></tr><tr><td>never</td><td></td><td>✅</td><td>결코 발생하지 않는 값</td></tr></tbody></table></div><p><br/></p><p><br/></p><h1 id="타입-선언-Type-Declaration"><a href="#타입-선언-Type-Declaration" class="headerlink" title="타입 선언 (Type Declaration)"></a>타입 선언 (Type Declaration)</h1><hr><ul><li>타입스크립트는 일반 변수, 매개 변수(Parameter), 객체 속성(Property) 등에 <code>: TYPE</code>과 같은 형태로 타입을 지정할 수 있다.</li><li><code>TypeScript</code>는 <code>JavaScript</code>의 모든 데이터 타입을 허용한다.</li></ul><p><br/></p><p><br/></p><h2 id="원시-타입-primitive-type"><a href="#원시-타입-primitive-type" class="headerlink" title="원시 타입 (primitive type)"></a>원시 타입 (primitive type)</h2><hr><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo_s: <span class="built_in">string</span> = <span class="string">&#x27;text&#x27;</span>    <span class="comment">// 문자열</span></span><br><span class="line"><span class="keyword">let</span> foo_n: <span class="built_in">number</span> = <span class="number">0</span>;        <span class="comment">// 숫자형</span></span><br><span class="line"><span class="keyword">let</span> foo_b: <span class="built_in">boolean</span> = <span class="literal">true</span>;    <span class="comment">// 논리형</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p>이 때 만약 지정된 타입이 아닌 다른 타입의 데이터를 할당하려고 시도하면 에러를 발생한다.</p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열로 선언하고 숫자를 대입하면 에러 발생</span></span><br><span class="line"><span class="keyword">let</span> foo_s: <span class="built_in">string</span> = <span class="number">0</span>; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자값이 들어가고 이후에 문자열을 대입하면 에러 발생</span></span><br><span class="line"><span class="keyword">let</span> foo_n: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">foo_n = <span class="string">&#x27;text&#x27;</span>; <span class="comment">// error Type &#x27;text&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="배열-Array"><a href="#배열-Array" class="headerlink" title="배열 (Array)"></a>배열 (Array)</h2><hr><p>배열은 다음과 같이 두 가지 방법으로 타입을 선언할 수 있다.</p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="튜플-Tuple"><a href="#튜플-Tuple" class="headerlink" title="튜플 (Tuple)"></a>튜플 (Tuple)</h2><hr><ul><li>튜플 타입을 사용하면, 요소의 타입과 개수가 고정된 배열을 표현할 수 있다.</li><li>요소들의 타입이 모두 같을 필요는 없다</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 튜플 타입으로 선언</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 초기화</span></span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; <span class="comment">// 성공</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 잘못된 초기화</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>]; <span class="comment">// 오류</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 정해진 인덱스에 위치한 요소에 접근하면 해당 타입이 나타난다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substring(<span class="number">1</span>)); <span class="comment">// 성공</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substring(<span class="number">1</span>)); <span class="comment">// 오류, &#x27;number&#x27;에는 &#x27;substring&#x27; 이 없다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 정해진 인덱스 외에 다른 인덱스에 있는 요소에 접근하면, 오류가 발생하며 실패한다.</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">&quot;world&quot;</span>; <span class="comment">// 오류, &#x27;[string, number]&#x27; 타입에는 프로퍼티 &#x27;3&#x27;이 없다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// &#x27;[string, number]&#x27; 타입에는 프로퍼티 &#x27;5&#x27;가 없다.</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="열거형-Enum"><a href="#열거형-Enum" class="headerlink" title="열거형 (Enum)"></a>열거형 (Enum)</h2><hr><ul><li>열거형(<code>enum</code>)은 숫자값 집합에 이름을 지정한 것이다.</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color1 &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c1: Color1 = Color1.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Color2 &#123;Red = <span class="number">1</span>, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c2: Color2 = Color2.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c2); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Color3 &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c3: Color3 = Color3.Blue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c3); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="모든-타입-Any"><a href="#모든-타입-Any" class="headerlink" title="모든 타입 (Any)"></a>모든 타입 (Any)</h2><hr><ul><li><code>Any</code>는 모든 타입을 의미한다.</li><li>일반적인 자바스크립트 변수와 동일하게 어떤 타입의 값도 할당할 수 있다.</li><li>외부 자원을 활용해 개발할 때 불가피하게 타입을 단언할 수 없는 경우, 유용할 수 있다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">any</span>: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">any</span> = <span class="string">&#x27;Hello world&#x27;</span>;</span><br><span class="line"><span class="built_in">any</span> = &#123;&#125;;</span><br><span class="line"><span class="built_in">any</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다양한 값을 포함하는 배열을 나타낼 때에도 사용 가능</span></span><br><span class="line"><span class="keyword">const</span> list: anyArray[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;Anything!&#x27;</span>];</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>강한 타입 시스템의 장점을 유지하기 위해 <code>Any</code> 사용을 엄격하게 금지하려면, 컴파일 옵션 <code>&quot;noImplicitAny&quot;: true</code>를 통해 <code>Any</code> 사용 시 에러를 발생시킬 수 있다.</li></ul><p><br/></p><p><br/></p><h2 id="알-수-없는-타입-Unknown"><a href="#알-수-없는-타입-Unknown" class="headerlink" title="알 수 없는 타입 (Unknown)"></a>알 수 없는 타입 (Unknown)</h2><hr><ul><li><code>Any</code>와 같이 최상위 타입인 <code>Unknown</code>은 알 수 없는 타입을 의미한다.</li><li><code>Any</code>와 같이 <code>Unknown</code>에는 어떤 타입의 값도 할당할 수 있지만, <code>Unknown</code>을 다른 타입에는 할당할 수 없다.</li><li>일반적인 경우 <code>Unknown</code>은 타입 단언(<code>Assertions</code>)이나 타입 가드(<code>Guards</code>)를 필요로 한다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> u: unknown = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v1: <span class="built_in">boolean</span> = a; <span class="comment">// 모든 타입(any)은 어디든 할당할 수 있다.</span></span><br><span class="line"><span class="keyword">let</span> v2: <span class="built_in">number</span> = u; <span class="comment">// 알 수 없는 타입(unknown)은 모든 타입(any)을 제외한 다른 타입에 할당할 수 없다.</span></span><br><span class="line"><span class="keyword">let</span> v3: <span class="built_in">any</span> = u; <span class="comment">// OK!</span></span><br><span class="line"><span class="keyword">let</span> v4: <span class="built_in">number</span> = u <span class="keyword">as</span> <span class="built_in">number</span>; <span class="comment">// 타입을 단언하면 할당할 수 있다.</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체 (Object)"></a>객체 (Object)</h2><hr><ul><li>기본적으로 <code>typeof</code> 연산자가 <code>&quot;object&quot;</code>로 반환하는 모든 타입</li><li>컴파일러 옵션에서 엄격한 타입 검사(<code>strict</code>)를 <code>true</code>로 설정하면, <code>null</code>은 포함하지 않음.</li><li><code>object</code> 타입을 쓰면 <code>Object.create</code> 같은 API 가 더 잘 나타난다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// 성공</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// 성공</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// 오류</span></span><br><span class="line">create(<span class="string">&quot;string&quot;</span>); <span class="comment">// 오류</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// 오류</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// 오류</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h2><hr><ul><li><code>void</code>는 어떤 타입도 존재할 수 없음을 나타내기 때문에, <code>any</code>의 정반대로 작동한다.</li><li><code>void</code>는 보통 함수에서 반환 값이 없을 때 반환 타입을 표현하기 위해 쓰인다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li><code>void</code>를 타입 변수를 선언하는 것은 유용하지 않은데, 그 변수에는 <code>null</code> 또는 <code>undefined</code>만 할당할 수 있기 때문이다. ( <code>--strictNullChecks</code>를 사용하지 않을 때만 해당 )</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line">unusable = <span class="literal">null</span>; <span class="comment">// 성공  (`--strictNullChecks` 을 사용하지 않을때만)</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="Null과-Undefined"><a href="#Null과-Undefined" class="headerlink" title="Null과 Undefined"></a>Null과 Undefined</h2><hr><ul><li>기본적으로 Null과 Undefined는 모든 타입의 하위 타입으로, 다음과 같이 각 타입에 할당할 수 있다.</li><li>심지어 서로의 타입에도 할당 가능하다.</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> obj: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="literal">false</span> &#125; = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">any</span>[] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> und: <span class="literal">undefined</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nul: <span class="literal">null</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> voi: <span class="built_in">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div><p>컴파일 옵션 <code>&quot;strictNullChecks&quot;: true</code>를 사용하면 <code>Null</code>과 <code>Undefined</code>가 서로의 타입을 할당할 수 없다. </p><p>단, <code>Void</code>에는 <code>Undefined</code>을 할당할 수 있다.</p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> voi: <span class="built_in">void</span> = <span class="literal">undefined</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><hr><ul><li><code>Never</code>는 절대 발생하지 않을 값을 나타내며, 어떠한 타입도 적용할 수 없다</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>보통 빈 타입 배열을 타입으로 선정할 경우 에러로 볼 수 있다.</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">never</span>: [] = [];</span><br><span class="line"><span class="built_in">never</span>.push(<span class="number">3</span>); <span class="comment">// Error - TS2345: </span></span><br><span class="line">    <span class="comment">// Argument of type &#x27;3&#x27; is not assignable to parameter of type &#x27;never&#x27;.</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="유니언-Union"><a href="#유니언-Union" class="headerlink" title="유니언 (Union)"></a>유니언 (Union)</h2><hr><ul><li>2개 이상의 타입을 허용하는 경우</li><li><code>|</code>(vertical bar)를 통해 타입을 구분</li><li><code>()</code>는 선택사항이다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> union: (<span class="built_in">string</span> | <span class="built_in">number</span>);</span><br><span class="line">union = <span class="string">&#x27;Hello type!&#x27;</span>;</span><br><span class="line">union = <span class="number">123</span>;</span><br><span class="line">union = <span class="literal">false</span>; <span class="comment">// Error - TS2322: </span></span><br><span class="line">    <span class="comment">// Type &#x27;false&#x27; is not assignable to type &#x27;string | number&#x27;.</span></span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="인터섹션-Intersection"><a href="#인터섹션-Intersection" class="headerlink" title="인터섹션 (Intersection)"></a>인터섹션 (Intersection)</h2><hr><ul><li><code>&amp;</code>(ampersand)를 사용해 2개 이상의 타입을 조합하는 경우</li><li>새 타입을 생성하지 않고 기존 타입들을 조합할 수 있어 유용하나, 자주 사용되진 않음.</li><li>유니언이 <code>Or</code>라면, 인터섹션은 <code>And</code>에 해당</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기존 타입들이 조합 가능하다면 인터섹션을 활용할 수 있다.</span></span><br><span class="line"><span class="keyword">interface</span> IUser &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IValidation &#123;</span><br><span class="line">  <span class="attr">isValid</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> heropy: IUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Heropy&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">36</span>,</span><br><span class="line">  <span class="attr">isValid</span>: <span class="literal">true</span> <span class="comment">// Error -  TS2322: </span></span><br><span class="line">    <span class="comment">// Type &#x27;&#123; name: string; age: number; isValid: boolean; &#125;&#x27; </span></span><br><span class="line">    <span class="comment">// is not assignable to type &#x27;IUser&#x27;.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> neo: IUser &amp; IValidation = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Neo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">85</span>,</span><br><span class="line">  <span class="attr">isValid</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 혹은 기존 타입(IUser, IValidation)과 비슷하지만, </span></span><br><span class="line"><span class="comment">// 정확히 일치하는 타입이 없다면 새로운 타입을 생성해야 한다.</span></span><br><span class="line"><span class="keyword">interface</span> IUserNew &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">isValid</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> evan: IUserNew = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Evan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">36</span>,</span><br><span class="line">  <span class="attr">isValid</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h2 id="함수-Function"><a href="#함수-Function" class="headerlink" title="함수 (Function)"></a>함수 (Function)</h2><hr><ul><li>화살표 함수를 이용해 타입을 지정할 수 있다.</li><li>인수의 타입과 반환 값의 타입을 입력한다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myFunc는 2개의 숫자 타입 인수를 가지고, 숫자 타입을 반환하는 함수.</span></span><br><span class="line"><span class="keyword">let</span> myFunc: <span class="function">(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">myFunc = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인수가 없고, 반환도 없는 경우.</span></span><br><span class="line"><span class="keyword">let</span> yourFunc: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">yourFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello world~&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><br/></p><p><br/></p><h1 id="타입-추론-Type-Inference"><a href="#타입-추론-Type-Inference" class="headerlink" title="타입 추론 (Type Inference)"></a>타입 추론 (Type Inference)</h1><hr><ul><li>명시적으로 타입 선언이 되어있지 않은 경우, 타입스크립트는 타입을 추론해 제공한다.</li><li>타입스크립트가 타입을 추론하는 경우<ul><li>초기화된 변수</li><li>기본값이 설정된 매개 변수 </li><li>반환 값이 있는 함수</li></ul></li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 초기화된 변수 `num`</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본값이 설정된 매개 변수 `b`</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span> = <span class="number">2</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 반환 값(`a + b`)이 있는 함수</span></span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>타입 추론은 엄격하지 않은 타입 선언( <code>strict: false</code> 등 )과는 다르다.</li><li>따라서 타입 추론을 활용하여 <strong>‘모든 곳에 타입 명시’</strong>를 피하는 편이 코드 <strong>가독성</strong>에는 더 좋다.</li></ul><p><br/></p><p><br/></p><h1 id="타입-단언-Type-Assertions"><a href="#타입-단언-Type-Assertions" class="headerlink" title="타입 단언 (Type Assertions)"></a>타입 단언 (Type Assertions)</h1><hr><ul><li>개발자가 컴파일러보다 값의 유형을 더 잘 알고 있을 때 이를 명시하는 방법</li><li>컴파일러에게 <code>내가 뭘 하고 있는지 알아</code> 라고 말하는 것</li><li>다른 언어의 타입 변환(캐스팅)과 <strong>유사</strong>하지만 데이터를 재구성하거나 검사하지 않음<ul><li>캐스팅 : 이미 선언된 타입이 런타임에서 변하는 것</li></ul></li><li>런타임에 영향을 미치지 않고, 온전히 컴파일러만 사용</li><li>타입 스크립트는 개발자가 필요한 어떤 검사를 수행했다고 인지</li></ul><p><br/></p><p>타입 단언에는 두 가지 형태가 있다. 하나는 “<code>angle-bracket</code>“ 문법이다.</p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure></div><p><br/></p><p>다른 하나는 <code>as -</code> 문법이다.</p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure></div><p>위 두 예제는 동일하므로 기호에 따라 선택하여 사용하다.</p><p>그러나 만약 <code>TypeScript</code>를 <code>JSX</code>와 함께 사용할 때는 <code>as -</code> 스타일의 문법만 허용된다.</p><p><br/></p><p><br/></p><h1 id="타입-가드-Type-Guards"><a href="#타입-가드-Type-Guards" class="headerlink" title="타입 가드 (Type Guards)"></a>타입 가드 (Type Guards)</h1><hr><p>타입을 매번 보장하기 위해 타입 단언을 여러 번 사용해야 하는 경우가 있다.</p><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pet <span class="keyword">as</span> Fish).swim) &#123;</span><br><span class="line">    (pet <span class="keyword">as</span> Fish).swim();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((pet <span class="keyword">as</span> Bird).fly) &#123;</span><br><span class="line">    (pet <span class="keyword">as</span> Bird).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>타입 가드는 타입스크립트가 추론 가능한 특정 범위(<code>scope</code>)에서 타입을 보장할 수 있다.</li><li><code>NAME is TYPE</code> 형태의 <strong>타입 서술어</strong>를 반환 타입으로 명시한 함수다.</li><li>여기서 <code>NAME</code>은 반드시 현재 함수의 매개변수 이름이어야 한다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pet <span class="keyword">as</span> Fish).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li><code style="color: #61aeee !important">pet is Fish</code>는 위 예제의 타입 서술어다.</li><li>이를 활용하여 앞선 예제는 아래와 같이 깔끔해진다</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이제 &#x27;swim&#x27;과 &#x27;fly&#x27;에 대한 모든 호출이 허용된다</span></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><p><strong>TypeScript</strong>가 <code>pet</code>이 if문 안에서 <code>Fish</code>라는 것을 알고 있을뿐만 아니라, else문 안에서 <code>Fish</code>가 없다는 것을 알고 있으므로, <code>Bird</code>를 반드시 가지고 있어야한다.</p><p><br/></p><p>위 방식뿐 아니라 제공 가능한 타입가드들이 더 있다.<br><code>typeof</code>, <code>in</code>, <code>instanceof</code> 연산자를 직접 사용하는 타입 가드다.</p><p><br/></p><h2 id="in-연산자-사용하기"><a href="#in-연산자-사용하기" class="headerlink" title="in 연산자 사용하기"></a>in 연산자 사용하기</h2><hr><ul><li><code>in</code> 연산자는 타입을 좁히는 작용을 한다.</li><li><code>n in x</code>에서, <code>n</code>은 문자열 리터럴 혹은 문자열 리터럴 타입이고 <code>x</code>는 유니언 타입이다.</li><li>“<code>true</code>“ 분기에서는 선택적 혹은 필수 프로퍼티 <code>n</code>을 가지는 타입으로 좁힌다.</li><li>“<code>false</code>“ 분기에서는 선택적 혹은 누락된 프로퍼티 n을 가지는 타입으로 좁혀진다.</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">pet: Fish | Bird</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> pet) &#123;</span><br><span class="line">        <span class="keyword">return</span> pet.swim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><h2 id="typeof-타입-가드"><a href="#typeof-타입-가드" class="headerlink" title="typeof 타입 가드"></a>typeof 타입 가드</h2><hr><ul><li>유니언 타입을 사용하는 버전의 <code>padLeft</code> 코드 예제다.</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNumber(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isString(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>그러나 타입이 원시 값인지 확인하는 함수를 정의하는 것은 너무나 귀찮은 일이다.</li><li>다행히도 <code>TypeScript</code>는 <code>typeof</code>를 타입 가드로 인식하기 때문에 typeof <code>x === &quot;number&quot;</code>를 함수로 추상할 필요가 없다.</li><li>즉, 타입 검사를 인라인으로 작성할 수 있다.</li></ul><p><br/></p><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got &#x27;<span class="subst">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li><code>typeof</code> 타입 가드는 두 가지 다른 형식인 typeof <code>v === &quot;typename&quot;</code> 와 typeof <code>v !== &quot;typename&quot;</code>이 있다.</li><li>여기서 <code>typename</code>은 “<code>number</code>“, “<code>string</code>“, “<code>boolean</code>“, “<code>symbol</code>“ 중 하나여야 한다.</li><li><code>TypeScript</code>에서 위에 없는 다른 문자열과 비교하는 것을 막지는 않지만, 타입 가드의 표현식으로 인지되지 않는다.</li></ul><p><br/></p><h2 id="instanceof-타입-가드"><a href="#instanceof-타입-가드" class="headerlink" title="instanceof 타입 가드"></a>instanceof 타입 가드</h2><hr><ul><li><code>instanceof</code> 타입 가드는 생성자 함수를 사용하여 타입을 좁히는 방법이다.</li></ul><div class="clean"><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">        <span class="keyword">new</span> StringPadder(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입은 &#x27;SpaceRepeatingPadder | StringPadder&#x27; 다.</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 타입은 &#x27;SpaceRepeatingPadder&#x27;으로 좁혀진다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 타입은 &#x27;StringPadder&#x27;으로 좁혀진다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><br/></p><p><code>instanceof</code>의 오른쪽은 생성자 함수여야 하며, <code>TypeScript</code>는 다음과 같이 타입을 좁힌다.</p><ul><li>함수의 <code>prototype</code> 프로퍼티 타입이 <code>any</code>가 아닌 경우</li><li>타입의 생성자 시그니처에서 반환된 유니언 타입일 경우</li></ul><p>위 예제와 같은 순서대로 진행된다.</p><p><br/></p><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><ul><li><a href="https://velog.io/@recordboy/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8TypeScript-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8">타입스크립트(TypeScript) 타입 선언</a></li><li><a href="https://fastcampus.co.kr/dev_academy_kmt1">김민태의 프론트엔드 아카데미</a></li><li><a href="https://heropy.blog/2020/01/27/typescript/">한눈에 보는 타입스크립트 - HEROPY TECH</a></li><li><a href="https://typescript-kr.github.io/pages/unions-and-intersections.html">TypeScript Korea</a></li><li><a href="https://poiemaweb.com/typescript-typing">정적 타이핑 - Poiema Web</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">타입스크립트</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">타입스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B9%80%EB%AF%BC%ED%83%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8/">김민태의 프론트엔드 아카데미</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/05/f3a2b4b29950/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) x만큼 간격이 있는 n개의 숫자</title>
      <link>https://sklubmk.github.io/2021/08/04/a5a552938e29/</link>
      <guid>https://sklubmk.github.io/2021/08/04/a5a552938e29/</guid>
      <pubDate>Wed, 04 Aug 2021 06:06:18 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;x만큼-간격이-있는-n개의-숫자&quot;&gt;&lt;a href=&quot;#x만큼-간격이-있는-n개의-숫자&quot; class=&quot;headerlink&quot; title=&quot;x만큼 간격이 있는 n개의 숫자&quot;&gt;&lt;/a&gt;x만큼 간격이 있는 n개의 숫자&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="x만큼-간격이-있는-n개의-숫자"><a href="#x만큼-간격이-있는-n개의-숫자" class="headerlink" title="x만큼 간격이 있는 n개의 숫자"></a>x만큼 간격이 있는 n개의 숫자</h1><p>JavaScript, Python</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.</p><h2 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h2><ul><li>x는 -10000000 이상, 10000000 이하인 정수입니다.</li><li>n은 1000 이하인 자연수입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>x</th><th>n</th><th>answer</th></tr></thead><tbody><tr><td>2</td><td>5</td><td>[2,4,6,8,10]</td></tr><tr><td>4</td><td>3</td><td>[4,8,12]</td></tr><tr><td>-4</td><td>2</td><td>[-4, -8]</td></tr></tbody></table></div></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(n), <span class="function">(<span class="params">a,i</span>) =&gt;</span> (i+<span class="number">1</span>)*x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">x, n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [i*x <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><ul><li>반복되는 배열의 인덱스를 활용하는 문제다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/04/a5a552938e29/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 행렬의 덧셈</title>
      <link>https://sklubmk.github.io/2021/08/04/6c54e9ab7bc7/</link>
      <guid>https://sklubmk.github.io/2021/08/04/6c54e9ab7bc7/</guid>
      <pubDate>Wed, 04 Aug 2021 06:05:55 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;행렬의-덧셈&quot;&gt;&lt;a href=&quot;#행렬의-덧셈&quot; class=&quot;headerlink&quot; title=&quot;행렬의 덧셈&quot;&gt;&lt;/a&gt;행렬의 덧셈&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="행렬의-덧셈"><a href="#행렬의-덧셈" class="headerlink" title="행렬의 덧셈"></a>행렬의 덧셈</h1><p>JavaScript, Python</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.</p><h2 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h2><ul><li>행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>arr1</th><th>arr2</th><th>return</th></tr></thead><tbody><tr><td>[[1,2],[2,3]]</td><td>[[3,4],[5,6]]</td><td>[[4,6],[7,9]]</td></tr><tr><td>[[1],[2]]</td><td>[[3],[4]]</td><td>[[4],[6]]</td></tr></tbody></table></div></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.map(<span class="function">(<span class="params">a1,i</span>)=&gt;</span>a1.map(<span class="function">(<span class="params">a1_,i_</span>)=&gt;</span>a1_+arr2[i][i_]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">arr1, arr2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ [c+d <span class="keyword">for</span> c,d <span class="keyword">in</span> <span class="built_in">zip</span>(a,b)] <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(arr1,arr2)]</span><br></pre></td></tr></table></figure><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>두 배열의 연산 능력을 묻는 문제.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/04/6c54e9ab7bc7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 핸드폰 번호 가리기</title>
      <link>https://sklubmk.github.io/2021/08/04/5106f0ee5223/</link>
      <guid>https://sklubmk.github.io/2021/08/04/5106f0ee5223/</guid>
      <pubDate>Wed, 04 Aug 2021 06:05:20 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;핸드폰-번호-가리기&quot;&gt;&lt;a href=&quot;#핸드폰-번호-가리기&quot; class=&quot;headerlink&quot; title=&quot;핸드폰 번호 가리기&quot;&gt;&lt;/a&gt;핸드폰 번호 가리기&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="핸드폰-번호-가리기"><a href="#핸드폰-번호-가리기" class="headerlink" title="핸드폰 번호 가리기"></a>핸드폰 번호 가리기</h1><p>JavaScript, Python</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.\<br>전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 <code>*</code>으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.</p><h2 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h2><ul><li>s는 길이 4 이상, 20이하인 문자열입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>phone_number</th><th>return</th></tr></thead><tbody><tr><td>“01033334444”</td><td>“<strong><em>*</em></strong>4444”</td></tr><tr><td>“027778888”</td><td>“<strong>*</strong>8888”</td></tr></tbody></table></div></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">phone_number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> phone_number.split(<span class="string">&#x27;&#x27;</span>).reverse().map(<span class="function">(<span class="params">n,i</span>)=&gt;</span>i&lt;<span class="number">4</span>?n:<span class="string">&#x27;*&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">phone_number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span>*(<span class="built_in">len</span>(phone_number)-<span class="number">4</span>) + phone_number[-<span class="number">4</span>:]</span><br></pre></td></tr></table></figure><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>문자열 반복 구현 방법을 묻는 문제.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/04/5106f0ee5223/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 하샤드 수</title>
      <link>https://sklubmk.github.io/2021/08/04/a35ac8d3f93b/</link>
      <guid>https://sklubmk.github.io/2021/08/04/a35ac8d3f93b/</guid>
      <pubDate>Wed, 04 Aug 2021 06:04:52 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;하샤드-수&quot;&gt;&lt;a href=&quot;#하샤드-수&quot; class=&quot;headerlink&quot; title=&quot;하샤드 수&quot;&gt;&lt;/a&gt;하샤드 수&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="하샤드-수"><a href="#하샤드-수" class="headerlink" title="하샤드 수"></a>하샤드 수</h1><p>JavaScript, Python</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.</p><h2 id="제한-조건"><a href="#제한-조건" class="headerlink" title="제한 조건"></a>제한 조건</h2><ul><li><code>x</code>는 1 이상, 10000 이하인 정수입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>arr</th><th>return</th></tr></thead><tbody><tr><td>10</td><td>true</td></tr><tr><td>12</td><td>true</td></tr><tr><td>11</td><td>false</td></tr><tr><td>13</td><td>false</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1\<br>10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다.</p><p>입출력 예 #2\<br>12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다.</p><p>입출력 예 #3\<br>11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다.</p><p>입출력 예 #4\<br>13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다.</p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % (x+<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27;&#x27;</span>).reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a*<span class="number">1</span>+b*<span class="number">1</span>,<span class="number">0</span>) === <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">str</span>(x))) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>숫자를 문자열을 나누고, 이를 다시 정수형으로 변환하여 자릿수 합을 구한다.</p><p>이를 원래 값에 나누어 정답 결과를 반환한다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/04/a35ac8d3f93b/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
