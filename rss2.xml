<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JK&#39;s Devlog</title>
    <link>https://sklubmk.github.io/</link>
    
    <atom:link href="https://sklubmk.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Jinki Kim&#39;s Front End Devlog</description>
    <pubDate>Fri, 03 Sep 2021 08:46:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[프로그래머스] (LV3) 가장 먼 노드</title>
      <link>https://sklubmk.github.io/2021/09/03/8bd3bc05bead/</link>
      <guid>https://sklubmk.github.io/2021/09/03/8bd3bc05bead/</guid>
      <pubDate>Fri, 03 Sep 2021 08:26:23 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.</p><p>노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>노드의 개수 n은 2 이상 20,000 이하입니다.</li><li>간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.</li><li>vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>vertex</th><th>return</th></tr></thead><tbody><tr><td>6</td><td>[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]</td><td>3</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>예제의 그래프를 표현하면 아래 그림과 같고, 1번 노드에서 가장 멀리 떨어진 노드는 4,5,6번 노드입니다.</p><p><img src="https://grepp-programmers.s3.amazonaws.com/files/ybm/fadbae38bb/dec85ab5-0273-47b3-ba73-fc0b5f6be28a.png" alt="image.png"></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, edge</span>):</span></span><br><span class="line">    inf = <span class="number">50001</span></span><br><span class="line">    dist = [inf]*(n+<span class="number">1</span>)</span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    nodes = []</span><br><span class="line">    isVisit = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> edge:</span><br><span class="line">        graph[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line">        graph[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    h.heappush(nodes,(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> nodes:</span><br><span class="line">        cur_dist, cur_node = h.heappop(nodes)</span><br><span class="line">        <span class="keyword">if</span> isVisit[cur_node] == <span class="literal">True</span>: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>: isVisit[cur_node] = <span class="literal">True</span></span><br><span class="line">        dist[cur_node] = cur_dist</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> next_node <span class="keyword">in</span> graph[cur_node]:</span><br><span class="line">            <span class="keyword">if</span> dist[next_node] &gt; cur_dist+<span class="number">1</span>:</span><br><span class="line">                h.heappush(nodes,(cur_dist+<span class="number">1</span>,next_node))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist.count(<span class="built_in">max</span>(d <span class="keyword">for</span> d <span class="keyword">in</span> dist <span class="keyword">if</span> d != inf))</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><code>dijkstra</code> 최단거리 알고리즘의 개념을 잘 알고 있다면 무리없이 풀 수 있는 <strong>그래프</strong> 문제다.</p><p><br/></p><p>주어진 간선 그래프를 저장하고, 한 <code>heap queue</code>를 만들어 그곳에 방문하게 될 노드들의 스케줄을 짠다고 생각하편 간편하다. 풀이에서 <code>nodes</code>가 그 역할을 하는데, while문에선 이를통해 다음과 같은 사항을 반복적으로 수행한다.</p><p><br/></p><ul><li><code>nodes</code>에서 <code>heappop()</code>을 통해 현재까지 지나온 거리가 가장 가까운 노드 정보를 뽑는다.<ul><li>이미 초기화 되지 않았다면 반드시 최단거리가 되므로, <code>dist</code>에 할당하면 된다.</li></ul></li><li>뽑은 노드 정보로 <strong>방문</strong>한다. <code>isVisit</code>을 통해 방문 여부를 체크하고, 첫 방문이 아니면 <code>continue</code>한다.</li><li>그래프에서 다시 현재 노드와 연결된 간선들의 정보를 가져와 <code>heap queue</code>에 <code>push</code>한다.</li></ul><p><br/></p><p>이렇게 주어진 <code>dist</code> 결과에서 초기값 <code>inf</code>를 제외한 최대 값의 개수를 찾아 반환하면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      
      <comments>https://sklubmk.github.io/2021/09/03/8bd3bc05bead/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV4) 징검다리</title>
      <link>https://sklubmk.github.io/2021/09/02/7d7086579935/</link>
      <guid>https://sklubmk.github.io/2021/09/02/7d7086579935/</guid>
      <pubDate>Thu, 02 Sep 2021 10:10:42 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.\<br>예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.</p><div class="table-container"><table><thead><tr><th>제거한 바위의 위치</th><th>각 바위 사이의 거리</th><th>거리의 최솟값</th></tr></thead><tbody><tr><td>[21, 17]</td><td>[2, 9, 3, 11]</td><td>2</td></tr><tr><td>[2, 21]</td><td>[11, 3, 3, 8]</td><td>3</td></tr><tr><td>[2, 11]</td><td>[14, 3, 4, 4]</td><td>3</td></tr><tr><td>[11, 21]</td><td>[2, 12, 3, 8]</td><td>2</td></tr><tr><td>[2, 14]</td><td>[11, 6, 4, 4]</td><td>4</td></tr></tbody></table></div><p>위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.</p><p>출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.</li><li>바위는 1개 이상 50,000개 이하가 있습니다.</li><li>n 은 1 이상 <code>바위의 개수</code> 이하입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>distance</th><th>rocks</th><th>n</th><th>return</th></tr></thead><tbody><tr><td>25</td><td>[2, 14, 11, 21, 17]</td><td>2</td><td>4</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>문제에 나온 예와 같습니다.</p><p><a href="http://contest.usaco.org/DEC06.htm">출처</a></p><p>※ 공지 - 2020년 2월 17일 테스트케이스가 추가되었습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">distance, rocks, n</span>):</span></span><br><span class="line">    rocks.sort()</span><br><span class="line">    left, right = <span class="number">1</span>, distance</span><br><span class="line">    <span class="keyword">while</span> right &gt;= left:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        prev = cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rocks)):</span><br><span class="line">            <span class="keyword">if</span> rocks[i] - prev &lt; mid: </span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                prev = rocks[i]</span><br><span class="line">        <span class="keyword">if</span> cnt &gt; n: </span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><code>[시도해본 풀이 방법들]</code></p><ul><li><code>combinations</code>를 이용한 <code>brute force</code> 풀이</li><li>정렬 후 <code>min</code>값에 따라 돌을 한 개씩 제거하는 방법</li><li>거리 기준 정렬 후 순차적 제거</li></ul><p><code>[정답 풀이 방법]</code></p><ul><li><strong>이분 탐색(Binary Search)</strong></li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv4/">lv4</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv4/">lv4</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      
      <comments>https://sklubmk.github.io/2021/09/02/7d7086579935/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 추석 트래픽</title>
      <link>https://sklubmk.github.io/2021/08/31/bf79b39f4914/</link>
      <guid>https://sklubmk.github.io/2021/08/31/bf79b39f4914/</guid>
      <pubDate>Tue, 31 Aug 2021 14:16:34 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.</p><h1 id="입력-형식"><a href="#입력-형식" class="headerlink" title="입력 형식"></a>입력 형식</h1><ul><li><code>solution</code> 함수에 전달되는 <code>lines</code> 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.</li><li>응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 <code>2016-09-15 hh:mm:ss.sss</code> 형식으로 되어 있다.</li><li>처리시간 T는 <code>0.1s</code>, <code>0.312s</code>, <code>2s</code> 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 <code>s</code>로 끝난다.</li><li>예를 들어, 로그 문자열 <code>2016-09-15 03:10:33.020 0.011s</code>은 “2016년 9월 15일 오전 3시 10분 33.010초”부터 “2016년 9월 15일 오전 3시 10분 33.020초”까지 “0.011초” 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함)</li><li>서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.</li><li><code>lines</code> 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.</li></ul><h2 id="출력-형식"><a href="#출력-형식" class="headerlink" title="출력 형식"></a>출력 형식</h2><ul><li><code>solution</code> 함수에서는 로그 데이터 <code>lines</code> 배열에 대해 초당 최대 처리량을 리턴한다.</li></ul><h2 id="입출력-예제"><a href="#입출력-예제" class="headerlink" title="입출력 예제"></a>입출력 예제</h2><h2 id="예제1"><a href="#예제1" class="headerlink" title="예제1"></a>예제1</h2><ul><li><p>입력: [\<br>“2016-09-15 01:00:04.001 2.0s”,\<br>“2016-09-15 01:00:07.000 2s”\<br>]</p></li><li><p>출력: 1</p></li></ul><h2 id="예제2"><a href="#예제2" class="headerlink" title="예제2"></a>예제2</h2><ul><li><p>입력: [\<br>“2016-09-15 01:00:04.002 2.0s”,\<br>“2016-09-15 01:00:07.000 2s”\<br>]</p></li><li><p>출력: 2</p></li><li><p>설명: 처리시간은 시작시간과 끝시간을 포함하므로\<br>첫 번째 로그는 <code>01:00:02.003 ~ 01:00:04.002</code>에서 2초 동안 처리되었으며,\<br>두 번째 로그는 <code>01:00:05.001 ~ 01:00:07.000</code>에서 2초 동안 처리된다.\<br>따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 <code>01:00:04.002 ~ 01:00:05.001</code> 1초 동안 최대 2개가 된다.</p></li></ul><h2 id="예제3"><a href="#예제3" class="headerlink" title="예제3"></a>예제3</h2><ul><li><p>입력: [\<br>“2016-09-15 20:59:57.421 0.351s”,\<br>“2016-09-15 20:59:58.233 1.181s”,\<br>“2016-09-15 20:59:58.299 0.8s”,\<br>“2016-09-15 20:59:58.688 1.041s”,\<br>“2016-09-15 20:59:59.591 1.412s”,\<br>“2016-09-15 21:00:00.464 1.466s”,\<br>“2016-09-15 21:00:00.741 1.581s”,\<br>“2016-09-15 21:00:00.748 2.31s”,\<br>“2016-09-15 21:00:00.966 0.381s”,\<br>“2016-09-15 21:00:02.066 2.62s”\<br>]</p></li><li><p>출력: 7</p></li><li><p>설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 <code>(1)</code>은 4개, <code>(2)</code>는 7개, <code>(3)</code>는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.\<br><img src="http://t1.kakaocdn.net/welcome2018/chuseok-01-v5.png" alt="Timeline"></p></li></ul><p><a href="http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/">해설 보러가기</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">lines</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">        l = lines[i]</span><br><span class="line">        splits = l.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        end = dt.datetime.strptime(<span class="string">&quot; &quot;</span>.join(splits[:<span class="number">2</span>]), <span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)</span><br><span class="line">        start = end - dt.timedelta(seconds=<span class="built_in">float</span>(splits[<span class="number">2</span>][:-<span class="number">1</span>])-<span class="number">0.001</span>)</span><br><span class="line">        lines[i] = (start, end)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines)):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        endTime = lines[idx][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx,<span class="built_in">len</span>(lines)):</span><br><span class="line">            <span class="keyword">if</span> endTime + dt.timedelta(seconds=<span class="number">0.999</span>) &lt; lines[i][<span class="number">0</span>]: <span class="keyword">continue</span>;                </span><br><span class="line">            <span class="keyword">elif</span> endTime &gt; lines[i][<span class="number">1</span>]: <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count+=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        answer = <span class="built_in">max</span>(answer, count)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><h2 id="핵심-사항"><a href="#핵심-사항" class="headerlink" title="핵심 사항"></a>핵심 사항</h2><ul><li>데이터 파싱단계에서 <code>datetime</code> 라이브러리 숙련도가 필요하다.</li><li><code>delta time</code>을 더할 때 <code>1</code> 마이크로초(문제 내 최소단위)를 빼야 한다.<ul><li>1초의 범위가 <code>0.000</code> ~ <code>0.999</code>이기 때문. (쉽게 말하면 <code>0</code>도 포함되서)</li><li>부등호를 잘 조절하면 해당 작업을 하지 않아도 되는 것 같다.</li></ul></li><li>주어지는 <code>log</code>들은 종료 시점으로 정렬되어 있다. (문제를 잘 읽자)</li><li>주어진 <code>log</code>들의 시작시점을 계산하여 저장한다.</li><li>이중 반복문을 통해 <strong>현 <code>log</code>의 종료시점 + <code>1</code>초</strong>보다 <strong>시작시간</strong>이 같거나 작은 로그와,</li><li>동시에 <strong>현 <code>log</code>의 종료시점</strong>보다 <strong>종료시간</strong>이 같거나 큰 로그들을 카운팅 하여 최대값을 찾는다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/31/bf79b39f4914/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 모음 사전</title>
      <link>https://sklubmk.github.io/2021/08/30/ef36d4eaefde/</link>
      <guid>https://sklubmk.github.io/2021/08/30/ef36d4eaefde/</guid>
      <pubDate>Mon, 30 Aug 2021 13:32:26 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>사전에 알파벳 모음 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 “A”이고, 그다음은 “AA”이며, 마지막 단어는 “UUUUU”입니다.</p><p>단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>word의 길이는 1 이상 5 이하입니다.</li><li>word는 알파벳 대문자 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’로만 이루어져 있습니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>word</th><th>result</th></tr></thead><tbody><tr><td><code>&quot;AAAAE&quot;</code></td><td>6</td></tr><tr><td><code>&quot;AAAE&quot;</code></td><td>10</td></tr><tr><td><code>&quot;I&quot;</code></td><td>1563</td></tr><tr><td><code>&quot;EIO&quot;</code></td><td>1189</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>사전에서 첫 번째 단어는 “A”이고, 그다음은 “AA”, “AAA”, “AAAA”, “AAAAA”, “AAAAE”, … 와 같습니다. “AAAAE”는 사전에서 6번째 단어입니다.</p><p>입출력 예 #2</p><p>“AAAE”는 “A”, “AA”, “AAA”, “AAAA”, “AAAAA”, “AAAAE”, “AAAAI”, “AAAAO”, “AAAAU”의 다음인 10번째 단어입니다.</p><p>입출력 예 #3</p><p>“I”는 1563번째 단어입니다.</p><p>입출력 예 #4</p><p>“EIO”는 1189번째 단어입니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">word</span>):</span></span><br><span class="line">    </span><br><span class="line">    basic = <span class="built_in">list</span>(<span class="string">&#x27;AEIOU&#x27;</span>)</span><br><span class="line">    book = <span class="built_in">set</span>(basic)</span><br><span class="line">    temp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> word_ <span class="keyword">in</span> book:</span><br><span class="line">            <span class="keyword">for</span> apb <span class="keyword">in</span> basic:</span><br><span class="line">                temp.append(word_+apb)</span><br><span class="line">        book.update(temp)</span><br><span class="line">        temp=[]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(book)).index(word) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>복잡하게 생각하면 오히려 난이도가 높아지는 문제다. </p><p>나도 처음에는 단어가 배열되는 규칙을 찾아 값이 나오는 함수를 구현하려 했는데, 문득 수학 문제를 풀고있는 것이 아닌가란 생각이 들었다.</p><p>코딩 문제란 것을 잊지 않으면, 사전 자체를 만들어버리는 생각을 떠올리는 것은 간단하다.</p><p>사전 단어들은 기존 단어에 <code>A E I O U</code>의 모음 단어 하나씩 오른쪽에 더하는 과정을 4번 반복하면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/30/ef36d4eaefde/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 숫자의 표현</title>
      <link>https://sklubmk.github.io/2021/08/27/fcb225688f00/</link>
      <guid>https://sklubmk.github.io/2021/08/27/fcb225688f00/</guid>
      <pubDate>Fri, 27 Aug 2021 14:47:04 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.</p><ul><li>1 + 2 + 3 + 4 + 5 = 15</li><li>4 + 5 + 6 = 15</li><li>7 + 8 = 15</li><li>15 = 15</li></ul><p>자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>n은 10,000 이하의 자연수 입니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>result</th></tr></thead><tbody><tr><td>15</td><td>4</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예#1\<br>문제의 예시와 같습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n+<span class="number">1</span>):</span><br><span class="line">            count += j</span><br><span class="line">            <span class="keyword">if</span> count == n:</span><br><span class="line">                answer += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> count &gt; n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><script type="math/tex">O(N^2)</script>으로도 풀리는 간단한 문제지만, 자료구조를 이용하면 더 빠르게 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/27/fcb225688f00/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 주식가격</title>
      <link>https://sklubmk.github.io/2021/08/25/752f5e69183a/</link>
      <guid>https://sklubmk.github.io/2021/08/25/752f5e69183a/</guid>
      <pubDate>Wed, 25 Aug 2021 11:14:10 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li><li>prices의 길이는 2 이상 100,000 이하입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>prices</th><th>return</th></tr></thead><tbody><tr><td>[1, 2, 3, 2, 3]</td><td>[4, 3, 1, 1, 0]</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><ul><li>1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.</li><li>2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.</li><li>3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.</li><li>4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.</li><li>5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.</li></ul><p>※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">prices</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(prices)</span><br><span class="line">    answer = [<span class="number">0</span>]*n</span><br><span class="line">    <span class="keyword">for</span> i, price <span class="keyword">in</span> <span class="built_in">enumerate</span>(prices):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            answer[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> price &gt; prices[j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>문제 설명이 애매한 편이지만, 차분하게 풀면 <script type="math/tex">O(N^2)</script>의 효율성 만으로도 풀 수 있는 문제다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/25/752f5e69183a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 직업군 추천하기</title>
      <link>https://sklubmk.github.io/2021/08/23/f67283951ab9/</link>
      <guid>https://sklubmk.github.io/2021/08/23/f67283951ab9/</guid>
      <pubDate>Mon, 23 Aug 2021 10:31:01 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>개발자가 사용하는 언어와 <code>언어 선호도</code>를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.</p><p>아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 <code>직업군 언어 점수</code>를 부여한 표입니다.</p><div class="table-container"><table><thead><tr><th>점수</th><th>SI</th><th>CONTENTS</th><th>HARDWARE</th><th>PORTAL</th><th>GAME</th></tr></thead><tbody><tr><td>5</td><td>JAVA</td><td>JAVASCRIPT</td><td>C</td><td>JAVA</td><td>C++</td></tr><tr><td>4</td><td>JAVASCRIPT</td><td>JAVA</td><td>C++</td><td>JAVASCRIPT</td><td>C#</td></tr><tr><td>3</td><td>SQL</td><td>PYTHON</td><td>PYTHON</td><td>PYTHON</td><td>JAVASCRIPT</td></tr><tr><td>2</td><td>PYTHON</td><td>SQL</td><td>JAVA</td><td>KOTLIN</td><td>C</td></tr><tr><td>1</td><td>C#</td><td>C++</td><td>JAVASCRIPT</td><td>PHP</td><td>JAVA</td></tr></tbody></table></div><p>예를 들면, SQL의 SI <code>직업군 언어 점수</code>는 3점이지만 CONTENTS <code>직업군 언어 점수</code>는 2점입니다. SQL의 HARDWARE, PORTAL, GAME <code>직업군 언어 점수</code>는 0점입니다.</p><p><code>직업군 언어 점수</code>를 정리한 문자열 배열 <code>table</code>, 개발자가 사용하는 언어를 담은 문자열 배열 <code>languages</code>, <code>언어 선호도</code>를 담은 정수 배열 <code>preference</code>가 매개변수로 주어집니다. 개발자가 사용하는 언어의 <code>언어 선호도</code> x <code>직업군 언어 점수</code>의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요. 총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.</p><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li><code>table</code>의 길이 = 5<ul><li><code>table</code>의 원소는 <code>&quot;직업군 5점언어 4점언어 3점언어 2점언어 1점언어&quot;</code>형식의 문자열입니다. <code>직업군</code>, <code>5점언어</code>, <code>4언어</code>, <code>3점언어</code>, <code>2점언어</code>, <code>1점언어</code>는 하나의 공백으로 구분되어 있습니다.</li><li><code>table</code>은 모든 테스트케이스에서 동일합니다.</li></ul></li><li>1 ≤ <code>languages</code>의 길이 ≤ 9<ul><li><code>languages</code>의 원소는 <code>&quot;JAVA&quot;</code>, <code>&quot;JAVASCRIPT&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;C++&quot;</code> ,<code>&quot;C#&quot;</code> , <code>&quot;SQL&quot;</code>, <code>&quot;PYTHON&quot;</code>, <code>&quot;KOTLIN&quot;</code>, <code>&quot;PHP&quot;</code> 중 한 개 이상으로 이루어져 있습니다.</li><li><code>languages</code>의 원소는 중복되지 않습니다.</li></ul></li><li><code>preference</code>의 길이 = <code>languages</code>의 길이<ul><li>1 ≤ <code>preference</code>의 원소 ≤ 10</li></ul></li><li><code>preference</code>의 i번째 원소는 <code>languages</code>의 i번째 원소의 <code>언어 선호도</code>입니다.</li><li>return 할 문자열은 <code>&quot;SI&quot;</code>, <code>&quot;CONTENTS&quot;</code>, <code>&quot;HARDWARE&quot;</code>, <code>&quot;PORTAL&quot;</code>, <code>&quot;GAME&quot;</code> 중 하나입니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>table</th><th>languages</th><th>preference</th><th>result</th></tr></thead><tbody><tr><td><code>[&quot;SI JAVA JAVASCRIPT SQL PYTHON C#&quot;, &quot;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++&quot;, &quot;HARDWARE C C++ PYTHON JAVA JAVASCRIPT&quot;, &quot;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP&quot;, &quot;GAME C++ C# JAVASCRIPT C JAVA&quot;]</code></td><td><code>[&quot;PYTHON&quot;, &quot;C++&quot;, &quot;SQL&quot;]</code></td><td>[7, 5, 5]</td><td><code>&quot;HARDWARE&quot;</code></td></tr><tr><td><code>[&quot;SI JAVA JAVASCRIPT SQL PYTHON C#&quot;, &quot;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++&quot;, &quot;HARDWARE C C++ PYTHON JAVA JAVASCRIPT&quot;, &quot;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP&quot;, &quot;GAME C++ C# JAVASCRIPT C JAVA&quot;]</code></td><td><code>[&quot;JAVA&quot;, &quot;JAVASCRIPT&quot;]</code></td><td>[7, 5]</td><td><code>&quot;PORTAL&quot;</code></td></tr></tbody></table></div><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>각 직업군 별로 점수를 계산해보면 아래와 같습니다.</p><p>아래 사진은 <code>개발자 언어 선호도</code> 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9a711ad6-4a8e-4028-b100-0280a4e3a7dd/tc1_preference.PNG" alt="tc1_preference.PNG"></p><p>아래 사진은 개발자가 선호하는 언어의 <code>직업군 언어 점수</code>를 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/1ef5a88a-8109-415d-b611-a6320410b1e1/tc1_score.PNG" alt="tc1_score.PNG"></p><p>따라서 점수 총합이 41로 가장 높은 <code>&quot;HARDWARE&quot;</code>를 return 해야 합니다.</p><p>입출력 예 #2</p><p>각 직업군 별로 점수를 계산해보면 아래와 같습니다.</p><p>아래 사진은 <code>개발자 언어 선호도</code> 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e49d818b-938a-4cc3-8d2a-27783f2e1af5/tc2_preference.PNG" alt="tc2_preference.PNG"></p><p>아래 사진은 개발자가 선호하는 언어의 <code>직업군 언어 점수</code>를 나타낸 표입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0624156e-e1d3-4299-b554-470815322a79/tc2_score.PNG" alt="tc2_score.PNG">\<br>점수 총합이 55로 가장 높은 직업군은 “SI” 와 “PORTAL”입니다.\<br>따라서 사전 순으로 먼저 오는 <code>&quot;PORTAL&quot;</code>을 return 해야 합니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">table, languages, preference</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    table_hash = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):</span><br><span class="line">        t_s = table[i].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        table_hash[t_s[<span class="number">0</span>]] = &#123;t:<span class="number">5</span>-i <span class="keyword">for</span> i,t <span class="keyword">in</span> <span class="built_in">enumerate</span>(t_s[<span class="number">1</span>:])&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> table_hash.items():</span><br><span class="line">        h.heappush(answer,(-<span class="built_in">sum</span>(t[<span class="number">1</span>][l]*preference[l_i] <span class="keyword">for</span> l_i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(languages) <span class="keyword">if</span> l <span class="keyword">in</span> t[<span class="number">1</span>]),t[<span class="number">0</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> h.heappop(answer)[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/23/f67283951ab9/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 디스크 컨트롤러</title>
      <link>https://sklubmk.github.io/2021/08/22/3f56f3c9af6f/</link>
      <guid>https://sklubmk.github.io/2021/08/22/3f56f3c9af6f/</guid>
      <pubDate>Sun, 22 Aug 2021 07:51:32 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.</p><p>예를들어</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 0ms 시점에 3ms가 소요되는 A작업 요청</span><br><span class="line">- 1ms 시점에 9ms가 소요되는 B작업 요청</span><br><span class="line">- 2ms 시점에 6ms가 소요되는 C작업 요청</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.\<br><img src="https://grepp-programmers.s3.amazonaws.com/files/production/b68eb5cec6/38dc6a53-2d21-4c72-90ac-f059729c51d5.png" alt="Screen Shot 2018-09-13 at 6.34.58 PM.png"></p><p>한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.\<br><img src="https://grepp-programmers.s3.amazonaws.com/files/production/5e677b4646/90b91fde-cac4-42c1-98b8-8f8431c52dcf.png" alt="Screen Shot 2018-09-13 at 6.38.52 PM.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)</span><br><span class="line">- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)</span><br><span class="line">- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다.</p><p>하지만 A → C → B 순서대로 처리하면\<br><img src="https://grepp-programmers.s3.amazonaws.com/files/production/9eb7c5a6f1/a6cff04d-86bb-4b5b-98bf-6359158940ac.png" alt="Screen Shot 2018-09-13 at 6.41.42 PM.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)</span><br><span class="line">- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)</span><br><span class="line">- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다.</p><p>각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)</p><h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><ul><li>jobs의 길이는 1 이상 500 이하입니다.</li><li>jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.</li><li>각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.</li><li>각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.</li><li>하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>jobs</th><th>return</th></tr></thead><tbody><tr><td>[[0, 3], [1, 9], [2, 6]]</td><td>9</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>문제에 주어진 예와 같습니다.</p><ul><li>0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.</li><li>1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.</li><li>2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">jobs</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(jobs)</span><br><span class="line">    jobs.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>]);</span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    time = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> jobs:</span><br><span class="line">        hq = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(jobs) <span class="keyword">and</span> jobs[i][<span class="number">0</span>] &lt;= time:</span><br><span class="line">            h.heappush(hq,(jobs[i][<span class="number">1</span>],time-jobs[i][<span class="number">0</span>]+jobs[i][<span class="number">1</span>], i))</span><br><span class="line">            i+=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(hq) == <span class="number">0</span>:</span><br><span class="line">            time = jobs[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            next_job = h.heappop(hq)</span><br><span class="line">            time += next_job[<span class="number">0</span>]</span><br><span class="line">            answer += next_job[<span class="number">1</span>]</span><br><span class="line">            jobs.pop(next_job[<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer//n</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>현재 시점 기준으로 요청된 작업들 중 가장 수행시간이 짧은 작업을 매번 선택하면 되고, 이는 <code>그리디</code> 처럼 작동한다.</p><p><br/></p><p><code>heap queue</code>를 활용하는 문제인데, 처음에 어떤 값을 넣어야 할지 혼동스러웠다. 결과 값으로 저장해야하는 값(처음 요청된 시간 ~ 요청 종료까지 시간)을 기준으로 <code>heap queue</code>에 담았는데, 이러다보니 작업시간이 짧지만 대기한 시간이 긴 작업들의 우선권이 뒤로 밀려버렸다.</p><p><br/></p><p>이내 수행시간을 기준으로 <code>heap queue</code>에 담아 문제를 푸니 정상적으로 풀이 되었다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/22/3f56f3c9af6f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 순위</title>
      <link>https://sklubmk.github.io/2021/08/21/583bf6e35728/</link>
      <guid>https://sklubmk.github.io/2021/08/21/583bf6e35728/</guid>
      <pubDate>Sat, 21 Aug 2021 12:57:25 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.</p><p>선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>선수의 수는 1명 이상 100명 이하입니다.</li><li>경기 결과는 1개 이상 4,500개 이하입니다.</li><li>results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.</li><li>모든 경기 결과에는 모순이 없습니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>results</th><th>return</th></tr></thead><tbody><tr><td>5</td><td>[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]</td><td>2</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.\<br>5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.</p><p><a href="http://contest.usaco.org/JAN08.htm">출처</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, results</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    wins = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">        winner, loser = r</span><br><span class="line">        wins[winner][loser] = <span class="number">1</span></span><br><span class="line">        wins[loser][winner] = -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> visit <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> wins[start][end] == <span class="number">0</span> <span class="keyword">and</span> wins[start][visit] == wins[visit][end]:</span><br><span class="line">                    wins[start][end] = wins[start][visit]</span><br><span class="line">                    wins[end][start] = -<span class="number">1</span>*wins[start][visit]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> wins[i].count(<span class="number">0</span>) == <span class="number">2</span>: </span><br><span class="line">            answer+=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p> <code>1</code>. <code>A</code>가 <code>B</code>를 이겼다<br> <code>2</code>. <code>B</code>가 <code>C</code>를 이겼다<br> <code>3</code>. 따라서 <code>A</code>는 <code>C</code>를 이긴다</p><p>풀이를 위해선 <code>3</code>번의 간접적인 순위를 직접적인 순위관계로 변화시켜야한다.</p><p><br/></p><p>각 <strong>시작</strong>, <strong>방문</strong>, <strong>목적지</strong> 노드를 뜻하는 세 번의 반복문을 수행한다.</p><ol><li>시작 -&gt; 목적지 노드의 순위관계가 정해져 있지 않고,</li><li>시작 -&gt; 방문 노드의 순위 관계가 정해져있고,</li><li>방문 -&gt; 목적지 노드의 순위관계가 2번의 관계와 동일하다면, 이를 1번에 할당한다.</li></ol><p><br/></p><p>위 과정을 거치면 확실히 순위관계를 나타낼 수 있는 항목의 값들은 모두 값이 체워진다. 따라서 이러한 노드의 개수를 반환하면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B7%B8%EB%9E%98%ED%94%84/">그래프</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/21/583bf6e35728/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 입국심사</title>
      <link>https://sklubmk.github.io/2021/08/20/79376bb85650/</link>
      <guid>https://sklubmk.github.io/2021/08/20/79376bb85650/</guid>
      <pubDate>Fri, 20 Aug 2021 14:04:36 GMT</pubDate>
      
      <description>&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Python3<br><span id="more"></span></p><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.</p><p>처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.</p><p>모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.</p><p>입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.</li><li>각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.</li><li>심사관은 1명 이상 100,000명 이하입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>times</th><th>return</th></tr></thead><tbody><tr><td>6</td><td>[7, 10]</td><td>28</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>가장 첫 두 사람은 바로 심사를 받으러 갑니다.</p><p>7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.</p><p>10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.</p><p>14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.</p><p>20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.</p><p><a href="http://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf">출처</a></p><p>※ 공지 - 2019년 9월 4일 문제에 새로운 테스트 케이스를 추가하였습니다. 도움을 주신 weaver9651 님께 감사드립니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, times</span>):</span></span><br><span class="line">    answer = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    left, right = <span class="number">1</span>, n*<span class="built_in">max</span>(times)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        cur_times= <span class="built_in">sum</span>(mid//t <span class="keyword">for</span> t <span class="keyword">in</span> times)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_times &gt;= n:</span><br><span class="line">            answer = <span class="built_in">min</span>(answer, mid)</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cur_times &lt; n:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>결과 값은 반드시 <code>times</code>에 포함된 한 값의 <strong>공배수</strong>가 되므로, <code>times</code>내의 값들을 탐색하며 정답을 찾으면 된다. <code>left</code>는 문제 조건의 최소값인 1을, <code>right</code>는 주어진 <code>times</code>의 최대값 x n을 할당한다. 정답은 반드시 이 두 범위 안에 존재하므로, 이분탐색을 활용하여 정답을 구한다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/">이분탐색</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/20/79376bb85650/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 퍼즐 조각 채우기</title>
      <link>https://sklubmk.github.io/2021/08/18/8c559b93b60c/</link>
      <guid>https://sklubmk.github.io/2021/08/18/8c559b93b60c/</guid>
      <pubDate>Wed, 18 Aug 2021 11:08:19 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;퍼즐-조각-채우기&quot;&gt;&lt;a href=&quot;#퍼즐-조각-채우기&quot; class=&quot;headerlink&quot; title=&quot;퍼즐 조각 채우기&quot;&gt;&lt;/a&gt;퍼즐 조각 채우기&lt;/h1&gt;&lt;p&gt;Python3&lt;br&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="퍼즐-조각-채우기"><a href="#퍼즐-조각-채우기" class="headerlink" title="퍼즐 조각 채우기"></a>퍼즐 조각 채우기</h1><p>Python3<br><span id="more"></span></p><p><br/></p><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><blockquote><p>테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.</p><ul><li>조각은 한 번에 하나씩 채워 넣습니다.</li><li>조각을 회전시킬 수 있습니다.</li><li>조각을 뒤집을 수는 없습니다.</li><li>게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.</li></ul><p>다음은 퍼즐 조각을 채우는 예시입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ab4d8aa2-f282-4764-bb46-84d405464b90/puzzle_5.png" alt="puzzle_5.png"></p><p>위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다.</p><p>이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/70e371ad-4306-412b-b53b-25208e52a513/puzzle_6.png" alt="puzzle_6.png"></p><ul><li>3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.</li><li>5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.</li></ul><p>다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dadd0bc1-8e38-4689-a480-26afa799a5a3/puzzle_7.png" alt="puzzle_7.png"></p><p>최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다.</p><p>현재 게임 보드의 상태 <code>game_board</code>, 테이블 위에 놓인 퍼즐 조각의 상태 <code>table</code>이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요.</p><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>3 ≤ <code>game_board</code>의 행 길이 ≤ 50</li><li><code>game_board</code>의 각 열 길이 = <code>game_board</code>의 행 길이<ul><li>즉, 게임 보드는 정사각 격자 모양입니다.</li><li><code>game_board</code>의 모든 원소는 0 또는 1입니다.</li><li>0은 빈칸, 1은 이미 채워진 칸을 나타냅니다.</li><li>퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.</li></ul></li><li><code>table</code>의 행 길이 = <code>game_board</code>의 행 길이</li><li><code>table</code>의 각 열 길이 = <code>table</code>의 행 길이<ul><li>즉, 테이블은 <code>game_board</code>와 같은 크기의 정사각 격자 모양입니다.</li><li><code>table</code>의 모든 원소는 0 또는 1입니다.</li><li>0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다.</li><li>퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.</li></ul></li><li><code>game_board</code>에는 반드시 하나 이상의 빈칸이 있습니다.</li><li><code>table</code>에는 반드시 하나 이상의 블록이 놓여 있습니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>game_board</th><th>table</th><th>result</th></tr></thead><tbody><tr><td>[[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]]</td><td>[[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]]</td><td>14</td></tr><tr><td>[[0,0,0],[1,1,0],[1,1,1]]</td><td>[[1,1,1],[1,0,0],[0,0,0]]</td><td>0</td></tr></tbody></table></div><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>입력은 다음과 같은 형태이며, 문제의 예시와 같습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/653b44d8-0fa6-42f8-aa9d-ceca639b0ad4/puzzle_9.png" alt="puzzle_9.png"></p><p>입출력 예 #2</p><p>블록의 회전은 가능하지만, 뒤집을 수는 없습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">game_board, table</span>):</span></span><br><span class="line">    directions = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    N = <span class="built_in">len</span>(table)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 저장 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkingPuzzle</span>(<span class="params">pos,blocks,checkValue,board</span>):</span></span><br><span class="line">        x,y = pos</span><br><span class="line">        <span class="keyword">if</span> board[y][x] == checkValue:</span><br><span class="line">            blocks.append((x,y))</span><br><span class="line">            board[y][x] = <span class="number">0</span> <span class="keyword">if</span> checkValue == <span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="keyword">if</span> -<span class="number">1</span> &lt; x+d[<span class="number">0</span>] &lt; N <span class="keyword">and</span> -<span class="number">1</span> &lt; y+d[<span class="number">1</span>] &lt; N:</span><br><span class="line">                    checkingPuzzle((x+d[<span class="number">0</span>],y+d[<span class="number">1</span>]),blocks,checkValue,board)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 좌표 변환 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">syncBlocks</span>(<span class="params">blocks</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(blocks) == <span class="number">1</span>: <span class="keyword">return</span> [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        blocks = <span class="built_in">sorted</span>(blocks)        </span><br><span class="line">        sync_x, sync_y = blocks[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> [ (b[<span class="number">0</span>]-sync_x,b[<span class="number">1</span>]-sync_y) <span class="keyword">for</span> b <span class="keyword">in</span> blocks]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 회전 함수</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatingPuzzle</span>(<span class="params">blocks</span>):</span></span><br><span class="line">        result = [blocks,[],[],[]]</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> blocks:</span><br><span class="line">            x,y = b</span><br><span class="line">            result[<span class="number">1</span>].append((N-y,x))</span><br><span class="line">            result[<span class="number">2</span>].append((N-x,N-y))</span><br><span class="line">            result[<span class="number">3</span>].append((y,N-x))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 및 게임보드 빈 공간 저장</span></span><br><span class="line">    puzzles = []</span><br><span class="line">    blanks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N*N):</span><br><span class="line">        <span class="keyword">if</span> table[i//N][i%N] == <span class="number">1</span>: <span class="comment"># 테이블 위 퍼즐 저장</span></span><br><span class="line">            puzzles.append([])</span><br><span class="line">            checkingPuzzle( (i%N,i//N), puzzles[-<span class="number">1</span>], <span class="number">1</span>, table)</span><br><span class="line">        <span class="keyword">if</span> game_board[i//N][i%N] == <span class="number">0</span>: <span class="comment"># 게임보드 빈 공간 저장</span></span><br><span class="line">            blanks.append([])</span><br><span class="line">            checkingPuzzle( (i%N,i//N), blanks[-<span class="number">1</span>], <span class="number">0</span>, game_board)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 퍼즐 회전체 추가 및 좌표 변환</span></span><br><span class="line">    <span class="keyword">for</span> p_i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(puzzles):</span><br><span class="line">        puzzles[p_i] = []</span><br><span class="line">        <span class="keyword">for</span> r_i, r <span class="keyword">in</span> <span class="built_in">enumerate</span>(rotatingPuzzle(p)):</span><br><span class="line">            puzzles[p_i].append(syncBlocks(r))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 게임 보드 빈 공간 좌표 변환</span></span><br><span class="line">    <span class="keyword">for</span> b_i,b <span class="keyword">in</span> <span class="built_in">enumerate</span>(blanks):</span><br><span class="line">        blanks[b_i] = syncBlocks(b)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 두 값 비교</span></span><br><span class="line">    <span class="keyword">for</span> p_i,p <span class="keyword">in</span> <span class="built_in">enumerate</span>( (puzzles) ):</span><br><span class="line">        <span class="keyword">for</span> rotate <span class="keyword">in</span> p:</span><br><span class="line">            <span class="keyword">if</span> rotate <span class="keyword">in</span> blanks:</span><br><span class="line">                answer += <span class="built_in">len</span>(rotate)</span><br><span class="line">                blanks.remove(rotate)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/">lv3</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/18/8c559b93b60c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 상호 평가</title>
      <link>https://sklubmk.github.io/2021/08/16/5a27c5948dfc/</link>
      <guid>https://sklubmk.github.io/2021/08/16/5a27c5948dfc/</guid>
      <pubDate>Sun, 15 Aug 2021 16:19:45 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;상호-평가&quot;&gt;&lt;a href=&quot;#상호-평가&quot; class=&quot;headerlink&quot; title=&quot;상호 평가&quot;&gt;&lt;/a&gt;상호 평가&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="상호-평가"><a href="#상호-평가" class="headerlink" title="상호 평가"></a>상호 평가</h1><p>Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td><del>100</del></td><td>90</td><td>98</td><td>88</td><td>65</td></tr><tr><td>1</td><td>50</td><td><del>45</del></td><td>99</td><td>85</td><td>77</td></tr><tr><td>2</td><td>47</td><td>88</td><td>95</td><td>80</td><td>67</td></tr><tr><td>3</td><td>61</td><td>57</td><td>100</td><td>80</td><td>65</td></tr><tr><td>4</td><td>24</td><td>90</td><td>94</td><td>75</td><td>65</td></tr><tr><td>평균</td><td>45.5</td><td>81.25</td><td>97.2</td><td>81.6</td><td>67.8</td></tr><tr><td>학점</td><td>F</td><td>B</td><td>A</td><td>B</td><td>D</td></tr></tbody></table></div><p>위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.</p><ul><li>0번 학생이 평가한 점수는 0번 <code>행</code>에담긴 [100, 90, 98, 88, 65]입니다.<ul><li>0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.</li></ul></li><li>2번 학생이 평가한 점수는 2번 <code>행</code>에담긴 [47, 88, 95, 80, 67]입니다.<ul><li>2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.</li></ul></li></ul><p>당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.\<br>만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.</p><ul><li>0번 학생이 받은 점수는 0번 <code>열</code>에 담긴 [<code>100</code>, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.<ul><li>0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.</li></ul></li><li>4번 학생이 받은 점수는 4번 <code>열</code>에 담긴 [65, 77, 67, 65, <code>65</code>]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.<ul><li>4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.</li></ul></li></ul><p>제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.</p><div class="table-container"><table><thead><tr><th>평균</th><th>학점</th></tr></thead><tbody><tr><td>90점 이상</td><td>A</td></tr><tr><td>80점 이상 90점 미만</td><td>B</td></tr><tr><td>70점 이상 80점 미만</td><td>C</td></tr><tr><td>50점 이상 70점 미만</td><td>D</td></tr><tr><td>50점 미만</td><td>F</td></tr></tbody></table></div><p>학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.</p><hr><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>2 ≤ <code>scores</code>의 행의 길이(학생 수) ≤ 10</li><li><p><code>scores</code>의 열의 길이 = <code>scores</code>의 행의 길이</p><ul><li>즉, <code>scores</code>는 행과 열의 길이가 같은 2차원 배열입니다.</li></ul></li><li><p>0 ≤ <code>scores</code>의 원소 ≤ 100</p></li><li>return 값 형식<ul><li>0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.</li></ul></li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>scores</th><th>result</th></tr></thead><tbody><tr><td>[[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]</td><td><code>&quot;FBABD&quot;</code></td></tr><tr><td>[[50,90],[50,87]]</td><td><code>&quot;DA&quot;</code></td></tr><tr><td>[[70,49,90],[68,50,38],[73,31,100]]</td><td><code>&quot;CFD&quot;</code></td></tr></tbody></table></div><hr><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1</p><p>문제 예시와 같습니다.</p><p>입출력 예 #2</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td></tr><tr><td>0</td><td>50</td><td>90</td></tr><tr><td>1</td><td>50</td><td><del>87</del></td></tr><tr><td>평균</td><td>50</td><td>90</td></tr><tr><td>학점</td><td>D</td><td>A</td></tr></tbody></table></div><ul><li>1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.</li></ul><p>입출력 예 #3</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td></tr><tr><td>0</td><td>70</td><td>49</td><td>90</td></tr><tr><td>1</td><td>68</td><td><del>50</del></td><td>38</td></tr><tr><td>2</td><td>73</td><td>31</td><td><del>100</del></td></tr><tr><td>평균</td><td>70.33…</td><td>40</td><td>64</td></tr><tr><td>학점</td><td>C</td><td>F</td><td>D</td></tr></tbody></table></div><ul><li>1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.</li><li>2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">scores</span>):</span></span><br><span class="line">    scores = [[score[r] <span class="keyword">for</span> score <span class="keyword">in</span> scores] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores))]</span><br><span class="line">    grade = [(<span class="number">90</span>,<span class="string">&#x27;A&#x27;</span>),(<span class="number">80</span>,<span class="string">&#x27;B&#x27;</span>),(<span class="number">70</span>,<span class="string">&#x27;C&#x27;</span>),(<span class="number">50</span>,<span class="string">&#x27;D&#x27;</span>),(<span class="number">0</span>,<span class="string">&#x27;F&#x27;</span>)]</span><br><span class="line">    grading = <span class="keyword">lambda</span> x: <span class="built_in">next</span>(v[<span class="number">1</span>] <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(grade) <span class="keyword">if</span> x &gt;= v[<span class="number">0</span>])</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> idx, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(scores):</span><br><span class="line">        without_self = [s <span class="keyword">for</span> i,s <span class="keyword">in</span> <span class="built_in">enumerate</span>(score) <span class="keyword">if</span> i != idx]</span><br><span class="line">        <span class="keyword">if</span> score[idx] &gt; <span class="built_in">max</span>(without_self) <span class="keyword">or</span> score[idx] &lt; <span class="built_in">min</span>(without_self):</span><br><span class="line">            answer += grading(<span class="built_in">sum</span>(without_self) / <span class="built_in">len</span>(without_self))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer += grading(<span class="built_in">sum</span>(score) / <span class="built_in">len</span>(score))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><br/></p><h2 id="풀이-과정"><a href="#풀이-과정" class="headerlink" title="풀이 과정"></a>풀이 과정</h2><ol><li>행열 전환</li><li>성적 산출 함수 구현</li><li>결과 도출</li></ol><p><br/></p><h2 id="풀이-설명"><a href="#풀이-설명" class="headerlink" title="풀이 설명"></a>풀이 설명</h2><h3 id="행열-전환하기-행-lt-gt-열"><a href="#행열-전환하기-행-lt-gt-열" class="headerlink" title="[ 행열 전환하기 (행 &lt;-&gt; 열) ]"></a><code>[ 행열 전환하기 (행 &lt;-&gt; 열) ]</code></h3><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores = [[score[r] <span class="keyword">for</span> score <span class="keyword">in</span> scores] <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores))]</span><br></pre></td></tr></table></figure></div><p><br/></p><h3 id="성적-산출"><a href="#성적-산출" class="headerlink" title="[ 성적 산출 ]"></a><code>[ 성적 산출 ]</code></h3><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grade = [(<span class="number">90</span>,<span class="string">&#x27;A&#x27;</span>),(<span class="number">80</span>,<span class="string">&#x27;B&#x27;</span>),(<span class="number">70</span>,<span class="string">&#x27;C&#x27;</span>),(<span class="number">50</span>,<span class="string">&#x27;D&#x27;</span>),(<span class="number">0</span>,<span class="string">&#x27;F&#x27;</span>)]</span><br><span class="line">grading = <span class="keyword">lambda</span> x: <span class="built_in">next</span>(v[<span class="number">1</span>] <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(grade) <span class="keyword">if</span> x &gt;= v[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li><code>python</code>의 <code>tuple</code>을 이용해 성적 산출을 리스트로 구현했다.</li></ul><p><br/></p><h3 id="결과-도출"><a href="#결과-도출" class="headerlink" title="[ 결과 도출 ]"></a><code>[ 결과 도출 ]</code></h3><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> idx, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(scores):</span><br><span class="line">    without_self = [s <span class="keyword">for</span> i,s <span class="keyword">in</span> <span class="built_in">enumerate</span>(score) <span class="keyword">if</span> i != idx]</span><br><span class="line">    <span class="keyword">if</span> score[idx] &gt; <span class="built_in">max</span>(without_self) <span class="keyword">or</span> score[idx] &lt; <span class="built_in">min</span>(without_self):</span><br><span class="line">        answer += grading(<span class="built_in">sum</span>(without_self) / <span class="built_in">len</span>(without_self))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer += grading(<span class="built_in">sum</span>(score) / <span class="built_in">len</span>(score))</span><br></pre></td></tr></table></figure></div><p><br/></p><ul><li>자신의 점수를 제외한 <code>without_self</code> 리스트를 만든다.</li><li>현재 값이 <code>without_self</code>의 <strong>최대값</strong>보다 크거나 <strong>최소값</strong>보다 작으면 제외한다.<ul><li>자신의 점수가 제외된 <code>without_self</code>로 평균 점수와 성적을 산출한다.</li></ul></li><li>그게 아니면 전체 값으로 성적을 산출한다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/16/5a27c5948dfc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 부족한 금액 계산하기</title>
      <link>https://sklubmk.github.io/2021/08/16/ce5d6cfa269c/</link>
      <guid>https://sklubmk.github.io/2021/08/16/ce5d6cfa269c/</guid>
      <pubDate>Sun, 15 Aug 2021 16:19:17 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;부족한-금액-계산하기&quot;&gt;&lt;a href=&quot;#부족한-금액-계산하기&quot; class=&quot;headerlink&quot; title=&quot;부족한 금액 계산하기&quot;&gt;&lt;/a&gt;부족한 금액 계산하기&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="부족한-금액-계산하기"><a href="#부족한-금액-계산하기" class="headerlink" title="부족한 금액 계산하기"></a>부족한 금액 계산하기</h1><p>Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><p>새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\<br>놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.\<br>단, 금액이 부족하지 않으면 0을 return 하세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수</li><li>처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수</li><li>놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>price</th><th>money</th><th>count</th><th>result</th></tr></thead><tbody><tr><td>3</td><td>20</td><td>4</td><td>10</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>입출력 예 #1\<br>이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">price, money, count</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, (price * count * (count+<span class="number">1</span>) / <span class="number">2</span>) - money )</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/">lv1</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/">위클리챌린지</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/16/ce5d6cfa269c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 뉴스 클러스터링</title>
      <link>https://sklubmk.github.io/2021/08/13/dec5e25d4d7a/</link>
      <guid>https://sklubmk.github.io/2021/08/13/dec5e25d4d7a/</guid>
      <pubDate>Fri, 13 Aug 2021 08:37:51 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;1차-뉴스-클러스터링&quot;&gt;&lt;a href=&quot;#1차-뉴스-클러스터링&quot; class=&quot;headerlink&quot; title=&quot;[1차] 뉴스 클러스터링&quot;&gt;&lt;/a&gt;[1차] 뉴스 클러스터링&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="1차-뉴스-클러스터링"><a href="#1차-뉴스-클러스터링" class="headerlink" title="[1차] 뉴스 클러스터링"></a>[1차] 뉴스 클러스터링</h1><p>Python3</p><span id="more"></span><p><br/></p><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><hr><blockquote><h2 id="뉴스-클러스터링"><a href="#뉴스-클러스터링" class="headerlink" title="뉴스 클러스터링"></a>뉴스 클러스터링</h2><p>여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.</p><p>개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 “카카오 신입 개발자 공채” 관련 기사를 검색해보았다.</p><ul><li>카카오 첫 공채..’블라인드’ 방식 채용</li><li>카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용</li><li>카카오, 블라인드 전형으로 신입 개발자 공채</li><li>카카오 공채, 신입 개발자 코딩 능력만 본다</li><li>카카오, 신입 공채.. “코딩 실력만 본다”</li><li>카카오 “코딩 능력만으로 2018 신입 개발자 뽑는다”</li></ul><p>기사의 제목을 기준으로 “블라인드 전형”에 주목하는 기사와 “코딩 테스트”에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.</p><p>유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 “자카드 유사도”라는 방법을 찾아냈다.</p><p>자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 <code>A</code>, <code>B</code> 사이의 자카드 유사도 <code>J(A, B)</code>는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.</p><p>예를 들어 집합 <code>A</code> = {1, 2, 3}, 집합 <code>B</code> = {2, 3, 4}라고 할 때, 교집합 <code>A ∩ B</code> = {2, 3}, 합집합 <code>A ∪ B</code> = {1, 2, 3, 4}이 되므로, 집합 <code>A</code>, <code>B</code> 사이의 자카드 유사도 <code>J(A, B)</code> = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 <code>J(A, B)</code> = 1로 정의한다.</p><p>자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 <code>A</code>는 원소 “1”을 3개 가지고 있고, 다중집합 <code>B</code>는 원소 “1”을 5개 가지고 있다고 하자. 이 다중집합의 교집합 <code>A ∩ B</code>는 원소 “1”을 min(3, 5)인 3개, 합집합 <code>A ∪ B</code>는 원소 “1”을 max(3, 5)인 5개 가지게 된다. 다중집합 <code>A</code> = {1, 1, 2, 2, 3}, 다중집합 <code>B</code> = {1, 2, 2, 4, 5}라고 하면, 교집합 <code>A ∩ B</code> = {1, 2, 2}, 합집합 <code>A ∪ B</code> = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 <code>J(A, B)</code> = 3/7, 약 0.42가 된다.</p><p>이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 “FRANCE”와 “FRENCH”가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 <code>J(&quot;FRANCE&quot;, &quot;FRENCH&quot;)</code> = 2/8 = 0.25가 된다.</p><h2 id="입력-형식"><a href="#입력-형식" class="headerlink" title="입력 형식"></a>입력 형식</h2><ul><li>입력으로는 <code>str1</code>과 <code>str2</code>의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.</li><li>입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 “ab+”가 입력으로 들어오면, “ab”만 다중집합의 원소로 삼고, “b+”는 버린다.</li><li>다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. “AB”와 “Ab”, “ab”는 같은 원소로 취급한다.</li></ul><h2 id="출력-형식"><a href="#출력-형식" class="headerlink" title="출력 형식"></a>출력 형식</h2><p>입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.</p><h2 id="예제-입출력"><a href="#예제-입출력" class="headerlink" title="예제 입출력"></a>예제 입출력</h2><div class="table-container"><table><thead><tr><th>str1</th><th>str2</th><th>answer</th></tr></thead><tbody><tr><td>FRANCE</td><td>french</td><td>16384</td></tr><tr><td>handshake</td><td>shake hands</td><td>65536</td></tr><tr><td>aa1+aa2</td><td>AAAA12</td><td>43690</td></tr><tr><td>E=M*C^2</td><td>e=m*c^2</td><td>65536</td></tr></tbody></table></div><p><a href="http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/">해설 보러가기</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">str1, str2</span>):</span></span><br><span class="line">    split = <span class="keyword">lambda</span> x:[x[i:i+<span class="number">2</span>].lower() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)-<span class="number">1</span>) <span class="keyword">if</span> x[i:i+<span class="number">2</span>].isalpha()]</span><br><span class="line">    summary = <span class="keyword">lambda</span> arr: &#123;i:arr.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> arr&#125;</span><br><span class="line">    a_sum, b_sum = summary(split(str1)), summary(split(str2))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a_sum) + <span class="built_in">len</span>(b_sum) == <span class="number">0</span> : <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line">    </span><br><span class="line">    intersection = <span class="built_in">sum</span>([<span class="built_in">min</span>(a_sum[a],b_sum[a]) <span class="keyword">for</span> a <span class="keyword">in</span> a_sum <span class="keyword">if</span> a <span class="keyword">in</span> b_sum]);</span><br><span class="line">    union = <span class="built_in">sum</span>(a_sum.values()) + <span class="built_in">sum</span>(b_sum.values()) - intersection;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(intersection/union * <span class="number">65536</span>);</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><h2 id="풀이-전략"><a href="#풀이-전략" class="headerlink" title="풀이 전략"></a>풀이 전략</h2><p><br/></p><p>문제의 조건을 구현할 수 있는 피지컬을 요하는 <code>구현</code> 문제다.</p><p>문제는 크게 2가지 과정으로 풀이 된다.</p><ol><li>주어진 두 배열을 각각 2글자로 이루어진 원소의 집합으로 만들기</li><li>두 집합으로 교집합과 합집합 계산 및 결과 반환하기</li></ol><p><br/></p><h2 id="2글자-집합-만들기"><a href="#2글자-집합-만들기" class="headerlink" title="2글자 집합 만들기"></a>2글자 집합 만들기</h2><p><br/></p><p>문제의 조건대로 2글자씩 배열을 나눈 뒤, 이를 <code>알파벳</code>인지 검사한다. 이 때 python 내장함수 <code>isalpha()</code>를 사용한다. 만약 알파벳이 맞다면 <code>lower()</code> 함수를 이용해 소문자 단어로 변환하여 배열에 저장한다. 결과적으로 소문자 2개로 이루어진 원소들을 가지는 집합이 된다.</p><p>예시 : [<code>fr</code>, <code>ra</code>, <code>an</code>, <code>nc</code>, <code>ce</code>, <code>fr</code>, <code>re</code>, <code>en</code>, <code>nc</code>, <code>ch</code>]</p><p><br/></p><p>여기서 각 단어 개수를 카운팅하여 <code>dictionary</code>로 저장한다. 이때 <code>count</code> 함수를 활용한다.</p><p>예시 : {<code>fr</code>:<code>2</code>, <code>nc</code>:<code>2</code>, <code>ra</code>:<code>1</code>,<code>an</code>:<code>1</code> , …}</p><p><br/></p><h2 id="교집합-intersection"><a href="#교집합-intersection" class="headerlink" title="교집합 (intersection)"></a>교집합 (intersection)</h2><p><br/></p><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intersection = <span class="built_in">sum</span>([<span class="built_in">min</span>(a_sum[a],b_sum[a]) <span class="keyword">for</span> a <span class="keyword">in</span> a_sum <span class="keyword">if</span> a <span class="keyword">in</span> b_sum])</span><br></pre></td></tr></table></figure></div><p>두 집합에 동시에 속한 단어가 있다면 해당 단어 <code>counting</code>의 최소 값을 모아 합산 한다.</p><p><br/></p><h2 id="합집합-union"><a href="#합집합-union" class="headerlink" title="합집합 (union)"></a>합집합 (union)</h2><p><br/></p><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union = <span class="built_in">sum</span>(a_sum.values()) + <span class="built_in">sum</span>(b_sum.values()) - intersection</span><br></pre></td></tr></table></figure></div><p>합집합은 두 집합의 전체 값 - 교집합으로 계산할 수 있다. 따라서 각 집합 결과의 <code>sum</code>을 더해 앞서 계산한 교집합 값을 빼면 된다.</p><p>이후, 교집합 값과 합집합 값을 문제 조건대로 계산하여 반환하면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B5%AC%ED%98%84/">구현</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/13/dec5e25d4d7a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[알고리즘] 정렬 알고리즘</title>
      <link>https://sklubmk.github.io/2021/08/13/54aee196b995/</link>
      <guid>https://sklubmk.github.io/2021/08/13/54aee196b995/</guid>
      <pubDate>Thu, 12 Aug 2021 15:34:18 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;버블 정렬 (&lt;code&gt;Bubble Sort&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;선택 정렬 (&lt;code&gt;Selection Sort&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;삽입 정렬 (&lt;code&gt;Insertion Sort&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;그외 정렬 알고리즘들&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>버블 정렬 (<code>Bubble Sort</code>)</li><li>선택 정렬 (<code>Selection Sort</code>)</li><li>삽입 정렬 (<code>Insertion Sort</code>)</li><li>그외 정렬 알고리즘들</li></ul><span id="more"></span><p><br/></p><h1 id="버블정렬-Bubble-Sort"><a href="#버블정렬-Bubble-Sort" class="headerlink" title="버블정렬 (Bubble Sort)"></a>버블정렬 (Bubble Sort)</h1><hr><h2 id="동작원리"><a href="#동작원리" class="headerlink" title="동작원리"></a>동작원리</h2><ul><li>배열의 <code>0</code>번부터 <code>N-1</code>번까지 탐색을 하면서 인접한 칸과 비교하여 <code>swap</code> 하는 방식</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="https://t1.daumcdn.net/cfile/tistory/9999CE475CC465A407" /></p><p><img style="margin: 1rem auto; width:80%; display: block;" src="https://t1.daumcdn.net/cfile/tistory/99587F465CC465D501" /></p><p><br/></p><ul><li>Bubble 정렬을 오름차순으로 1회 실시하고 나서의 결과</li><li><code>j</code>번째 값과 <code>j+1</code>번째 값을 비교해서 만약 <code>j</code>번째의 값이 더 크다면 <code>swap</code> 해주는 식으로 동작</li><li>위의 과정을 첫번째는 <code>0</code> ~ <code>N-1</code>번까지, 두 번째는 <code>0</code> ~ <code>N-2</code>번까지, 세 번째는 <code>0</code> ~ <code>N-3</code>번까지 … 식으로 진행되는데 이유는 위의 과정을 보면 알겠지만, 1회 실시하고 나게 되면 최댓값이 가장 마지막으로 가게 된다는 것을 알 수 있다.</li><li>즉, 2번째 과정에서는 이미 최댓값 위치에 저장되어있는 가장 마지막 값을 건드릴 필요가 없다.</li></ul><p><br/></p><h2 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a><strong>시간복잡도</strong></h2><ul><li>처음에는 <code>N-1</code>번탐색, 두 번째는 <code>N-2</code>번 탐색, … 이런식으로 진행되므로<br>총 <code>N-1</code> + <code>N-2</code> + <code>N-3</code> + <code>N-4</code> + <code>...</code> + <code>1</code> 번 진행 = <script type="math/tex">\cfrac{N(N-1)}2</script></li><li><p>식의 유도</p><ul><li>1, 2, 3, 4, 5 가 존재할 때, 1회 탐색할때 총 1부터 5까지 4번 탐색을 하게된다.</li><li>2회 탐색할 때에는 1부터 4까지 3번탐색, 3회는 2번, 4회는 1번 … 총 4 + 3 + 2 + 1 = 10회 탐색을 하게된다.</li><li>이 10을 식을 이용해서 도출해 내면 (5 x 4) / 2로 표현할 수 있게 된다. 따라서 위의 식 만큼의 탐색을 하게 된다.</li><li>따라서  <script type="math/tex">\cfrac12N^2 - \cfrac12N</script> 이라는 시간복잡도를 갖게 되고, <script type="math/tex">O(N^2)</script> 으로 표기할 수 있다.</li></ul></li><li><p><strong>worst case</strong></p><ul><li>역방향으로 정렬이 되어 있는 경우</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li><strong>best case</strong><ul><li>이미 정렬이 되어 있는 경우</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li>즉, Bubble정렬의 경우 최악이든 최선이든 똑같이 <strong><script type="math/tex">O(N^2)</script></strong>만큼의 시간복잡도를 갖게 된다.</li></ul><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%209.png" /></p><p><br/></p><p><br/></p><h1 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬 (Selection Sort)"></a>선택 정렬 (Selection Sort)</h1><hr><h2 id="동작-원리"><a href="#동작-원리" class="headerlink" title="동작 원리"></a>동작 원리</h2><ul><li>가장 먼저 제일 앞에 값을 ‘최소값을 가진 Index’ 라고 가정을 하고 탐색 시작.</li><li>탐색 진행 중, 만약 ‘최소값을 가진 Index’보다 더 작은 값을 가진 값이 나오면, ‘최소값을 가진 Index’를 더 작은 값을가진 Index번호로 변경. 이 과정을 <code>N-1</code>번까지 진행.</li><li>이후에, 제일 앞 Index 번호와, 최소값을 가진 Index번호가 다르다면 <code>swap</code> 해주면 되는 방식</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%2010.png" /></p><ul><li>위 그림은 1회전 시켰을 때의 결과값이다.</li><li>그렇다면 2회전 시킬 때 시작점을 어디로 잡으면될까?<ul><li>1번으로 시작하면 된다.</li><li>왜냐하면 0번에는 이미 최소값이 자기 자리를 찾아서 정렬되어 있기 때문에 더 이상 관리할 필요가 없기 때문이다.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 선택정렬 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 0부터 끝까지 전체탐색</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MAX; i++)&#123;</span><br><span class="line">    <span class="comment">// 가장 작은 값이 저장된 Index를 탐색을 시작하는 Index로 가정하고 탐색시작.</span></span><br><span class="line">    <span class="keyword">int</span> Min_Index = i;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// i + 1번부터 끝까지 탐색을 하는데</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i  + <span class="number">1</span>; i j &lt; MAX; j++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 만약 더 작은 값이 나오면 Min_Index값 변경</span></span><br><span class="line">        <span class="keyword">if</span>(Arr[j] &lt; Arr[Min_Index]) Min_Index = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 변화가 있었다면 swap.</span></span><br><span class="line">    <span class="keyword">if</span>(i != Min_Index) <span class="built_in">swap</span>(Arr[i], Arr[Min_Index]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br/></p><h2 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ul><li>선택정렬의 경우, 가장 처음에 총 <code>N-1</code>번의 탐색을 하게 된다.</li><li>2회전 때는 정렬된 가장 첫번째 값(최소값)을 빼고 <code>N-2</code>번 탐색을 하게된다.</li><li>즉, 끝까지 탐색을 하게되면 결과적으로 <code>N-1</code> + <code>N-2</code> + <code>N-3</code> + <code>...</code> + <code>1</code> 번 탐색.</li><li>이를 수식으로 나타내면  <script type="math/tex">\cfrac12N^2 - \cfrac12N</script> 번 탐색을 하게되고, <script type="math/tex">O(N^2)</script>이 된다.</li><li><strong>worst case</strong><ul><li>역방향으로 정렬되어 있는 경우</li><li><code>N-1</code> + <code>N-2</code> + <code>N-3</code> + <code>...</code> + <code>1</code>번 탐색</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li><strong>best case</strong><ul><li>이미 정렬이 되어 있는 경우</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li></ul><p><br/></p><p><br/></p><h1 id="삽입-정렬-Insertion-Sort"><a href="#삽입-정렬-Insertion-Sort" class="headerlink" title="삽입 정렬 (Insertion Sort)"></a>삽입 정렬 (Insertion Sort)</h1><hr><h2 id="동작-원리-1"><a href="#동작-원리-1" class="headerlink" title="동작 원리"></a>동작 원리</h2><ul><li>삽입정렬은 앞으로 가면서 탐색을 진행한다.</li><li><code>N</code>만큼의 크기의 배열을 선언하고 <code>0</code>부터 <code>N-1</code> 번까지의 배열을 사용할때, Index 1번부터 탐색을 진행한다.</li><li>왜냐하면 앞으로 가면서 탐색을 하는 방식이기 때문에 0번 Index는 의미가 없기 때문</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%2011.png" /></p><ul><li>앞부분에 대해서만 정렬하는 과정</li><li>시작 Index를 기점으로 앞으로 쭉 탐색을 진행하는데, 2가지 조건이 있다.<ol><li>Index가 0보다 크거나 같을때<ul><li>0보다 작은 Index는 존재하지 않기 때문에 아무리 탐색을 많이 하더라도 0보다 크거나 같을 때 까지만 탐색이 가능하다.</li></ul></li><li>비교하는 값이 더 클때<ul><li>앞의 값이 더 크다면 <strong>특정한 과정</strong>을 진행한 후 탐색을 계속하지만, 값이 더 작으면 앞쪽 배열은 이미 정렬이 완료된 상태 그대로 탐색을 종료한다.</li></ul></li></ol></li><li>특별한 과정<ul><li>현재 값을 Temp 에 저장하고, 비교 값(Temp보다 작은 값)을 현재 index에 복사.</li><li>만약 비교값이 같거나 크다면 해당 비교 index에 Temp값 삽입</li><li>비교값의 index가 0보다 작아지기 전까지 위 과정 반복</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 1번 Index부터 마지막 Index까지 탐색. 0번 Index는 탐색 X</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> Cur_Index = <span class="number">1</span>; Cur_Index &lt; MAX; Cur_Index++)&#123;</span><br><span class="line">    <span class="comment">// 현재의 값을 Temp라는 임시 저장 변수에 저장.</span></span><br><span class="line">    <span class="keyword">int</span> Temp = Arr[Cur_Index];</span><br><span class="line">    <span class="comment">// Index를 관리하는 변수. 현재 Index - 1번부터 탐색 시작.</span></span><br><span class="line">    <span class="keyword">int</span> Before_Index = Cur_Index <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Index번호가 0보다 크거나 같고, 이전 값이 더 큰 경우만</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( Before_Index &gt;= <span class="number">0</span> &amp;&amp; Arr[Before_Index] &gt; Temp &#123;</span><br><span class="line">      <span class="comment">// 값을 그대로 복사해서 넣어주고</span></span><br><span class="line">      Arr[Before_Index + <span class="number">1</span>] = Arr[Befored_Index];</span><br><span class="line">      <span class="comment">// 탐색 계속해서 진행</span></span><br><span class="line">      Before_Index = Before_Index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 탐색이 종료되면, 올바른 배열을 만들어 주기 위해서 값 삽입.</span></span><br><span class="line">    Arr[Before_Index + <span class="number">1</span>] = Temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="시간-복잡도-1"><a href="#시간-복잡도-1" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h2><ul><li>삽입정렬은 최악의 경우와 최선의 경우 시간의 차이가 많이 정렬법이다.</li><li><strong>worst case</strong><ul><li>역정렬 되어있는 경우</li><li><script type="math/tex">\cfrac{N(N-1)}2</script> 번 시행</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li><li><strong>best case</strong><ul><li>이미 정렬이 되어있는 경우</li><li>모든 현재값이 비교값보다 같거나 크므로 1번씩 x N 번 시행</li><li><strong><script type="math/tex">O(N^2)</script></strong></li></ul></li></ul><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%2012.png" /></p><p><br/></p><p><br/></p><h1 id="다른-정렬-알고리즘"><a href="#다른-정렬-알고리즘" class="headerlink" title="다른 정렬 알고리즘"></a>다른 정렬 알고리즘</h1><hr><h2 id="퀵소트-quick-sort-알고리즘"><a href="#퀵소트-quick-sort-알고리즘" class="headerlink" title="퀵소트(quick sort) 알고리즘"></a>퀵소트(quick sort) 알고리즘</h2><ul><li>최악의 경우 <script type="math/tex">O(N^2)</script>, 하지만 평균 시간복잡도는 <strong><script type="math/tex">O(Nlog_2{N})</script></strong></li></ul><p><br/></p><h2 id="합병정렬-merge-sort"><a href="#합병정렬-merge-sort" class="headerlink" title="합병정렬(merge sort)"></a>합병정렬(merge sort)</h2><p>최악의 경우 <strong><script type="math/tex">O(Nlog_2{N})</script></strong></p><p><br/></p><h2 id="힙-정렬-heap-sort"><a href="#힙-정렬-heap-sort" class="headerlink" title="힙 정렬(heap sort)"></a>힙 정렬(heap sort)</h2><p>최악의 경우 <strong><script type="math/tex">O(Nlog_2{N})</script></strong></p><p><br/></p><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><p><a href="https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C/da">영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠) - 인프런</a></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B0%9C%EB%85%90/">개념</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B0%9C%EB%85%90/">개념</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/13/54aee196b995/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[알고리즘] 시간복잡도와 점근적 표기법</title>
      <link>https://sklubmk.github.io/2021/08/12/ddfce68ef73c/</link>
      <guid>https://sklubmk.github.io/2021/08/12/ddfce68ef73c/</guid>
      <pubDate>Wed, 11 Aug 2021 15:31:02 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;시간복잡도&lt;/li&gt;
&lt;li&gt;점근적 표기법&lt;/li&gt;
&lt;li&gt;복잡도 비교&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>시간복잡도</li><li>점근적 표기법</li><li>복잡도 비교</li></ul><span id="more"></span><p><br/></p><p><br/></p><h1 id="시간복잡도"><a href="#시간복잡도" class="headerlink" title="시간복잡도"></a>시간복잡도</h1><hr><ul><li>실행시간의 분석 : 실행시간은 실행환경에 따라 달라짐<ul><li>하드웨어, 운영체제, 언어, 컴파일러 등</li></ul></li><li>실행 시간을 측정하는 대신 연산의 실행 횟수를 카운트</li><li>연산의 실행 횟수는 입력 데이터의 크기에 관한 함수로 표현</li><li>데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐<ul><li>최악의 경우 시간복잡도 (<code>worst-case analysis</code>)</li><li>평균 시간복잡도 (<code>average-case analysis</code>)</li></ul></li></ul><p><br/></p><p><br/></p><h1 id="점근적-표기법"><a href="#점근적-표기법" class="headerlink" title="점근적 표기법"></a>점근적 표기법</h1><hr><ul><li>점근적 표기법을 사용<ul><li>데이터의 개수 n→∞일때 수행시간이 증가하는 <code>growth rate</code>로 시간복잡도를 표현<br>하는 기법</li><li><code>Θ</code>-표기, <code>Ο</code>-표기 등을 사용</li></ul></li><li>유일한 분석법도 아니고 가장 좋은 분석법도 아님<ul><li>다만(상대적으로) 가장 간단하며</li><li>알고리즘의 실행환경에 비의존적임</li><li>그래서 가장 광범위하게 사용됨</li></ul></li><li>알고리즘에 포함된 연산들의 실행 횟수를 표기하는 하나의 기법</li><li>최고차항의 차수만으로 표시</li><li>따라서 가장 자주 실행되는 연산 혹은 문장의 실행횟수를 고려하는 것으로 충분</li></ul><p><br/></p><h2 id="점근표기법-Ο-표기"><a href="#점근표기법-Ο-표기" class="headerlink" title="점근표기법: Ο-표기"></a>점근표기법: Ο-표기</h2><hr><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled.png" /></p><p><br/></p><h2 id="점근표기법-Ω-표기"><a href="#점근표기법-Ω-표기" class="headerlink" title="점근표기법: Ω-표기"></a>점근표기법: Ω-표기</h2><hr><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%201.png" /></p><p><br/></p><h2 id="점근표기법-Θ-표기"><a href="#점근표기법-Θ-표기" class="headerlink" title="점근표기법:Θ-표기"></a>점근표기법:Θ-표기</h2><hr><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%202.png" /></p><ul><li>f(n) ∈ O(g(n))을 f(n) = O(g(n))으로 쓰는 경우가 많음</li><li>차수가 k≥0인 모든 다항식은 O(nᵏ)이다.</li></ul><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%203.png" /></p><p><br/></p><h2 id="차수가-p인-다항식과-q인-다항식의-합"><a href="#차수가-p인-다항식과-q인-다항식의-합" class="headerlink" title="차수가 p인 다항식과 q인 다항식의 합"></a>차수가 p인 다항식과 q인 다항식의 합</h2><hr><p><img style="margin: 1rem auto; min-width: 150px; width:20%; display: block;" src="/img/post_images/algorithm/base/Untitled%204.png" /></p><p><img style="margin: 1rem auto; width:70%; display: block;" src="/img/post_images/algorithm/base/Untitled%205.png" /></p><p><br/></p><p><br/></p><h1 id="복잡도-비교"><a href="#복잡도-비교" class="headerlink" title="복잡도 비교"></a>복잡도 비교</h1><hr><ul><li>알고리즘은 실행 시간이 다항식 인 경우 효율적</li></ul><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%206.png" /></p><p><img style="margin: 1rem auto; width:80%; display: block;" src="/img/post_images/algorithm/base/Untitled%207.png" /></p><p><br/></p><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><p><a href="https://www.inflearn.com/course/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%95%EC%A2%8C/da">영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠) - 인프런</a></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B0%9C%EB%85%90/">개념</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B0%9C%EB%85%90/">개념</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/">시간복잡도</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/12/ddfce68ef73c/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 피보나치 수</title>
      <link>https://sklubmk.github.io/2021/08/12/b5f9f208b449/</link>
      <guid>https://sklubmk.github.io/2021/08/12/b5f9f208b449/</guid>
      <pubDate>Wed, 11 Aug 2021 15:24:24 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;피보나치-수&quot;&gt;&lt;a href=&quot;#피보나치-수&quot; class=&quot;headerlink&quot; title=&quot;피보나치 수&quot;&gt;&lt;/a&gt;피보나치 수&lt;/h1&gt;&lt;p&gt;JavaScript&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="피보나치-수"><a href="#피보나치-수" class="headerlink" title="피보나치 수"></a>피보나치 수</h1><p>JavaScript</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.</p><p>예를들어</p><ul><li>F(2) = F(0) + F(1) = 0 + 1 = 1</li><li>F(3) = F(1) + F(2) = 1 + 1 = 2</li><li>F(4) = F(2) + F(3) = 1 + 2 = 3</li><li>F(5) = F(3) + F(4) = 2 + 3 = 5</li></ul><p>와 같이 이어집니다.</p><p>2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.</p><h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><ul><li>n은 1이상, 100000이하인 자연수입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>n</th><th>return</th></tr></thead><tbody><tr><td>3</td><td>2</td></tr><tr><td>5</td><td>5</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, … 와 같이 이어집니다.</p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> answer = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        answer.push( (answer[i-<span class="number">1</span>] + answer[i-<span class="number">2</span>]) % <span class="number">1234567</span> )</span><br><span class="line">    <span class="keyword">return</span> answer[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n</span>):</span></span><br><span class="line">    pbnc_list = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        pbnc_list.append( (pbnc_list[i-<span class="number">2</span>] + pbnc_list[i-<span class="number">1</span>]) % <span class="number">1234567</span> )</span><br><span class="line">    <span class="keyword">return</span> pbnc_list[-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>피보나치 수열 문제를 풀 수 있는 가장 쉬운 방법은 재귀(<code>recursion</code>)일 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span> || n===<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pibonacci(n-<span class="number">2</span>) + pibonacci(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><p>그러나 위 풀이에는 많은 계산들이 중복되어 효율성이 매우 떨어진다.</p><p>이 때, 배열을 이용한 동적계획법 (Dynamic Programming)을 활용해 풀 수 있다.</p><p>배열에 저장하며 사용하면 중복되는 계산없이 풀 수 있고, 이때 복잡도는 <script type="math/tex">O(N)</script>을 따른다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/DP/">DP</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/12/b5f9f208b449/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 프린터</title>
      <link>https://sklubmk.github.io/2021/08/11/539b25284767/</link>
      <guid>https://sklubmk.github.io/2021/08/11/539b25284767/</guid>
      <pubDate>Tue, 10 Aug 2021 15:05:04 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;프린터&quot;&gt;&lt;a href=&quot;#프린터&quot; class=&quot;headerlink&quot; title=&quot;프린터&quot;&gt;&lt;/a&gt;프린터&lt;/h1&gt;&lt;p&gt;JavaScript, Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="프린터"><a href="#프린터" class="headerlink" title="프린터"></a>프린터</h1><p>JavaScript, Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1\. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.</span><br><span class="line">&gt;2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.</span><br><span class="line">&gt;3. 그렇지 않으면 J를 인쇄합니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.</p><p>내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.</p><p>현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.</li><li>인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.</li><li>location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>priorities</th><th>location</th><th>return</th></tr></thead><tbody><tr><td>[2, 1, 3, 2]</td><td>2</td><td>1</td></tr><tr><td>[1, 1, 9, 1, 1, 1]</td><td>0</td><td>5</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>예제 #1</p><p>문제에 나온 예와 같습니다.</p><p>예제 #2</p><p>6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다.</p><p><a href="http://www.csc.kth.se/contest/nwerc/2006/problems/nwerc06.pdf">출처</a></p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">priorities, location</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> currentIndex = location;</span><br><span class="line">    <span class="keyword">var</span> n = priorities.length</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        answer++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> max = priorities.indexOf(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,priorities))</span><br><span class="line">        <span class="keyword">if</span>(max === currentIndex)</span><br><span class="line">            <span class="keyword">return</span> answer;</span><br><span class="line">        </span><br><span class="line">        priorities[max] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> head = priorities.splice(<span class="number">0</span>, max)</span><br><span class="line">        max &lt; currentIndex ? currentIndex -= max : currentIndex += (n-max);</span><br><span class="line">        priorities.push.apply(priorities,head);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">priorities, location</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    <span class="keyword">while</span> priorities:</span><br><span class="line">        p_max = <span class="built_in">max</span>(priorities)</span><br><span class="line">        <span class="keyword">while</span> priorities[<span class="number">0</span>] != p_max:</span><br><span class="line">            priorities.append(priorities.pop(<span class="number">0</span>))</span><br><span class="line">            location = <span class="built_in">len</span>(priorities)-<span class="number">1</span> <span class="keyword">if</span> location == <span class="number">0</span> <span class="keyword">else</span> location-<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> location == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(queue) +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            queue.append(priorities.pop(<span class="number">0</span>))</span><br><span class="line">            location -= <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><code>queue</code> 자료구조를 활용하여 푸는 시물레이션 문제다.</p><p>문제에서 주어진 조건의 함수를 <code>queue</code>를 활용해 구현하면 쉽게 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/11/539b25284767/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 튜플</title>
      <link>https://sklubmk.github.io/2021/08/10/4ee95b87b24f/</link>
      <guid>https://sklubmk.github.io/2021/08/10/4ee95b87b24f/</guid>
      <pubDate>Tue, 10 Aug 2021 12:56:12 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;튜플&quot;&gt;&lt;a href=&quot;#튜플&quot; class=&quot;headerlink&quot; title=&quot;튜플&quot;&gt;&lt;/a&gt;튜플&lt;/h1&gt;&lt;p&gt;Javascript, Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="튜플"><a href="#튜플" class="headerlink" title="튜플"></a>튜플</h1><p>Javascript, Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.</p><ul><li>(a1, a2, a3, …, an)</li></ul><p>튜플은 다음과 같은 성질을 가지고 있습니다.</p><ol><li>중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)</li><li>원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)</li><li>튜플의 원소 개수는 유한합니다.</li></ol><p>원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 <code>(a1, a2, a3, ..., an)</code>이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다.</p><ul><li><code>&#123;&#123;a1&#125;, &#123;a1, a2&#125;, &#123;a1, a2, a3&#125;, &#123;a1, a2, a3, a4&#125;, ... &#123;a1, a2, a3, a4, ..., an&#125;&#125;</code></li></ul><p>예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는</p><ul><li><code>&#123;&#123;2&#125;, &#123;2, 1&#125;, &#123;2, 1, 3&#125;, &#123;2, 1, 3, 4&#125;&#125;</code></li></ul><p>와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로</p><ul><li><code>&#123;&#123;2&#125;, &#123;2, 1&#125;, &#123;2, 1, 3&#125;, &#123;2, 1, 3, 4&#125;&#125;</code></li><li><code>&#123;&#123;2, 1, 3, 4&#125;, &#123;2&#125;, &#123;2, 1, 3&#125;, &#123;2, 1&#125;&#125;</code></li><li><code>&#123;&#123;1, 2, 3&#125;, &#123;2, 1&#125;, &#123;1, 2, 4, 3&#125;, &#123;2&#125;&#125;</code></li></ul><p>는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.</p><p>특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="[제한사항]"></a>[제한사항]</h2><ul><li>s의 길이는 5 이상 1,000,000 이하입니다.</li><li>s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다.</li><li>숫자가 0으로 시작하는 경우는 없습니다.</li><li>s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.</li><li>s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.</li><li>return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.</li></ul><hr><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="[입출력 예]"></a>[입출력 예]</h2><div class="table-container"><table><thead><tr><th>s</th><th>result</th></tr></thead><tbody><tr><td><code>&quot;&#123;&#123;2&#125;,&#123;2,1&#125;,&#123;2,1,3&#125;,&#123;2,1,3,4&#125;&#125;&quot;</code></td><td>[2, 1, 3, 4]</td></tr><tr><td><code>&quot;&#123;&#123;1,2,3&#125;,&#123;2,1&#125;,&#123;1,2,4,3&#125;,&#123;2&#125;&#125;&quot;</code></td><td>[2, 1, 3, 4]</td></tr><tr><td><code>&quot;&#123;&#123;20,111&#125;,&#123;111&#125;&#125;&quot;</code></td><td>[111, 20]</td></tr><tr><td><code>&quot;&#123;&#123;123&#125;&#125;&quot;</code></td><td>[123]</td></tr><tr><td><code>&quot;&#123;&#123;4,2,3&#125;,&#123;3&#125;,&#123;2,3,4,1&#125;,&#123;2,3&#125;&#125;&quot;</code></td><td>[3, 2, 4, 1]</td></tr></tbody></table></div><h2 id="입출력-예에-대한-설명"><a href="#입출력-예에-대한-설명" class="headerlink" title="입출력 예에 대한 설명"></a>입출력 예에 대한 설명</h2><h3 id="입출력-예-1"><a href="#입출력-예-1" class="headerlink" title="입출력 예 #1"></a>입출력 예 #1</h3><p>문제 예시와 같습니다.</p><h3 id="입출력-예-2"><a href="#입출력-예-2" class="headerlink" title="입출력 예 #2"></a>입출력 예 #2</h3><p>문제 예시와 같습니다.</p><h3 id="입출력-예-3"><a href="#입출력-예-3" class="headerlink" title="입출력 예 #3"></a>입출력 예 #3</h3><p>(111, 20)을 집합 기호를 이용해 표현하면 <code>&#123;&#123;111&#125;, &#123;111,20&#125;&#125;</code>이 되며, 이는 <code>&#123;&#123;20,111&#125;,&#123;111&#125;&#125;</code>과 같습니다.</p><h3 id="입출력-예-4"><a href="#입출력-예-4" class="headerlink" title="입출력 예 #4"></a>입출력 예 #4</h3><p>(123)을 집합 기호를 이용해 표현하면 <code>&#123;&#123;123&#125;&#125;</code> 입니다.</p><h3 id="입출력-예-5"><a href="#입출력-예-5" class="headerlink" title="입출력 예 #5"></a>입출력 예 #5</h3><p>(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 <code>&#123;&#123;3&#125;,&#123;3,2&#125;,&#123;3,2,4&#125;,&#123;3,2,4,1&#125;&#125;</code>이 되며, 이는 <code>&#123;&#123;4,2,3&#125;,&#123;3&#125;,&#123;2,3,4,1&#125;,&#123;2,3&#125;&#125;</code>과 같습니다.</p></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&quot;&#123;&#123;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        .replace(<span class="string">&quot;&#125;&#125;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        .split(<span class="string">&quot;&#125;,&#123;&quot;</span>)</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        .sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a.length-b.length)</span><br><span class="line">        .reduce(<span class="function">(<span class="params">list,cur</span>)=&gt;</span>[...new <span class="built_in">Set</span>(list.concat(cur))])</span><br><span class="line">        .map(<span class="function"><span class="params">x</span>=&gt;</span>x*<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">s</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">sorted</span>([i.split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> re.split(<span class="string">&#x27;&#123;&#123;|&#125;&#125;|&#125;,&#123;&#x27;</span>,s)[<span class="number">1</span>:-<span class="number">1</span>]],key=<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(d) <span class="keyword">not</span> <span class="keyword">in</span> answer:</span><br><span class="line">                answer.append(<span class="built_in">int</span>(d))</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p>다음과 같은 풀이 과정을 따른다.</p><ol><li>주어진 문자열을 2차원 배열로 정제한다.</li><li>배열 안의 내부 배열들을 각 길이의 오름차순으로 정렬한다.</li><li>반복문을 돌며 다음 배열에서 현재 배열에 없는 값을 현재 배열에 추가한다.</li></ol><p><br/></p><p>1번의 과정은 정규표현식을 통해 간략화 할 수 있다.<br>3번의 과정은 <code>reduce</code> 함수와 <code>Set</code> 자료구조를 통해 쉽게 표현 할 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/10/4ee95b87b24f/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 타겟 넘버</title>
      <link>https://sklubmk.github.io/2021/08/09/9bb8d3343a89/</link>
      <guid>https://sklubmk.github.io/2021/08/09/9bb8d3343a89/</guid>
      <pubDate>Sun, 08 Aug 2021 16:08:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;타겟-넘버&quot;&gt;&lt;a href=&quot;#타겟-넘버&quot; class=&quot;headerlink&quot; title=&quot;타겟 넘버&quot;&gt;&lt;/a&gt;타겟 넘버&lt;/h1&gt;&lt;p&gt;JavaScript, Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="타겟-넘버"><a href="#타겟-넘버" class="headerlink" title="타겟 넘버"></a>타겟 넘버</h1><p>JavaScript, Python3</p><span id="more"></span><p><br/></p><blockquote><h1 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h1><p>n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br></pre></td></tr></table></figure><p>사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.</p><h2 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h2><ul><li>주어지는 숫자의 개수는 2개 이상 20개 이하입니다.</li><li>각 숫자는 1 이상 50 이하인 자연수입니다.</li><li>타겟 넘버는 1 이상 1000 이하인 자연수입니다.</li></ul><h2 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h2><div class="table-container"><table><thead><tr><th>numbers</th><th>target</th><th>return</th></tr></thead><tbody><tr><td>[1, 1, 1, 1, 1]</td><td>3</td><td>5</td></tr></tbody></table></div><h2 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h2><p>문제에 나온 예와 같습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> returnArray = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">i=<span class="number">0</span>,curArray=[]</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i === numbers.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curArray.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b,<span class="number">0</span>) === target)</span><br><span class="line">                answer++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        calc(i+<span class="number">1</span>,[numbers[i], ...curArray])</span><br><span class="line">        calc(i+<span class="number">1</span>,[-<span class="number">1</span>*numbers[i], ...curArray])</span><br><span class="line">    &#125;</span><br><span class="line">    calc()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python-DFS"><a href="#python-DFS" class="headerlink" title="python DFS"></a>python DFS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">numbers, target</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(numbers)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>([ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>&lt;&lt;n) <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: [<span class="number">1</span>,-<span class="number">1</span>][<span class="built_in">int</span>(x[<span class="number">1</span>])]*numbers[x[<span class="number">0</span>]], <span class="built_in">enumerate</span>(<span class="built_in">list</span>(<span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(n))))) == target ])</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="python-recursion"><a href="#python-recursion" class="headerlink" title="python recursion"></a>python recursion</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">numbers, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">and</span> target == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> numbers:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> solution(numbers[<span class="number">1</span>:], target - numbers[<span class="number">0</span>]) + solution(numbers[<span class="number">1</span>:], target+numbers[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><br/></p><h2 id="DFS-풀이-javascript-python"><a href="#DFS-풀이-javascript-python" class="headerlink" title="DFS 풀이 (javascript, python)"></a>DFS 풀이 (javascript, python)</h2><p><br/></p><p>카운트를 세는 방식의 재귀함수 DFS 풀이다. </p><p>가장 일반적으로 떠올릴 수 있는 풀이 방법으로, <code>numbers</code>의 길이만큼 재귀함수의 뎁스를 가진다. 매 재귀함수마다 늘어나는 계산은 2가지 (-1을 곱할때와 +1을 곱할때) 이므로 2배씩 늘어난다.</p><p>따라서 <code>numbers</code>의 길이가 <code>n</code> 일때 모든 <code>time complexity</code>는</p><p><script type="math/tex">1 + 2 + 4 + 8 + 2^{n} = \sum_{k=1}^{n} {2^k}</script> 이므로 <strong>등비수열의 합</strong>이 된다.</p><p>따라서 이를 계산하면 <script type="math/tex">2(2^{n}-1)</script>이 되고, <script type="math/tex">O(2^n)</script>을 뜻한다.</p><p><br/></p><h2 id="DFS-bit-mask-python"><a href="#DFS-bit-mask-python" class="headerlink" title="DFS + bit_mask (python)"></a>DFS + bit_mask (python)</h2><p><br/></p><p>재귀함수 대신 비트마스크를 이용한 반복문으로 풀이하는 방법.</p><ol><li><code>i</code>에 <code>1</code> ~ <code>1&lt;&lt;n</code> (<code>numbers</code>의 길이 <code>n</code> 만큼의 비트를 가지는 값 / ex: <code>n = 4</code> ? <code>1&lt;&lt;n = 16</code>) 까지 반복문을 돌며 값을 할당한다.</li><li>할당된 <code>i</code>값을 <strong>비트화</strong> 한다. <code>n=4</code> 일때, { <code>0000</code>, <code>0001</code>, <code>0010</code>, <code>0011</code>, &nbsp; <strong>…</strong> &nbsp; , <code>1111</code> } 의 값을 가진다.</li><li>비트화된 <code>i</code>값을 리스트로 나누어 <strong>0</strong>일땐 <code>+1</code>을, <strong>1</strong>일땐 <code>-1</code>을 곱한뒤 이 값들을 모두 더하고, 더한 값이 <code>target</code>과 같은 것들을 필터링 한다.</li></ol><p><br/></p><p>비트마스크를 이용한 풀이를 연습하려고 의도적으로 사용했고, 코드를 돌리면 첫 번째 풀이보다도 효율성이 떨어지는 결과를 얻는다. </p><p>위 모든 과정에서 <strong>최소</strong> <script type="math/tex">O(nlog_{2}{n})</script>이 소요되는데, 특히나 3번 과정은 리스트를 나누고 값을 곱한뒤 더하는 계산으로 <strong>최소</strong> <script type="math/tex">O(n^3)</script>의 복잡도를 보인다. 전체 계산은 대략 <script type="math/tex">O(n^5log_{2}{n})</script>이 된다.</p><p><br/></p><p>여기서 재미있는 점은, 사실 아래 풀이의 효율성이 위 문제보다 좋다는 것이다. </p><p>문제에서 주어진 <code>n</code>의 조건은 <code>20</code> 이하다. 이 조건 내에서 위 <script type="math/tex">O(2^n)</script>에 접목시키면 대략 <code>100만</code>번의 풀이가 나온다. 아래 식에 <code>20</code>을 접목시키면 대략 <code>2000만</code>번의 풀이가 나온다. 해당 조건에서 아래 풀이가 더 효율성이 떨어지지만, 지수함수와 다항함수의 차이는 그 값이 커질수록 기하급수적으로 차이가 난다. </p><p><code>n</code>의 제한이 <code>40</code>까지만 되도 위 식의 풀이는 <code>1조번</code> 이상의 시간이 소요된다.  그러나 아래식은 대략 <code>10억번</code>의 시간으로 풀이가 가능하다.  풀이 시간 뿐만 아니라 DFS 풀이에서 반복되는 재귀함수의 <code>stack</code> 점유는 제한 조건이 조금만 상향되도 문제로 다가올 것이다.</p><p><br/></p><p>따라서 이런 점으로 미루어보아, 주어진 문제의 <strong>제한사항</strong>을 꼼꼼히 확인할 필요가 있다. 특히나 이 문제처럼 다소 가벼운 조건의 문제라면 시간복잡도가 높은 풀이 방법이 오히려 좋은 효율을 보일 수 있기 때문이다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/">lv2</category>
      
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/">자바스크립트</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/">파이썬</category>
      
      <category domain="https://sklubmk.github.io/tags/bit/">bit</category>
      
      <category domain="https://sklubmk.github.io/tags/DFS/">DFS</category>
      
      
      <comments>https://sklubmk.github.io/2021/08/09/9bb8d3343a89/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
