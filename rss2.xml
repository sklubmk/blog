<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JK&#39;s Devlog</title>
    <link>https://sklubmk.github.io/</link>
    
    <atom:link href="https://sklubmk.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 29 Jul 2021 13:47:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[알고리즘] 서로소 집합 자료 구조 (Disjoint Set)</title>
      <link>https://sklubmk.github.io/2021/07/28/d0fc2da48b98/</link>
      <guid>https://sklubmk.github.io/2021/07/28/d0fc2da48b98/</guid>
      <pubDate>Wed, 28 Jul 2021 12:45:25 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;서로소 집합 자료구조(&lt;code&gt;Disjoint set&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;서로소 집합 연결 리스트 (&lt;code&gt;Disjoint-set linked lists&lt;/code&gt;) &lt;/li&gt;
&lt;li&gt;서로소 집합 숲 (&lt;code&gt;Disjoint-set forest&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;최적화&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>서로소 집합 자료구조(<code>Disjoint set</code>)</li><li>서로소 집합 연결 리스트 (<code>Disjoint-set linked lists</code>) </li><li>서로소 집합 숲 (<code>Disjoint-set forest</code>)</li><li>최적화</li></ul><span id="more"></span><p><br/></p><p><br/></p><h1 id="서로소-집합-자료-구조-Disjoint-Set"><a href="#서로소-집합-자료-구조-Disjoint-Set" class="headerlink" title="서로소 집합 자료 구조 (Disjoint Set)"></a>서로소 집합 자료 구조 (Disjoint Set)</h1><hr><p><strong>서로소 집합 자료 구조</strong>란 <U>서로소 부분 집합</U>으로 나눠진 원소들에 대한 정보를 다루는 자료구조다.</p><p>여기서 <strong>서로소 집합</strong>은 <U>공통 원소</U>가 없는 두 집합을 뜻한다.</p><p>즉, <strong>서로소 집합 자료구조</strong>는 <U>상호 배타적</U>인 부분 집합들로 이루어진 원소들을 다루는 자료구조다.</p><ul><li>서로소 집합(<code>disjoint-set</code>) 자료 구조</li><li>합집합-찾기(<code>union-find</code>) 자료 구조</li><li>병합-찾기 집합(<code>merge-find set</code>)</li></ul><p>위 3가지 자료 구조는 모두 <strong>서로소 부분 집합</strong>을 다룬다.</p><p><br/></p><p><br/></p><h2 id="사용-함수"><a href="#사용-함수" class="headerlink" title="사용 함수"></a>사용 함수</h2><hr><div style="width: 70%; background: rgba(255,255,255,0.2); border: 2.0rem solid rgba(255,255,255,0); margin: 2.0rem auto"><img alt="메이크셋은 한 원소의 집합을 만든다" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Dsu_disjoint_sets_init.svg/720px-Dsu_disjoint_sets_init.svg.png" /><br/><img alt="유니온 연산을 반복적으로 수행하면 여러 집합들이 합쳐진다" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ac/Dsu_disjoint_sets_final.svg/720px-Dsu_disjoint_sets_final.svg.png" /></div><ul><li>파인드(<code>Find</code>): 어떤 원소가 주어졌을 때 이 원소가 속한 집합을 반환한다. 일반적으로 같은 집합인지 판단하기 위해 집합을 대표하는 원소를 반환한다.</li><li>유니온(<code>Union</code>): 두 개의 집합을 하나의 집합으로 합친다.</li><li>메이크셋(<code>MakeSet</code>): 특정 <strong>한 원소</strong>만을 가지는 집합을 만든다.</li></ul><p>이 세 가지 연산을 활용하여 많은 파티션(<code>partitioning</code>) 문제들을 해결 할 수 있다.</p><p><br/></p><p><br/></p><h1 id="서로소-집합-연결-리스트-Disjoint-set-linked-lists"><a href="#서로소-집합-연결-리스트-Disjoint-set-linked-lists" class="headerlink" title="서로소 집합 연결 리스트 (Disjoint-set linked lists)"></a>서로소 집합 연결 리스트 (Disjoint-set linked lists)</h1><hr><p><img style="display: block;margin: 0 auto; width: 50%" alt="각 노드가 head를 가르키는 서로소 집합 연결 리스트" src="/img/post_images/algorithm/Disjoint-set_linked_lists.png" /></p><p><br/></p><ul><li>서로소 집합 데이터 구조는 간단히 집합을 표현하기 위해 연결 리스트(linked list)를 사용한다.</li><li>각 리스트의 헤드(head) 부분에는 해당 집합의 대표 원소를 저장한다.</li><li><code>MakeSet</code>은 한 원소만을 가지는 리스트를 생성한다.</li><li><code>Union</code>은 두 리스트를 붙이는 연산을 수행한다. 이때 한 리스트의 헤드 부분이 다른 리스트의 꼬리를 가리켜 <U>상수 시간(<code>constant-time</code>)</U> 연산을 수행한다.</li><li><code>Find</code> 수행시 특정 원소로부터 리스트의 헤드까지 반대 방향으로 탐색해야 하므로 <script type="math/tex">O(n)</script>이 소요된다.<ul><li>이 단점은 각 연결 리스트 노드에 헤드를 가리키는 포인터를 포함시켜 해결 할 수 있다. 이 때문에 상수 시간으로 대표 원소를 바로 참조할 수 있다.</li><li>그러나 이 경우 <code>Union</code> 연산시 head를 갱신해야하므로 <script type="math/tex">O(n)</script>이 요구된다.</li></ul></li></ul><p><br/></p><h2 id="가중치-유니온-휴리스틱-weighted-union-heuristic"><a href="#가중치-유니온-휴리스틱-weighted-union-heuristic" class="headerlink" title="가중치-유니온 휴리스틱 (weighted-union heuristic)"></a>가중치-유니온 휴리스틱 (weighted-union heuristic)</h2><ul><li>서로소 집합 연결 리스트(<code>Disjoint-set linked lists</code>)의 성능 향상 방법.</li><li>만약 각 리스트의 길이를 추적(길이 기준 sorting 등)할 수 있다면, 항상 짧은 리스트를 긴 리스트에 덧붙이며 요구 시간(required time) 성능을 향상시킬 수 있다.</li><li><code>n</code>개의 원소들의 <code>m</code>개의 연이은 <code>MakeSet</code>, <code>Union</code>, <code>Find</code>를 수행할 경우 <script type="math/tex">O(m + nlogn)</script> 시간을 요구한다.</li><li>점근적으로(asymptotically) 더 빠른 연산을 위해서 다른 자료 구조(Tree 등)가 필요하다.</li></ul><p><br/></p><p><img style="display: block;margin: 0 auto; width: 80%; border: 2.0rem solid rgba(255,255,255,1)" alt="리스트 L 원소의 병합과정 비용" src="/img/post_images/algorithm/disjoint-set-linked-time.png" /></p><p>위 그림에서 전체 노드의 갯수는 n(n=8)이고 연결 리스트 L은 1개의 원소를 담은 배열이다. 배열 L이 자신보다 길이가 같거나 큰 배열과 <code>Union</code>을 수행한다면 매 수행마다 길이가 2배가 되야 한다. 이때 발생하는 비용은 정확히 <script type="math/tex">log_{2}{n}</script>이다.</p><p>따라서 특정 리스트(L)안의 특정 원소(node 8)는 최악의 경우 <script type="math/tex">log_{2}{n}</script>번의 갱신이 필요하다. 그러므로 n개의 원소를 가지는 한 리스트는 최악의 경우 <script type="math/tex">O(nlog{n})</script>의 시간이 걸린다. 이 구조에서 각 노드는 원소가 속한 리스트의 이름(head)을 포함하므로 <code>Find</code> 연산은 <script type="math/tex">O(1)</script>의 시간이 걸린다.</p><p><br/></p><p><br/></p><h1 id="서로소-집합-숲-Disjoint-set-forest"><a href="#서로소-집합-숲-Disjoint-set-forest" class="headerlink" title="서로소 집합 숲 (Disjoint-set forest)"></a>서로소 집합 숲 (Disjoint-set forest)</h1><hr><ul><li>서로소 연결 리스트에 트리(<code>Tree</code>)를 접목한 자료구조</li><li>각 노드들은 부모 노드를 참조</li><li>각 집합의 대표는 해당 트리의 루트(<code>root</code>) 노드</li><li><code>Find</code>는 루트 노드에 도달할 때까지 부모 노드를 따라 참조</li><li><code>Union</code>은 한 루트 노드를 다룬 루트 노드에 연결하여 병합</li><li>최악의 경우 매우 불균형한 트리를 생성하여 연결 리스트와 동일</li></ul><p><br/></p><h2 id="함수-Python"><a href="#함수-Python" class="headerlink" title="함수 (Python)"></a>함수 (Python)</h2><div class="clean"> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># makeSet</span></span><br><span class="line">parent = [<span class="number">0</span>] * (N+<span class="number">1</span>) <span class="comment"># 부모 테이블 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 부모 테이블 상에서 자기 자신을 부모로 설정</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    parent[i] = i</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">a</span>):</span> <span class="comment"># a 정점의 루트 노드 탐색</span></span><br><span class="line">    <span class="keyword">if</span> parent[a] == a: <span class="comment"># a가 루트 노드이면, a 반환</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> find(parent[a]) <span class="comment"># 루트가 아니면 a의 부모 노드로 재탐색</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">a, b</span>):</span> <span class="comment"># a와 b 집합을 병합</span></span><br><span class="line">    a = find(a) <span class="comment"># a의 루트 노드 탐색</span></span><br><span class="line">    b = find(b) <span class="comment"># b의 루트 노드 탐색</span></span><br><span class="line">    parent[a] = parent[b]</span><br></pre></td></tr></table></figure></div><p><img style="width: 40%;margin: auto; display: block" alt="최악의 경우" src="http://isukorea.com/media/PNG/uf_09.PNG" /></p><ul><li>최악의 경우 연결 리스트와 동일한 효율성을 갖는다.</li><li>아래 두 가지 방법을 통해 성능을 개선할 수 있다.</li></ul><p><br/></p><h2 id="유니온-바이-랭크-Union-by-rank"><a href="#유니온-바이-랭크-Union-by-rank" class="headerlink" title="유니온 바이 랭크(Union by rank)"></a>유니온 바이 랭크(Union by rank)</h2><p><img style="width: 60%;margin: auto; display: block" alt="유니온 바이 랭크" src="http://isukorea.com/media/GIF/uf_13.gif" /></p><ul><li>항상 작은 트리를 큰 트리 루트에 붙이는 방법</li><li>두 트리의 깊이가 같을 경우에만 깊이가 증가</li><li>만약 <strong>경로 압축</strong>을 활용하면 깊이가 같을 경우 알고리즘 동작이 멈추므로 깊이 대신 rank란 용어 사용</li><li>한 개의 원소를 가지는 트리의 랭크 = <code>0</code></li><li>같은 랭크 <code>r</code>을 가지는 두 트리가 합쳐질 경우 <code>r+1</code>의 트리가 만들어짐</li><li>이때 <code>Union</code> 또는 <code>Find</code> 연산은 <script type="math/tex">O(logn)</script>을 가진다.</li></ul><p><br/></p><p>[<code>향상된 MakeSet</code>]</p><div class="clean"> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># makeSet</span></span><br><span class="line">parent = [<span class="number">0</span>] * (N+<span class="number">1</span>) <span class="comment"># 부모 테이블 초기화</span></span><br><span class="line">rank = [<span class="number">0</span>] * (N+<span class="number">1</span>) <span class="comment"># 정점의 rank를 저장</span></span><br></pre></td></tr></table></figure></div><p>[<code>향상된 Union</code>]</p><div class="clean"> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">a, b</span>):</span> <span class="comment"># a와 b 집합을 병합</span></span><br><span class="line">    a = find(a) <span class="comment"># a의 루트 노드 탐색</span></span><br><span class="line">    b = find(b) <span class="comment"># b의 루트 노드 탐색</span></span><br><span class="line">    <span class="keyword">if</span> a == b: <span class="comment"># 루트 노드가 동일하면, 동일한 집합</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> rank[a] &gt; rank[b]: <span class="comment"># rank가 낮은 집합을 rank가 높은 집합으로 병합</span></span><br><span class="line">        parent[b] = a <span class="comment"># 병합</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[a] = b <span class="comment"># 집합 병합</span></span><br><span class="line">        <span class="keyword">if</span> rank[a] == rank[b]: <span class="comment"># 두 랭크가 동일하면</span></span><br><span class="line">            rank[b] += <span class="number">1</span> <span class="comment"># 랭크 +1</span></span><br></pre></td></tr></table></figure></div><p><br/></p><h2 id="경로-압축-path-compression"><a href="#경로-압축-path-compression" class="headerlink" title="경로 압축 (path compression)"></a>경로 압축 (path compression)</h2><p><img style="width: 70%;margin: auto; display: block" alt="경로 압축" src="https://codeforces.com/predownloaded/32/4b/324b5a317afe8645c60b2a3aaa0451fd857dd961.png" /></p><ul><li>파인드 연산을 수행 할 때마다 트리의 구조를 평평하게 만드는 방법</li><li>방문한 각 노드들이 직접 루트 노드를 가리키도록 갱신하는 것</li><li>모든 노드가 같은 대표 노드를 공유</li><li>최종 생성된 트리는 보다 평평해짐</li><li>해당 원소뿐만 아니라 직/간접적으로 참조하는 연산들의 속도를 빠르게 해줌</li><li><code>Find</code> 연산이 시간 복잡도를 좌우하며 <script type="math/tex">O(N-1)</script>을 따른다.</li></ul><p>[<code>향상된 Find</code>]</p><div class="clean"> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">a</span>):</span> <span class="comment"># a 정점의 루트 노드 탐색</span></span><br><span class="line">    <span class="keyword">if</span> parent[a] == a: <span class="comment"># a가 루트 노드이면, a 반환</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    p = find(parent[a]) <span class="comment"># 루트 노드 탐색</span></span><br><span class="line">    parent[a] = p <span class="comment"># a의 루트 노드 갱신</span></span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br></pre></td></tr></table></figure></div><p><br/></p><h2 id="최적화"><a href="#최적화" class="headerlink" title="최적화"></a>최적화</h2><p><br/></p><p><img style="width: 70%;margin: auto; display: block" alt="유니온 바이 랭크 + 경로 압축" src="https://raw.githubusercontent.com/yuegs/yuegs.github.io/master/images/algorithm/union-find/weighted-quick-union-compression.gif" /></p><p>[<code>최적화 코드 - python</code>]</p><div class="clean"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment"># 노드 수 입력 받기</span></span><br><span class="line">M = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment"># 정점 수 입력 받기</span></span><br><span class="line">parent = [<span class="number">0</span>] * (N+<span class="number">1</span>) <span class="comment"># 부모 테이블 초기화</span></span><br><span class="line">rank = [<span class="number">0</span>] * (N+<span class="number">1</span>) <span class="comment"># 정점의 rank를 저장</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 부모 테이블 상에서 자기 자신을 부모로 설정</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    parent[i] = i</span><br><span class="line">    </span><br><span class="line"><span class="comment"># union find algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">a</span>):</span> <span class="comment"># a 정점의 루트 노드 탐색</span></span><br><span class="line">    <span class="keyword">if</span> parent[a] == a: <span class="comment"># a가 루트 노드이면, a 반환</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    p = find(parent[a]) <span class="comment"># 루트 노드 탐색</span></span><br><span class="line">    parent[a] = p <span class="comment"># a의 루트 노드 갱신</span></span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">a, b</span>):</span> <span class="comment"># a와 b 집합을 병합</span></span><br><span class="line">    a = find(a) <span class="comment"># a의 루트 노드 탐색</span></span><br><span class="line">    b = find(b) <span class="comment"># b의 루트 노드 탐색</span></span><br><span class="line">    <span class="keyword">if</span> a == b: <span class="comment"># 루트 노드가 동일하면, 동일한 집합</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> rank[a] &gt; rank[b]: <span class="comment"># rank가 낮은 집합을 rank가 높은 집합으로 병합</span></span><br><span class="line">        parent[b] = a <span class="comment"># 병합</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[a] = b <span class="comment"># 집합 병합</span></span><br><span class="line">        <span class="keyword">if</span> rank[a] == rank[b]: <span class="comment"># 두 랭크가 동일하면</span></span><br><span class="line">            rank[b] += <span class="number">1</span> <span class="comment"># 랭크 +1</span></span><br></pre></td></tr></table></figure></div><p><br/></p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><hr><p><a href="https://ko.wikipedia.org/wiki/%EC%84%9C%EB%A1%9C%EC%86%8C_%EC%A7%91%ED%95%A9_%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0">서로소 집합 자료 구조 - 위키백과</a></p><p><a href="https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html">[알고리즘] Union-Find 알고리즘</a></p><p><a href="https://deep-learning-study.tistory.com/589">Union-Find 알고리즘</a></p><p><a href="http://isukorea.com/blog/home/waylight3/215">서로소 집합 / 유니온 파인드</a></p><p><a href="https://codeforces.com/blog/entry/57338">Understanding Disjoint Set Structures - CODEFORCES</a></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B0%9C%EB%85%90/">개념</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/Disjoint-Set/">Disjoint Set</category>
      
      <category domain="https://sklubmk.github.io/tags/Union-Find/">Union-Find</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/28/d0fc2da48b98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 체육복</title>
      <link>https://sklubmk.github.io/2021/07/22/63a696571dde/</link>
      <guid>https://sklubmk.github.io/2021/07/22/63a696571dde/</guid>
      <pubDate>Thu, 22 Jul 2021 11:03:22 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;체육복&quot;&gt;&lt;a href=&quot;#체육복&quot; class=&quot;headerlink&quot; title=&quot;체육복&quot;&gt;&lt;/a&gt;체육복&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="체육복"><a href="#체육복" class="headerlink" title="체육복"></a>체육복</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.</p><p>전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>전체 학생의 수는 2명 이상 30명 이하입니다.</li><li>체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.</li><li>여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.</li><li>여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.</li><li>여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>n</th><th>lost</th><th>reserve</th><th>return</th></tr></thead><tbody><tr><td>5</td><td>[2, 4]</td><td>[1, 3, 5]</td><td>5</td></tr><tr><td>5</td><td>[2, 4]</td><td>[3]</td><td>4</td></tr><tr><td>3</td><td>[3]</td><td>[1]</td><td>2</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>예제 #1\<br>1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.</p><p>예제 #2\<br>3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.</p><p><a href="http://hsin.hr/coci/archive/2009_2010/contest6_tasks.pdf">출처</a></p><p>※ 공지 - 2019년 2월 18일 지문이 리뉴얼되었습니다.\<br>※ 공지 - 2019년 2월 27일, 28일 테스트케이스가 추가되었습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, lost, reserve</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx, std <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">tuple</span>(lost)):</span><br><span class="line">        <span class="keyword">if</span> std <span class="keyword">in</span> reserve:</span><br><span class="line">            lost.remove(std)</span><br><span class="line">            reserve.remove(std)</span><br><span class="line">        <span class="keyword">elif</span> std-<span class="number">1</span> <span class="keyword">in</span> reserve:</span><br><span class="line">            lost.remove(std)</span><br><span class="line">            reserve.remove(std-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> (std+<span class="number">1</span> <span class="keyword">in</span> reserve) <span class="keyword">and</span> (std+<span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> lost):</span><br><span class="line">            lost.remove(std)</span><br><span class="line">            reserve.remove(std+<span class="number">1</span>)</span><br><span class="line">    answer = n-<span class="built_in">len</span>(lost)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>탐욕법을 사용하여 간단하게 해결할 수 있는 기본 문제다.</p><p>문제의 조건대로 lost의 배열을 조회하며 lost와 reserve를 수정한다.</p><p>lost 배열의 반복문을 돌며 lost 배열을 수정하면 반복문에 문제가 생기므로 tuple을 통해 값을 복사하여 반복문을 시행해야 한다.</p><p>각 for문의 선택이 다른 선택에 관여하지 않으므로, 탐욕법 풀이가 가능한 문제다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%83%90%EC%9A%95%EB%B2%95/">탐욕법</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/22/63a696571dde/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[TypeScript] 타입스크립트 시작하기</title>
      <link>https://sklubmk.github.io/2021/07/22/05da08db9576/</link>
      <guid>https://sklubmk.github.io/2021/07/22/05da08db9576/</guid>
      <pubDate>Thu, 22 Jul 2021 07:14:58 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;typescript 소개&lt;/li&gt;
&lt;li&gt;typescript 세팅&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>typescript 소개</li><li>typescript 세팅</li></ul><span id="more"></span><p><br/></p><p><br/></p><h1 id="타입스크립트가-필요한-이유"><a href="#타입스크립트가-필요한-이유" class="headerlink" title="타입스크립트가 필요한 이유"></a>타입스크립트가 필요한 이유</h1><hr><h3 id="타입스크립트는-자바스크립트의-슈퍼셋이다"><a href="#타입스크립트는-자바스크립트의-슈퍼셋이다" class="headerlink" title="타입스크립트는 자바스크립트의 슈퍼셋이다"></a>타입스크립트는 자바스크립트의 슈퍼셋이다</h3><p>JS의 모든 기능을 사용할 수 있을 뿐만 아니라, 추가 장점 기능들을 모두 사용할 수 있는 슈퍼셋이다.</p><p>자바스크립트를 대체한다가 아닌 슈퍼셋의 입장으로 공생의 전략을 취하는 언어다.</p><p><br/></p><h3 id="TypeScript-예시-코드"><a href="#TypeScript-예시-코드" class="headerlink" title="TypeScript 예시 코드"></a>TypeScript 예시 코드</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom type을 생성하여 명시적 선언 가능</span></span><br><span class="line"><span class="keyword">type</span> Centimeter = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> RainbowColor = <span class="string">&#x27;red&#x27;</span>|<span class="string">&#x27;orange&#x27;</span>|<span class="string">&#x27;yellow&#x27;</span>|<span class="string">&#x27;green&#x27;</span>|<span class="string">&#x27;blue&#x27;</span>|<span class="string">&#x27;navy&#x27;</span>|<span class="string">&#x27;purple&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수 뒤에 :type을 명시 </span></span><br><span class="line"><span class="keyword">let</span> age:<span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> weight:<span class="built_in">number</span> = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">let</span> height:Centimeter = <span class="number">176</span>; </span><br><span class="line"><span class="keyword">let</span> color:RainbowColor = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// it will be error</span></span><br><span class="line">color = <span class="string">&#x27;black&#x27;</span>;</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="JS-프로젝트를-TS-프로젝트로-바꾸기"><a href="#JS-프로젝트를-TS-프로젝트로-바꾸기" class="headerlink" title="JS 프로젝트를 TS 프로젝트로 바꾸기"></a>JS 프로젝트를 TS 프로젝트로 바꾸기</h1><hr><p>[<span style="color:orange">parcel.js 기준</span>]</p><ol><li><p>변경할 파일의 파일명 확장자 변경</p><ul><li>변경된 파일명 참조값 확인  </li></ul></li><li><p>tsconfig.json 파일 생성</p><ul><li>폴더 root에 tsconfig.json 파일을 생성</li></ul></li></ol><p><br/></p><p><br/></p><h3 id="tsconfig-json-옵션"><a href="#tsconfig-json-옵션" class="headerlink" title="tsconfig.json 옵션"></a>tsconfig.json 옵션</h3><hr><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">       <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES5&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">&quot;downlevelIteration&quot;</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>strict : 코드 작성시 TS 규칙을 강하게 적용할지 여부</li><li>target : TS 파일을 컴파일하여 생성된 JS 파일이 사용할 문법체계 버전</li><li>module : 모듈 시스템 버전 선택</li><li>alwaysStrict : 코드를 ECMAScript Strict 모드로 분석하고 각 소스파일들에 적용</li><li>noImplicitAny : Any 타입 사용 여부 (true 선택시 명확히 타입 기술 필요)</li><li>sourceMap : TS 결과를 출력해놓은 dist 폴더에 소스맵 파일 저장 여부<ul><li>소스맵 파일 : 변환된 JS파일에서 문제점을 찾기 어려울 수 있으므로 작성한 TS 코드를 그대로 저장해 놓은 데이터 파일</li></ul></li><li>downlevelIteration : 다운레벨링(이전 버전의 자바스크립트로 변환) 방법 결정 <ul><li>활성화시 <a href="https://www.typescriptlang.org/tsconfig#importHelpers">importHelpers</a> 를 통해 <a href="https://www.npmjs.com/package/tslib">tslib</a> 를 사용하여 인라인 자바스크립트의 양을 줄일 수 있음  </li><li>비활성화시 모든 object의 루프가 기존 루프(for/ of for)로 다운레벨화</li></ul></li></ul><p><br/></p><p><a href="https://www.typescriptlang.org/tsconfig">TSConfig 상세 문서</a></p><p><br/></p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/typescript/">typescript</category>
      
      
      <category domain="https://sklubmk.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://sklubmk.github.io/tags/typescript/">typescript</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B9%80%EB%AF%BC%ED%83%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8/">김민태의 프론트엔드 아카데미</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/22/05da08db9576/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 전화번호 목록</title>
      <link>https://sklubmk.github.io/2021/07/18/157c8079359d/</link>
      <guid>https://sklubmk.github.io/2021/07/18/157c8079359d/</guid>
      <pubDate>Sun, 18 Jul 2021 07:49:07 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;전화번호-목록&quot;&gt;&lt;a href=&quot;#전화번호-목록&quot; class=&quot;headerlink&quot; title=&quot;전화번호 목록&quot;&gt;&lt;/a&gt;전화번호 목록&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="전화번호-목록"><a href="#전화번호-목록" class="headerlink" title="전화번호 목록"></a>전화번호 목록</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.\<br>전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.</p><ul><li>구조대 : 119</li><li>박준영 : 97 674 223</li><li>지영석 : 11 9552 4421</li></ul><p>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.</p><h5 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h5><ul><li>phone_book의 길이는 1 이상 1,000,000 이하입니다.<ul><li>각 전화번호의 길이는 1 이상 20 이하입니다.</li><li>같은 전화번호가 중복해서 들어있지 않습니다.</li></ul></li></ul><h5 id="입출력-예제"><a href="#입출력-예제" class="headerlink" title="입출력 예제"></a>입출력 예제</h5><div class="table-container"><table><thead><tr><th>phone_book</th><th>return</th></tr></thead><tbody><tr><td>[“119”, “97674223”, “1195524421”]</td><td>false</td></tr><tr><td>[“123”,”456”,”789”]</td><td>true</td></tr><tr><td>[“12”,”123”,”1235”,”567”,”88”]</td><td>false</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>입출력 예 #1\<br>앞에서 설명한 예와 같습니다.</p><p>입출력 예 #2\<br>한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.</p><p>입출력 예 #3\<br>첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.</p><hr><p>알림</p><p>2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.</p><p><a href="https://ncpc.idi.ntnu.no/ncpc2007/ncpc2007problems.pdf">출처</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">phone_book</span>):</span></span><br><span class="line">    phone_book.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(phone_book)):</span><br><span class="line">        <span class="keyword">if</span> phone_book[i].find(phone_book[i-<span class="number">1</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>해시 카테고리의 문제이나, 언뜻 생각할 수 있는 풀이 방법은 다양하다.</p><p><br/></p><p>그러나 문제의 제한사항에서 phone_book의 길이가 최대 100만이므로, $O(N^2)$ 이상은 효율성에서 실패할 것이다. 그러므로 최소한 $O(NlogN)$ 이하의 효율성을 보이는 풀이가 필요하다.</p><p><br/></p><p>hash를 이용해서도 문제를 풀 수 있다.  한 번의 반복문으로 모든 번호를 hash에 넣고, 다시 한 번 배열을 돌며 각 번호의 부분집합이 dict에 포함되어있는지 비교하면 된다. 전화번호의 길이가 최대 20이므로, 총 계산은 $O(21N)$이 되어 아슬아슬하게 풀이에 통과된다.</p><p><br/></p><p>그러나 가장 간단한 풀이는, 위 코드처럼 번호를 ‘문자’를 기준으로 정렬했을 때다. 이때 접두사가 포함된 문자는 반드시 접두사 문자 바로 뒤에 정렬되기 때문에 간단히 O(N) 비용으로 문제를 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/hash/">hash</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/18/157c8079359d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV4) 미로 탈출</title>
      <link>https://sklubmk.github.io/2021/07/15/28bed7b50dc1/</link>
      <guid>https://sklubmk.github.io/2021/07/15/28bed7b50dc1/</guid>
      <pubDate>Thu, 15 Jul 2021 06:10:59 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;미로-탈출&quot;&gt;&lt;a href=&quot;#미로-탈출&quot; class=&quot;headerlink&quot; title=&quot;미로 탈출&quot;&gt;&lt;/a&gt;미로 탈출&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="미로-탈출"><a href="#미로-탈출" class="headerlink" title="미로 탈출"></a>미로 탈출</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>신규 게임 ‘카카오 미로 탈출’이 출시되어, <code>라이언</code>이 베타테스터로 참가했습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0015adcc-d76e-40e3-8004-70dd8deff2ec/Maze.png" alt="Maze.png"></p><p>위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정으로 이동하면, 이동한 함정과 연결된 모든 화살표의 방향이 바뀝니다.\<br>출발지점인 <code>1</code>번 방에서 탈출이 가능한 <code>3</code>번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다.</p><ul><li>그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다.<ul><li>방이 <code>n</code>개일 때, 방 번호는 1부터 <code>n</code>까지 사용됩니다.</li></ul></li><li>화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다.<ul><li>화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다.</li></ul></li><li>그림에 표시된 빨간색 방인 <code>2</code>번 방은 함정입니다.<ul><li>함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다.</li><li>위 그림 <code>1</code>번 방에서 <code>2</code>번 방으로 이동하는 순간 <code>1</code>에서 <code>2</code>로 이동할 수 있던 길은 <code>2</code>에서 <code>1</code>로 이동할 수 있는 길로 바뀌고, <code>3</code>에서 <code>2</code>로 이동할 수 있던 길은 <code>2</code>에서 <code>3</code>으로 이동할 수 있는 길로 바뀝니다.</li><li>똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다.</li></ul></li><li>미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다.<ul><li>1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다.</li><li>함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다.</li><li>2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다.</li><li>탈출에 성공했습니다. 총 이동시간은 5입니다.</li></ul></li></ul><p>방의 개수를 나타내는 정수 <code>n</code>, 출발 방의 번호 <code>start</code>, 도착 방의 번호 <code>end</code>, 통로와 이동시간을 나타내는 2차원 정수 배열 <code>roads</code>, 함정 방의 번호를 담은 정수 배열 <code>traps</code>이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요.</p><hr><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>2 ≤ <code>n</code> ≤ 1,000</li><li>1 ≤ <code>start</code> ≤ <code>n</code></li><li>1 ≤ <code>end</code> ≤ <code>n</code></li><li>1 ≤ <code>roads</code>의 행 길이 ≤ 3,000</li><li><code>roads</code>의 행은 [P, Q, S]로 이루어져 있습니다.<ul><li><code>P</code>에서 <code>Q</code>로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 <code>S</code>만큼 시간이 걸립니다.</li><li>1 ≤ <code>P</code> ≤ <code>n</code></li><li>1 ≤ <code>Q</code> ≤ <code>n</code></li><li><code>P</code> ≠ <code>Q</code></li><li>1 ≤ <code>S</code> ≤ 3,000</li><li>서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다.</li></ul></li><li>0 ≤ <code>traps</code>의 길이 ≤ 10<ul><li>1 ≤ <code>traps</code>의 원소 ≤ <code>n</code></li><li>시작 방과 도착 방은 함정이 아닙니다.</li></ul></li><li>항상 미로를 탈출할 수 있는 경우만 주어집니다.</li></ul><hr><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>n</th><th>start</th><th>end</th><th>roads</th><th>traps</th><th>result</th></tr></thead><tbody><tr><td>3</td><td>1</td><td>3</td><td>[[1, 2, 2], [3, 2, 3]]</td><td>[2]</td><td>5</td></tr><tr><td>4</td><td>1</td><td>4</td><td>[[1, 2, 1], [3, 2, 1], [2, 4, 1]]</td><td>[2, 3]</td><td>4</td></tr></tbody></table></div><hr><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>입출력 예 #1</p><p>문제 예시와 같습니다.</p><p>입출력 예 #2</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/c5ab2e6d-9872-42d1-9898-2890b69ce74e/MazeEx2.png" alt="MazeEx2.png"></p><p>1 → 2 → 3 → 2 → 4 순서로 이동하면 됩니다. 총 이동시간은 4입니다.</p><hr><h5 id="제한시간-안내"><a href="#제한시간-안내" class="headerlink" title="제한시간 안내"></a>제한시간 안내</h5><ul><li>정확성 테스트 : 10초</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, start, end, roads, traps</span>):</span></span><br><span class="line">    start -=<span class="number">1</span>; end -=<span class="number">1</span>;</span><br><span class="line">    INF = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>);</span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    trap_dict = &#123;trap-<span class="number">1</span>:idx <span class="keyword">for</span> idx, trap <span class="keyword">in</span> <span class="built_in">enumerate</span>(traps)&#125;;</span><br><span class="line">    nodes = [];</span><br><span class="line">    isVisit = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>&lt;&lt;<span class="built_in">len</span>(traps))]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> road <span class="keyword">in</span> roads:</span><br><span class="line">        start_i, end_i, cost = road</span><br><span class="line">        graph[start_i-<span class="number">1</span>].append([end_i-<span class="number">1</span>,cost,<span class="number">0</span>])</span><br><span class="line">        graph[end_i-<span class="number">1</span>].append([start_i-<span class="number">1</span>,cost,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    h.heappush(nodes,(<span class="number">0</span>,start,<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> nodes:</span><br><span class="line">        cur_time, cur_node, state = h.heappop(nodes);</span><br><span class="line">        <span class="keyword">if</span> cur_node == end : <span class="keyword">return</span> cur_time;      </span><br><span class="line">        <span class="keyword">if</span> isVisit[state][cur_node] == <span class="literal">True</span>: <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>: isVisit[state][cur_node] = <span class="literal">True</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> next_node, next_cost, road_type <span class="keyword">in</span> graph[cur_node]:</span><br><span class="line">            next_state = state</span><br><span class="line">            cur_isTrap = <span class="number">1</span> <span class="keyword">if</span> cur_node <span class="keyword">in</span> trap_dict <span class="keyword">else</span> <span class="number">0</span>;</span><br><span class="line">            next_isTrap = <span class="number">1</span> <span class="keyword">if</span> next_node <span class="keyword">in</span> trap_dict <span class="keyword">else</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> cur_isTrap == <span class="number">0</span> <span class="keyword">and</span> next_isTrap == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> road_type == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> (cur_isTrap + next_isTrap) == <span class="number">1</span>:</span><br><span class="line">                node_i = cur_node <span class="keyword">if</span> cur_isTrap == <span class="number">1</span> <span class="keyword">else</span> next_node</span><br><span class="line">                isTrapOn = (state &amp; (<span class="number">1</span>&lt;&lt;trap_dict[node_i]))&gt;&gt;trap_dict[node_i]</span><br><span class="line">                <span class="keyword">if</span> isTrapOn != road_type: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                isTrapOn = (state &amp; (<span class="number">1</span>&lt;&lt;trap_dict[cur_node]))&gt;&gt;trap_dict[cur_node]</span><br><span class="line">                n_isTrapOn = (state &amp; (<span class="number">1</span>&lt;&lt;trap_dict[next_node]))&gt;&gt;trap_dict[next_node]</span><br><span class="line">                <span class="keyword">if</span> (isTrapOn ^ n_isTrapOn) != road_type: <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> next_isTrap == <span class="number">1</span>:</span><br><span class="line">                next_state = state ^ (<span class="number">1</span>&lt;&lt;trap_dict[next_node])</span><br><span class="line"></span><br><span class="line">            h.heappush(nodes,(cur_time+next_cost, next_node, next_state))</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><hr><p><br/></p><h2 id="🗣-Trash-talk"><a href="#🗣-Trash-talk" class="headerlink" title="🗣 Trash talk"></a>🗣 Trash talk</h2><p><br/></p><p>상반기 카카오 인턴 코딩테스트에서 출제된 문제인데, 당시 5번과 더불어 나의 숨을 조여온 기억이 난다. 시험때 4, 5번을 건들지도 못했는데도 테스트에 통과했을 정도니 당시 시험을 본 사람 대부분이 나처럼 체감 난이도가 상당했을 것이다. 해당 문제의 해설은 <a href="https://tech.kakao.com/2021/07/08/2021-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4%EC%8B%AD-for-tech-developers-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%B4%EC%84%A4/">이곳</a> 에서 친절하게 알려주고 있다. 물론 풀이 코드는 제외하고 말이다.</p><p><br/></p><p><br/></p><h2 id="📌-풀이-전략-요약"><a href="#📌-풀이-전략-요약" class="headerlink" title="📌 풀이 전략 요약"></a>📌 풀이 전략 요약</h2><p><br/></p><ol><li><a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98"><strong>dijkstra</strong></a> 알고리즘을 이용하여 두 점 사이 경로를 찾는다.</li><li><code>bit mask</code>를 이용하여 함정 노드들의 발동 상태(ON / OFF)를 구분 한다.</li><li>방문 확인을 위한 <code>isVisit</code> 배열은 (함정 상태 경우의 수) x (전체 노드의 길이) 만큼의 길이를 갖는다.</li><li>이를 이용해 이미 지나온 노드도 다른 상태(전체 함정들의 발동 상태)라면 재방문이 가능하다.</li><li>heapq를 사용해 최단 거리 경로들부터 확인한다. 따라서 end에 도달하는 순간이 정답이 된다.</li><li>heapq에는 직전 노드의 상태 정보를 넘긴다. 이 때문에 현재 상태를 따로 저장하고 갱신할 필요가 없다.</li></ol><p><br/></p><p><br/></p><h2 id="🎲-풀이-설명-Python-기준"><a href="#🎲-풀이-설명-Python-기준" class="headerlink" title="🎲 풀이 설명 (Python 기준)"></a>🎲 풀이 설명 (Python 기준)</h2><p><br/></p><h3 id="1-초기화"><a href="#1-초기화" class="headerlink" title="1. 초기화"></a>1. 초기화</h3><p><br/></p><p><img alt="" src="/img/post_images/algorithm/programmers/kakaoMaze/maze3.png" width="90%" /></p><p><code>trap_dict</code>에는 함정들의 정보가 담긴다. </p><ul><li>key에는 함정인 노드의 번호를 할당한다.</li><li>value에는 각 함정의 순서를 할당한다.<ul><li>이는 비트마스크에서 각 함정을 뜻하는 자릿수로 사용된다.</li></ul></li></ul><p><br/></p><p><img alt="isVisit 변수" src="/img/post_images/algorithm/programmers/kakaoMaze/maze7.png" width="60%" style="margin: 1.0rem auto;display:block"/></p><p><br/></p><p><img alt="" src="/img/post_images/algorithm/programmers/kakaoMaze/maze1.png" width="80%"/></p><p><code>isVisit</code>은 <strong>dijkstra</strong>의 방문노드 구분을 위한 2차원 배열이다.</p><ul><li>첫 인덱스는 함정들의 고유 순서(자릿수)를 뜻한다.</li><li>두 번째 인덱스는 <code>node</code>번호를 뜻한다.</li><li>문제의 제한사항대로 함정 노드는 최대 10개다. </li><li>따라서 최대 <script type="math/tex">2^{10} = 1024</script>개의 함정 상태를 구분하면 된다. </li><li>함정 노드들의 상태 구분은 문제에서 주어진 traps의 길이를 시프트 연산하여 할당한다(첫 인덱스).</li></ul><p><br/></p><p><br/></p><p><img alt="함정 발동 전" src="/img/post_images/algorithm/programmers/kakaoMaze/maze6.png" width="70%" style="margin: 2.0em auto;display:block"/></p><p><img alt="함정 발동 후(연결된 간선들의 방향이 바뀐다)" src="/img/post_images/algorithm/programmers/kakaoMaze/maze13.png" width="70%" style="margin: 2.0em auto;display:block"/></p><p><br/></p><p>함정 상태의 <code>0</code>은 <strong>OFF</strong>, <code>1</code>은 <strong>ON</strong> 상태를 뜻한다.</p><p>만약 위처럼 함정 노드(빨간 테두리 노드)가 2개인 그래프라면, 구분해야할 함정의 길이는 <script type="math/tex">2^2 = 4</script>이므로 4의 길이를 할당하면 되고 이는 [<code>00</code>, <code>01</code>, <code>10</code>, <code>11</code>]의 상태를 뜻한다.</p><p><br/></p><p><br/></p><h3 id="2-간선정보-할당"><a href="#2-간선정보-할당" class="headerlink" title="2. 간선정보 할당"></a>2. 간선정보 할당</h3><p><br/></p><p><img src="/img/post_images/algorithm/programmers/kakaoMaze/maze4.png" width="70%"/></p><ul><li>간선들의 정보를 할당한다. 이때 <strong>정방향</strong>과 <strong>역방향</strong>을 구분하여 넣어준다.</li><li>append로 할당되는 배열은 [목적지 노드번호, 이동비용, <span style="color:orange"> 다리의 방향 </span> ] 이다. </li><li>start 노드에게는 정방향(<code>0</code>)인 다리를, end 노드에게는 역방향(<code>1</code>)인 다리를 각각 할당한다.</li></ul><p><br/></p><p><br/></p><h3 id="3-heapq의-사용"><a href="#3-heapq의-사용" class="headerlink" title="3. heapq의 사용"></a>3. heapq의 사용</h3><p><br/></p><p><code>heapq</code>에는 다음과 같은 3가지 정보를 담은 튜플이 담긴다.</p><p><code>next_time</code>: 해당 간선 이동시의 총 비용<br><code>next_node</code>: 간선 이동시 도착 노드<br><code>next_state</code>: 간선 이동 후 다음 노드 도착시 함정들의 상태</p><p><br/></p><p>Python의 <code>heapq</code> 라이브러리는 튜플의 첫 번째 값으로 우선순위를 할당한다. 따라서 총 이동 비용이 최소인 간선들부터 순차적으로 확인할 수 있고, 만약 end 노드에 도착하면 현재 비용이 정답이 된다.</p><p><img alt="heapq의 root노드" src="/img/post_images/algorithm/programmers/kakaoMaze/maze8.png" width="80%" style="margin: 2.0em auto;display:block"/></p><p><br/></p><p>위 예시에서 놓쳐서 안되는 사실은, <code>heapq</code>에는 아직 <code>1번노드 -&gt; 2번노드</code> 경로와 <code>1번노드 -&gt; 4번노드</code> 경로가 남아있다는 것이다. 마찬가지로 오른쪽 이동을 통해 <code>3번노드 -&gt; 1번노드</code>의 경로도 담기게 된다. 따라서 오른쪽 그림의 4번노드로 이동이 끝난 후 다음으로 <code>pop</code>되는 경로는 왼쪽 그림의 <code>1번노드 -&gt; 2번노드</code>가 된다.</p><p><br/></p><p><br/></p><h3 id="4-현재-노드-검사"><a href="#4-현재-노드-검사" class="headerlink" title="4. 현재 노드 검사"></a>4. 현재 노드 검사</h3><p><br/></p><p>이제 시작 노드를 <code>heapq</code>에 넣고 반복문을 시작한다.</p><ul><li>heappop으로 heapq의 root를 가져온다.<ul><li><code>cur_time</code>, <code>cur_node</code>, <code>state</code> 정보를 변수에 할당한다.</li></ul></li><li>현재 <code>pop</code>을 통해 가져온 정보는 이론상 최소거리의 간선과 도착 노드다.</li><li>만약 현재 도착 노드가 <code>end</code>면 현재 거리 비용을 리턴한다.</li><li>현재 노드의 상태(함정 <code>state</code>)를 확인하여 이미 방문한 노드라면 <code>continue</code> 한다.</li></ul><p><br/></p><p>아래 그림은 각 노드 방문시 <code>isVisit</code> 변수의 변화를 타나내는 예시다.  </p><p><img alt="00 state에서 함정노드 3으로 이동" src="/img/post_images/algorithm/programmers/kakaoMaze/maze10.png" width="70%" style="margin: 1.0rem auto;display:block"/></p><p><img alt="01 state에서 일반노드 1로 이동" src="/img/post_images/algorithm/programmers/kakaoMaze/maze11.png" width="70%" style="margin: 1.0rem auto;display:block"/></p><p><img alt="이동 후 상태" src="/img/post_images/algorithm/programmers/kakaoMaze/maze12.png" width="70%" style="margin: 1.0rem auto;display:block"/></p><p><br/></p><p>첫 그림과 마지막 그림에서 둘 다 1번 노드에 방문했지만, 이동할 때마다 <code>state</code>(bit mask)가 달랐기 때문에 <code>isVisit</code>에 할당된 값의 위치도 다르게 구별된다. 따라서 완전히 다른 노드에 방문한 것과 다르지 않다. 이런 메커니즘으로 함정의 발동 여부에 따라 재방문이 필요한 노드를 중복 없이 구별할 수 있다.</p><p><br/></p><p>현재 노드의 검사 단계에서 문제가 없으면 다음 간선과 도착 노드에 대한 검증을 시작한다.</p><p><br/></p><p><br/></p><h3 id="5-검증"><a href="#5-검증" class="headerlink" title="5. 검증"></a>5. 검증</h3><p><br/></p><p><code>graph</code>에서 현재 노드와 연결된 모든 간선을 불러와 다음과 같은 검증을 수행한다.</p><ul><li>현재 노드와 다음 노드의 종류(함정 여부) 파악</li><li>현재 상태(<code>state</code>) 파악</li><li>다음 간선의 종류(방향) 파악</li><li>이동후의 상태(<code>next_state</code>) 파악</li></ul><p>이는 현재 주어진 간선으로 <strong>다음 노드로의 이동이 가능한지</strong>, 가능하다면 이동 후 <strong>상태가 어떻게 바뀔지</strong> 알기 위해서 수행하는 작업들이다.</p><p><br/></p><p>현재 노드의 종류(일반, 함정)와 다음 노드의 종류(일반, 함정)에 따라 크게 4가지 경우의 수가 생긴다.</p><ol><li>일반노드 -&gt; 함정노드</li><li>함정노드 -&gt; 함정노드</li><li>함정노드 -&gt; 일반노드</li><li>일반노드 -&gt; 일반노드</li></ol><p>각 종류의 이동 패턴은 다음 그림과 같다.</p><p><img alt="4가지 이동패턴 (점선: 다음 이동 경로, 붉은선: 역방향 간선)" src="/img/post_images/algorithm/programmers/kakaoMaze/maze9.png" width="90%" style="margin: 2.0em auto;display:block"/></p><p><br/></p><p>이를 통해 다음과 같은 사실들을 알 수 있다.</p><ul><li><code>일반-&gt;일반</code> 이동이 가능하려면 간선이 반드시 <strong>정방향</strong>이어야 한다.</li><li><code>일반-&gt;함정</code> 혹은 <code>함정-&gt;일반</code> 이동시 다음 두 가지 상황에서 이동이 <strong>가능</strong>하다.<ul><li>함정이 발동한 상태에서 <strong>역방향</strong> 간선</li><li>함정이 발동하지 않은 상태에서 <strong>정방향</strong> 간선  </li></ul></li><li><code>함정-&gt;함정</code> 노드 이동시 다음 세 가지 상황에서 이동이 <strong>가능</strong>하다.<ul><li>두 함정 모두 발동되지 않은 상태에서 <strong>정방향</strong> 간선</li><li>두 함정 모두 발동된 상태에서 <strong>정방향</strong> 간선</li><li>한 함정만 발동된 상태에서 <strong>역방향</strong> 간선</li></ul></li></ul><p><br/></p><p>이는 다음과 같은 코드로 표현된다.</p><p><img src="/img/post_images/algorithm/programmers/kakaoMaze/maze5.png" alt=""></p><p><code>isTrapOn</code>은 현재의 상태(<code>state</code>)에 특정 함정의 시프트 연산(<code>&lt;&lt;</code>)과 end(<code>&amp;</code>) 연산을 통해 <strong>특정 함정이 작동되어 있는지</strong>를 나타낸다. 이를 통해 현재 불러온 간선을 통해 이동이 가능한지 판단할 수 있다.</p><p><br/></p><p><br/></p><h3 id="6-heappush"><a href="#6-heappush" class="headerlink" title="6. heappush"></a>6. heappush</h3><p><br/></p><p>여기까지 모두 통과하여 도착한다면 이는 다음과 같이 요약할 수 있다.</p><blockquote><p>[<span style="color:orange">heapq에서 꺼내온 최단거리 경로 노드</span>]에서 [<span style="color:orange">해당 노드와 연결된 모든 간선 중에 현재 선택된 간선</span>]으로 이동이 <strong>가능</strong>하다.</p></blockquote><p><br/></p><p>이제 마지막으로 이동이 가능한 경로를 다시 <code>heapq</code>에 넣으면 된다.</p><p>앞에서 <code>heapq</code>에 담겼던 내용은 <code>next_time, next_node, next_state</code>였다.</p><p>이제 이 세가지를 현재 선택된 간선을 기준으로 계산하면 된다.</p><p><code>next_time</code>: 현재 이동 비용 + 간선 이동 비용<br><code>next_node</code>: 간선 이동시 도착 노드<br><code>next_state</code>: 간선 이동 후 다음 노드 도착시 함정들의 상태</p><p><br/></p><p>다음 방문할 노드가 함정이 아니라면 현재 <code>state</code>를 넘긴다.</p><p>만약 다음 방문할 노드가 함정이라면, 다음 노드의 함정이 작동된 상태를 시프트연산을 통해 갱신하여 넘겨줘야 한다.</p><p><img alt="" src="/img/post_images/algorithm/programmers/kakaoMaze/maze2.png" width="90%" /></p><p>이로써 <code>heappush</code>의 과정마저 끝났고, <code>end</code>에 도착할때까지 위 과정을 반복하면 된다.</p><p><br/></p><p><br/></p><p>🔴 질문이나 개선이 필요한 부분 등 적극적인 피드백 환영! 🔴</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv4/">lv4</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4/">카카오</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4/">카카오 인턴</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/">최단거리</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/15/28bed7b50dc1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 표 편집</title>
      <link>https://sklubmk.github.io/2021/07/15/8f1c603962dc/</link>
      <guid>https://sklubmk.github.io/2021/07/15/8f1c603962dc/</guid>
      <pubDate>Wed, 14 Jul 2021 16:39:21 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;표-편집&quot;&gt;&lt;a href=&quot;#표-편집&quot; class=&quot;headerlink&quot; title=&quot;표 편집&quot;&gt;&lt;/a&gt;표 편집&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="표-편집"><a href="#표-편집" class="headerlink" title="표 편집"></a>표 편집</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]</p><p>업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d8e89054-53ba-4222-a485-dc56893f45e4/table_1.png" alt="table_1.png"></p><p>위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.</p><ul><li><code>&quot;U X&quot;</code>: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.</li><li><code>&quot;D X&quot;</code>: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.</li><li><code>&quot;C&quot;</code> : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.</li><li><code>&quot;Z&quot;</code> : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다.</li></ul><p>예를 들어 위 표에서 <code>&quot;D 2&quot;</code>를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, <code>&quot;C&quot;</code>를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 “네오”가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다).</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/453bbb71-df69-4be2-a223-67361878202c/table_2.png" alt="table_2.png"></p><p>다음으로 <code>&quot;U 3&quot;</code>을 수행한 다음 <code>&quot;C&quot;</code>를 수행한 후의 표 상태는 아래 그림과 같습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/61261fa2-701d-4db5-9aa2-a56dd85a3dbf/table_3.png" alt="table_3.png"></p><p>다음으로 <code>&quot;D 4&quot;</code>를 수행한 다음 <code>&quot;C&quot;</code>를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b1a63278-be97-4e3a-a653-5a6aa0f477ba/table_4.png" alt="table_4.png"></p><p>다음으로 <code>&quot;U 2&quot;</code>를 수행하면 현재 선택된 행은 2행이 됩니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b1189eff-e4ee-4119-bb55-a1f06e388c29/table_5.png" alt="table_5.png"></p><p>위 상태에서 <code>&quot;Z&quot;</code>를 수행할 경우 가장 최근에 제거된 <code>&quot;라이언&quot;</code>이 적힌 행이 원래대로 복구됩니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0a386d19-0391-46a7-8086-9f36db31940d/table_6.png" alt="table_6.png"></p><p>다시한번 <code>&quot;Z&quot;</code>를 수행하면 그 다음으로 최근에 제거된 <code>&quot;콘&quot;</code>이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요.\<br><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8900360f-bf0b-449b-a508-98918a14ef1d/table_7.png" alt="table_7.png"></p><p>이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 <code>&quot;O&quot;</code>, 삭제된 행은 <code>&quot;X&quot;</code>로 표시하면 다음과 같습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/87a31aeb-50fb-4c0d-9f6b-8427632b582e/table_8.png" alt="table_8.png"></p><p>처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요.</p><hr><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>5 ≤ <code>n</code> ≤ 1,000,000</li><li>0 ≤ <code>k</code> &lt; <code>n</code></li><li>1 ≤ <code>cmd</code>의 원소 개수 ≤ 200,000<ul><li><code>cmd</code>의 각 원소는 <code>&quot;U X&quot;</code>, <code>&quot;D X&quot;</code>, <code>&quot;C&quot;</code>, <code>&quot;Z&quot;</code> 중 하나입니다.</li><li>X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.</li><li>X가 나타내는 자연수에 ‘,’ 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.</li><li><code>cmd</code>에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.</li><li>표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.</li><li>본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 <code>&quot;이름&quot;</code> 열을 사용하였으나, <code>&quot;이름&quot;</code>열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. <code>&quot;이름&quot;</code>열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.</li></ul></li><li>표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.</li><li>원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) “Z”가 명령어로 주어지는 경우는 없습니다.</li><li>정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.</li></ul><h5 id="정확성-테스트-케이스-제한-사항"><a href="#정확성-테스트-케이스-제한-사항" class="headerlink" title="정확성 테스트 케이스 제한 사항"></a>정확성 테스트 케이스 제한 사항</h5><ul><li>5 ≤ <code>n</code> ≤ 1,000</li><li>1 ≤ <code>cmd</code>의 원소 개수 ≤ 1,000</li></ul><h5 id="효율성-테스트-케이스-제한-사항"><a href="#효율성-테스트-케이스-제한-사항" class="headerlink" title="효율성 테스트 케이스 제한 사항"></a>효율성 테스트 케이스 제한 사항</h5><ul><li>주어진 조건 외 추가 제한사항 없습니다.</li></ul><hr><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>n</th><th>k</th><th>cmd</th><th>result</th></tr></thead><tbody><tr><td>8</td><td>2</td><td><code>[&quot;D 2&quot;,&quot;C&quot;,&quot;U 3&quot;,&quot;C&quot;,&quot;D 4&quot;,&quot;C&quot;,&quot;U 2&quot;,&quot;Z&quot;,&quot;Z&quot;]</code></td><td><code>&quot;OOOOXOOO&quot;</code></td></tr><tr><td>8</td><td>2</td><td><code>[&quot;D 2&quot;,&quot;C&quot;,&quot;U 3&quot;,&quot;C&quot;,&quot;D 4&quot;,&quot;C&quot;,&quot;U 2&quot;,&quot;Z&quot;,&quot;Z&quot;,&quot;U 1&quot;,&quot;C&quot;]</code></td><td><code>&quot;OOXOXOOO&quot;</code></td></tr></tbody></table></div><hr><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>입출력 예 #1</p><p>문제의 예시와 같습니다.</p><p>입출력 예 #2</p><p>다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8900360f-bf0b-449b-a508-98918a14ef1d/table_7.png" alt="table_7.png"></p><p>10번째 명령어 <code>&quot;U 1&quot;</code>을 수행하면 <code>&quot;어피치&quot;</code>가 적힌 2행이 선택되며, 마지막 명령어 <code>&quot;C&quot;</code>를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 <code>&quot;제이지&quot;</code>가 적힌 행을 선택합니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/c9798574-4aa9-4029-901f-21f83fe43164/table_9.png" alt="table_9.png"></p><p>따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다.</p><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e7ba17b2-9461-4e92-8356-81cc90adb2ec/table_10.png" alt="table_10.png"></p><hr><h5 id="제한시간-안내"><a href="#제한시간-안내" class="headerlink" title="제한시간 안내"></a>제한시간 안내</h5><ul><li>정확성 테스트 : 10초</li><li>효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python-풀이-1"><a href="#python-풀이-1" class="headerlink" title="python 풀이 1"></a>python 풀이 1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, k, cmd</span>):</span></span><br><span class="line">    nodes = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nodes[i] = &#123;<span class="string">&#x27;U&#x27;</span>:i-<span class="number">1</span>, <span class="string">&#x27;D&#x27;</span>:i+<span class="number">1</span>, <span class="string">&#x27;O&#x27;</span>:<span class="literal">True</span>&#125;</span><br><span class="line">    removed = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">up</span>(<span class="params">cur, x</span>):</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> nodes[cur][<span class="string">&#x27;U&#x27;</span>] &gt; -<span class="number">1</span>:</span><br><span class="line">            cur = nodes[cur][<span class="string">&#x27;U&#x27;</span>]</span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span>(<span class="params">cur, x</span>):</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> nodes[cur][<span class="string">&#x27;D&#x27;</span>] &lt; n:</span><br><span class="line">            cur = nodes[cur][<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> nodes[x][<span class="string">&#x27;U&#x27;</span>] &gt; -<span class="number">1</span>:</span><br><span class="line">            nodes[nodes[x][<span class="string">&#x27;U&#x27;</span>]][<span class="string">&#x27;D&#x27;</span>] = nodes[x][<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nodes[x][<span class="string">&#x27;D&#x27;</span>] &lt; n:</span><br><span class="line">            nodes[nodes[x][<span class="string">&#x27;D&#x27;</span>]][<span class="string">&#x27;U&#x27;</span>] = nodes[x][<span class="string">&#x27;U&#x27;</span>]</span><br><span class="line">            cur = nodes[x][<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = nodes[x][<span class="string">&#x27;U&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        removed.append(x)</span><br><span class="line">        nodes[x][<span class="string">&#x27;O&#x27;</span>] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> cur        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upLink</span>(<span class="params">x, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur &lt; <span class="number">0</span> <span class="keyword">or</span> nodes[cur][<span class="string">&#x27;U&#x27;</span>] &lt; <span class="number">0</span> : <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> nodes[nodes[cur][<span class="string">&#x27;U&#x27;</span>]][<span class="string">&#x27;O&#x27;</span>] == <span class="literal">True</span>:</span><br><span class="line">            nodes[nodes[cur][<span class="string">&#x27;U&#x27;</span>]][<span class="string">&#x27;D&#x27;</span>] = x</span><br><span class="line">        <span class="keyword">else</span>: upLink(x, nodes[cur][<span class="string">&#x27;U&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">downLink</span>(<span class="params">x, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur &gt;= n <span class="keyword">or</span> nodes[cur][<span class="string">&#x27;D&#x27;</span>] &gt;= n: <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> nodes[nodes[cur][<span class="string">&#x27;D&#x27;</span>]][<span class="string">&#x27;O&#x27;</span>] == <span class="literal">True</span>:</span><br><span class="line">            nodes[nodes[cur][<span class="string">&#x27;D&#x27;</span>]][<span class="string">&#x27;U&#x27;</span>] = x</span><br><span class="line">        <span class="keyword">else</span>: downLink(x, nodes[cur][<span class="string">&#x27;D&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">x</span>):</span></span><br><span class="line">        upLink(x,x)</span><br><span class="line">        downLink(x,x)</span><br><span class="line">        nodes[x][<span class="string">&#x27;O&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cmd:</span><br><span class="line">        cs = c.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> cs[<span class="number">0</span>] == <span class="string">&#x27;U&#x27;</span>: k = up(k, <span class="built_in">int</span>(cs[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">elif</span> cs[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>: k = down(k, <span class="built_in">int</span>(cs[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">elif</span> cs[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>: k = remove(k)</span><br><span class="line">        <span class="keyword">else</span>: insert(removed.pop())</span><br><span class="line">    answer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        answer += <span class="string">&#x27;O&#x27;</span> <span class="keyword">if</span> nodes[i][<span class="string">&#x27;O&#x27;</span>] <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><h4 id="python-풀이-2"><a href="#python-풀이-2" class="headerlink" title="python 풀이 2"></a>python 풀이 2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n, k, cmd</span>):</span></span><br><span class="line">    removed = []</span><br><span class="line">    up = [i - <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">2</span>)]</span><br><span class="line">    down = [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">2</span>)]</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="keyword">if</span> c[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            removed.append(k)</span><br><span class="line">            up[down[k]] = up[k]</span><br><span class="line">            down[up[k]] = down[k]</span><br><span class="line">            k = up[k] <span class="keyword">if</span> n &lt; down[k] <span class="keyword">else</span> down[k]</span><br><span class="line">        <span class="keyword">elif</span> c[<span class="number">0</span>] == <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">            restore = removed.pop()</span><br><span class="line">            down[up[restore]] = restore</span><br><span class="line">            up[down[restore]] = restore</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action, num = c.split()</span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(num)):</span><br><span class="line">                    k = up[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(num)):</span><br><span class="line">                    k = down[k]</span><br><span class="line"></span><br><span class="line">    answer = [<span class="string">&#x27;O&#x27;</span>]*n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> removed:</span><br><span class="line">        answer[i-<span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(answer)</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>시험에서도, 시험 후 복기에서도 굉장히 애를 먹은 문제다.</p><p>우선 실제 시험 당시에는 linked-list의 구현을 포기하고 배열을 사용하여 제출했고, 나중에 프로그래머스에서 비슷한 풀이로 풀어본 결과 효율성 테케를 모두 틀렸다.</p><p>그 후 천천히 linked-list를 이용해 문제를 풀어보았는데, 첫 번째 풀이가 복잡하고 길어진 이유는 쓸데없이 노드의 고립을 고민해서다.</p><p><br/></p><p><img src="/img/post_images/algorithm/programmers/linkedList/L1.png" alt="시작 전"></p><p>예를들어 위처럼 5개의 linked list에서 2번노드, 3번노드, 1번노드를 차례대로 삭제하면 아래와 같은 과정이 된다.</p><p><br/></p><p><img src="/img/post_images/algorithm/programmers/linkedList/L2.png" alt="노드 2 삭제"></p><p><img src="/img/post_images/algorithm/programmers/linkedList/L3.png" alt="노드 3 삭제"></p><p><img src="/img/post_images/algorithm/programmers/linkedList/L4.png" alt="노드 1 삭제"></p><p>여기서 주목할 것은 2번 노드다. 2번노드는 자신이 링크(up, down)를 연결한 인접 노드 모두가 삭제 된 상황이다.</p><p><br/></p><p>이때, 2번 노드를 다시 복구하면 아래와 같은 상황이 발생한다.</p><p><img src="/img/post_images/algorithm/programmers/linkedList/L5.png" alt="노드 2 복구"></p><p>즉, 복구한 2번 노드는 완전히 고립되어 다른 살아있는 노드들과 연결될 수 없다.</p><p><br/></p><p>나는 이 오류를 고려하여 문제를 풀었고, 풀이 1에서는 On OFF를 나타내는 변수를 포함한 Dictionary를 활용했다. 하지만 이런 오류는 해당 문제에서는 일어날 수가 없었다. 애초에 문제에서 제시한 복구 기능은 마지막에 제거한 node를 살리는 것으로, 반드시 하나 이상의 살아있는 노드와 다시 연결된다. 만약 마지막으로 삭제된 노드를 복구한다는 제한사항이 없었다면 해당 방식의 풀이가 올바른 답이 될 것이다.</p><p><br/></p><p>그러나 이 문제에서는 고립 문제는 발생하지 않기 때문에 첫 번째 풀이는 다소 효율적이지 못한 코드가 되는 것이다. 이를 반영하여 풀이한 두번째 풀이에서는 복잡해지는 Dictionary를 사용하지 않고 up링크와 down링크 정보를 담은 두 배열을 사용해 문제를 풀었다. 이 때, 각각 머리 끝과 꼬리 끝을 가리키는 -1과 n+1 index를 포함한 n+2개의 배열을 초기화해서 사용했다. </p><p><br/></p><p>많은 시간을 들이며 고생했지만, 덕분에 제대로 링크드 리스트 유형의 연습을 할 수 있었다. 추후 링크드 리스트 문제를 마주쳤을 때 이 경험을 살려 문제를 돌파할 수 있을 것 같다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B5%AC%ED%98%84/">구현</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      <category domain="https://sklubmk.github.io/tags/linked-list/">linked list</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/15/8f1c603962dc/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 거리두기 확인하기</title>
      <link>https://sklubmk.github.io/2021/07/14/607c8167d984/</link>
      <guid>https://sklubmk.github.io/2021/07/14/607c8167d984/</guid>
      <pubDate>Tue, 13 Jul 2021 16:10:57 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;거리두기-확인하기&quot;&gt;&lt;a href=&quot;#거리두기-확인하기&quot; class=&quot;headerlink&quot; title=&quot;거리두기 확인하기&quot;&gt;&lt;/a&gt;거리두기 확인하기&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="거리두기-확인하기"><a href="#거리두기-확인하기" class="headerlink" title="거리두기 확인하기"></a>거리두기 확인하기</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.</p><p>코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼\<br>아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.</p><blockquote><ol><li>대기실은 5개이며, 각 대기실은 5x5 크기입니다.</li><li>거리두기를 위하여 응시자들 끼리는 맨해튼 거리<a href="https://programmers.co.kr/learn/courses/30/lessons/81302#fn1">1</a>가 2 이하로 앉지 말아 주세요.</li><li>단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.</li></ol></blockquote><p>예를 들어,</p><div class="table-container"><table><thead><tr><th><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8c056cac-ec8f-435c-a49a-8125df055c5e/PXP.png" alt="PXP.png"></th><th><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d611f66e-f9c4-4433-91ce-02887657fe7f/PX_XP.png" alt="PX_XP.png"></th><th><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ed707158-0511-457b-9e1a-7dbf34a776a5/PX_OP.png" alt="PX_OP.png"></th></tr></thead><tbody><tr><td>위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다.</td><td>위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다.</td><td>위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다.</td></tr><tr><td><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4c548421-1c32-4947-af9e-a45c61501bc4/P.png" alt="P.png"></td><td><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ce799a38-668a-4038-b32f-c515b8701262/O.png" alt="O.png"></td><td><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/91e8f98b-baeb-4f81-8cb6-5bafebebdcc7/X.png" alt="X.png"></td></tr><tr><td>응시자가 앉아있는 자리(<code>P</code>)를 의미합니다.</td><td>빈 테이블(<code>O</code>)을 의미합니다.</td><td>파티션(<code>X</code>)을 의미합니다.</td></tr></tbody></table></div><p>5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 <code>places</code>가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.</p><hr><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li><code>places</code>의 행 길이(대기실 개수) = 5<ul><li><code>places</code>의 각 행은 하나의 대기실 구조를 나타냅니다.</li></ul></li><li><code>places</code>의 열 길이(대기실 세로 길이) = 5</li><li><code>places</code>의 원소는 <code>P</code>,<code>O</code>,<code>X</code>로 이루어진 문자열입니다.<ul><li><code>places</code> 원소의 길이(대기실 가로 길이) = 5</li><li><code>P</code>는 응시자가 앉아있는 자리를 의미합니다.</li><li><code>O</code>는 빈 테이블을 의미합니다.</li><li><code>X</code>는 파티션을 의미합니다.</li></ul></li><li>입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다.</li><li>return 값 형식<ul><li>1차원 정수 배열에 5개의 원소를 담아서 return 합니다.</li><li><code>places</code>에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다.</li><li>각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.</li></ul></li></ul><hr><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>places</th><th>result</th></tr></thead><tbody><tr><td><code>[[&quot;POOOP&quot;, &quot;OXXOX&quot;, &quot;OPXPX&quot;, &quot;OOXOX&quot;, &quot;POXXP&quot;], [&quot;POOPX&quot;, &quot;OXPXP&quot;, &quot;PXXXO&quot;, &quot;OXXXO&quot;, &quot;OOOPP&quot;], [&quot;PXOPX&quot;, &quot;OXOXP&quot;, &quot;OXPOX&quot;, &quot;OXXOP&quot;, &quot;PXPOX&quot;], [&quot;OOOXX&quot;, &quot;XOOOX&quot;, &quot;OOOXX&quot;, &quot;OXOOX&quot;, &quot;OOOOO&quot;], [&quot;PXPXP&quot;, &quot;XPXPX&quot;, &quot;PXPXP&quot;, &quot;XPXPX&quot;, &quot;PXPXP&quot;]]</code></td><td>[1, 0, 1, 1, 1]</td></tr></tbody></table></div><hr><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>입출력 예 #1</p><p>첫 번째 대기실</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td>P</td><td>O</td><td>O</td><td>O</td><td>P</td></tr><tr><td>1</td><td>O</td><td>X</td><td>X</td><td>O</td><td>X</td></tr><tr><td>2</td><td>O</td><td>P</td><td>X</td><td>P</td><td>X</td></tr><tr><td>3</td><td>O</td><td>O</td><td>X</td><td>O</td><td>X</td></tr><tr><td>4</td><td>P</td><td>O</td><td>X</td><td>X</td><td>P</td></tr></tbody></table></div><ul><li>모든 응시자가 거리두기를 지키고 있습니다.</li></ul><p>두 번째 대기실</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td>P</td><td>O</td><td>O</td><td>P</td><td>X</td></tr><tr><td>1</td><td>O</td><td>X</td><td>P</td><td>X</td><td>P</td></tr><tr><td>2</td><td>P</td><td>X</td><td>X</td><td>X</td><td>O</td></tr><tr><td>3</td><td>O</td><td>X</td><td>X</td><td>X</td><td>O</td></tr><tr><td>4</td><td>O</td><td>O</td><td>O</td><td>P</td><td>P</td></tr></tbody></table></div><ul><li>(0, 0) 자리의 응시자와 (2, 0) 자리의 응시자가 거리두기를 지키고 있지 않습니다.</li><li>(1, 2) 자리의 응시자와 (0, 3) 자리의 응시자가 거리두기를 지키고 있지 않습니다.</li><li>(4, 3) 자리의 응시자와 (4, 4) 자리의 응시자가 거리두기를 지키고 있지 않습니다.</li></ul><p>세 번째 대기실</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td>P</td><td>X</td><td>O</td><td>P</td><td>X</td></tr><tr><td>1</td><td>O</td><td>X</td><td>O</td><td>X</td><td>P</td></tr><tr><td>2</td><td>O</td><td>X</td><td>P</td><td>O</td><td>X</td></tr><tr><td>3</td><td>O</td><td>X</td><td>X</td><td>O</td><td>P</td></tr><tr><td>4</td><td>P</td><td>X</td><td>P</td><td>O</td><td>X</td></tr></tbody></table></div><ul><li>모든 응시자가 거리두기를 지키고 있습니다.</li></ul><p>네 번째 대기실</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td>O</td><td>O</td><td>O</td><td>X</td><td>X</td></tr><tr><td>1</td><td>X</td><td>O</td><td>O</td><td>O</td><td>X</td></tr><tr><td>2</td><td>O</td><td>O</td><td>O</td><td>X</td><td>X</td></tr><tr><td>3</td><td>O</td><td>X</td><td>O</td><td>O</td><td>X</td></tr><tr><td>4</td><td>O</td><td>O</td><td>O</td><td>O</td><td>O</td></tr></tbody></table></div><ul><li>대기실에 응시자가 없으므로 거리두기를 지키고 있습니다.</li></ul><p>다섯 번째 대기실</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>No.</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>0</td><td>P</td><td>X</td><td>P</td><td>X</td><td>P</td></tr><tr><td>1</td><td>X</td><td>P</td><td>X</td><td>P</td><td>X</td></tr><tr><td>2</td><td>P</td><td>X</td><td>P</td><td>X</td><td>P</td></tr><tr><td>3</td><td>X</td><td>P</td><td>X</td><td>P</td><td>X</td></tr><tr><td>4</td><td>P</td><td>X</td><td>P</td><td>X</td><td>P</td></tr></tbody></table></div><ul><li>모든 응시자가 거리두기를 지키고 있습니다.</li></ul><p>두 번째 대기실을 제외한 모든 대기실에서 거리두기가 지켜지고 있으므로, 배열 [1, 0, 1, 1, 1]을 return 합니다.</p><hr><h5 id="제한시간-안내"><a href="#제한시간-안내" class="headerlink" title="제한시간 안내"></a>제한시간 안내</h5><ul><li>정확성 테스트 : 10초</li></ul><hr><ol><li>두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 입니다. <a href="https://programmers.co.kr/learn/courses/30/lessons/81302#fnref1">↩</a></li></ol></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">places</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    <span class="keyword">for</span> place <span class="keyword">in</span> places:</span><br><span class="line">        <span class="comment"># add person    </span></span><br><span class="line">        per = []    </span><br><span class="line">        <span class="keyword">for</span> row,t <span class="keyword">in</span> <span class="built_in">enumerate</span>(place):</span><br><span class="line">            <span class="keyword">for</span> col,p <span class="keyword">in</span> <span class="built_in">enumerate</span>(t):</span><br><span class="line">                <span class="keyword">if</span> p == <span class="string">&#x27;P&#x27;</span>: per.append([row,col])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">calcBetweenLength</span>(<span class="params">p1,p2</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) + <span class="built_in">abs</span>(p1[<span class="number">1</span>] - p2[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">calcIsRight</span>(<span class="params">arr_p</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(arr_p) &lt;= <span class="number">1</span> : <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            new_arr = arr_p[:]</span><br><span class="line">            cur = new_arr.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> new_arr:</span><br><span class="line">                c = calcBetweenLength(cur,p)</span><br><span class="line">                <span class="keyword">if</span> c == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> c == <span class="number">2</span>:</span><br><span class="line">                    min_r = <span class="built_in">min</span>(cur[<span class="number">0</span>],p[<span class="number">0</span>])</span><br><span class="line">                    min_c = <span class="built_in">min</span>(cur[<span class="number">1</span>],p[<span class="number">1</span>])</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> cur[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">and</span> place[min_r][min_c + <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>: <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> cur[<span class="number">1</span>] == p[<span class="number">1</span>] <span class="keyword">and</span> place[min_r + <span class="number">1</span>][min_c] == <span class="string">&#x27;X&#x27;</span>: <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> cur[<span class="number">0</span>] != p[<span class="number">0</span>] <span class="keyword">and</span> cur[<span class="number">1</span>] != p[<span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">if</span> place[min_r][min_c] == <span class="string">&#x27;P&#x27;</span> <span class="keyword">and</span> place[min_r+<span class="number">1</span>][min_c] == <span class="string">&#x27;X&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">                            place[min_r][min_c+<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>: <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">elif</span> place[min_r][min_c+<span class="number">1</span>] == <span class="string">&#x27;P&#x27;</span> <span class="keyword">and</span> place[min_r][min_c] == <span class="string">&#x27;X&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">                            place[min_r+<span class="number">1</span>][min_c+<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>: <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> calcIsRight(new_arr)</span><br><span class="line">          </span><br><span class="line">        answer.append(<span class="number">1</span> <span class="keyword">if</span> calcIsRight(per) <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>구현 능력을 묻는 카카오 인턴쉽 2번째 문제다.</p><p>지도가 주어지고, 이를 해석하며 풀어야하는 문제로 풀이 난이도 자체는 크게 어렵지 않으나 간단하게 풀리지 않는 경우가 많은 유형의 문제다.</p><p>따라서 문제의 요구사항에 집중하며 풀어야 하는데, 나는 이 문제를 bfs처럼 풀이했다.</p><p>우선 사람들의 위치만을 인식하여 per 배열에 담고, 이들 서로간의 거리를 계산하며 문제를 풀었다.</p><p>따라서 사람의 등장에 따라 효율성이 떨어질 수 있지만, 주어진 맵의 크기가 작아 크게 상관 없었다.</p><p>단순히 5x5 크기의 map을 돌며 풀 수 있는 풀이로 개선해봐야겠다.</p><p><br/></p><p>-&gt;  풀이 개선 추가<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">places</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    dx = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">    dy = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sol</span>(<span class="params">place</span>):</span></span><br><span class="line">        <span class="keyword">for</span> r, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(place):</span><br><span class="line">            <span class="keyword">for</span> c, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                <span class="keyword">if</span> p == <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">                        <span class="keyword">if</span> -<span class="number">1</span> &lt; r+dx[i] &lt; <span class="number">5</span> <span class="keyword">and</span> -<span class="number">1</span> &lt; c+dy[i] &lt; <span class="number">5</span> <span class="keyword">and</span> place[r+dx[i]][c+dy[i]] == <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">                            <span class="keyword">if</span> i &lt; <span class="number">2</span> : <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                            <span class="keyword">elif</span> i == <span class="number">2</span> <span class="keyword">and</span> (place[r+<span class="number">1</span>][c] != <span class="string">&#x27;X&#x27;</span> <span class="keyword">or</span> place[r][c+<span class="number">1</span>] != <span class="string">&#x27;X&#x27;</span>): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                            <span class="keyword">elif</span> i == <span class="number">3</span> <span class="keyword">and</span> place[r][c+<span class="number">1</span>] != <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                            <span class="keyword">elif</span> i == <span class="number">4</span> <span class="keyword">and</span> place[r+<span class="number">1</span>][c] != <span class="string">&#x27;X&#x27;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                            <span class="keyword">elif</span> i == <span class="number">5</span> <span class="keyword">and</span> (place[r][c-<span class="number">1</span>] != <span class="string">&#x27;X&#x27;</span> <span class="keyword">or</span> place[r+<span class="number">1</span>][c] != <span class="string">&#x27;X&#x27;</span>): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                            </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> places:</span><br><span class="line">        answer.append(sol(p))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B5%AC%ED%98%84/">구현</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4/">카카오</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/14/607c8167d984/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV1) 숫자 문자열과 영단어</title>
      <link>https://sklubmk.github.io/2021/07/13/1dd194db05c3/</link>
      <guid>https://sklubmk.github.io/2021/07/13/1dd194db05c3/</guid>
      <pubDate>Tue, 13 Jul 2021 14:56:35 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;숫자-문자열과-영단어&quot;&gt;&lt;a href=&quot;#숫자-문자열과-영단어&quot; class=&quot;headerlink&quot; title=&quot;숫자 문자열과 영단어&quot;&gt;&lt;/a&gt;숫자 문자열과 영단어&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="숫자-문자열과-영단어"><a href="#숫자-문자열과-영단어" class="headerlink" title="숫자 문자열과 영단어"></a>숫자 문자열과 영단어</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d31cb063-4025-4412-8cbc-6ac6909cf93e/img1.png" alt="img1.png"></p><p>네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다.</p><p>다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다.</p><ul><li>1478 → “one4seveneight”</li><li>234567 → “23four5six7”</li><li>10203 → “1zerotwozero3”</li></ul><p>이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 <code>s</code>가 매개변수로 주어집니다. <code>s</code>가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요.</p><p>참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다.</p><div class="table-container"><table><thead><tr><th>숫자</th><th>영단어</th></tr></thead><tbody><tr><td>0</td><td>zero</td></tr><tr><td>1</td><td>one</td></tr><tr><td>2</td><td>two</td></tr><tr><td>3</td><td>three</td></tr><tr><td>4</td><td>four</td></tr><tr><td>5</td><td>five</td></tr><tr><td>6</td><td>six</td></tr><tr><td>7</td><td>seven</td></tr><tr><td>8</td><td>eight</td></tr><tr><td>9</td><td>nine</td></tr></tbody></table></div><hr><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>1 ≤ <code>s</code>의 길이 ≤ 50</li><li><code>s</code>가 “zero” 또는 “0”으로 시작하는 경우는 주어지지 않습니다.</li><li>return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 <code>s</code>로 주어집니다.</li></ul><hr><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>s</th><th>result</th></tr></thead><tbody><tr><td><code>&quot;one4seveneight&quot;</code></td><td>1478</td></tr><tr><td><code>&quot;23four5six7&quot;</code></td><td>234567</td></tr><tr><td><code>&quot;2three45sixseven&quot;</code></td><td>234567</td></tr><tr><td><code>&quot;123&quot;</code></td><td>123</td></tr></tbody></table></div><hr><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>입출력 예 #1</p><ul><li>문제 예시와 같습니다.</li></ul><p>입출력 예 #2</p><ul><li>문제 예시와 같습니다.</li></ul><p>입출력 예 #3</p><ul><li>“three”는 3, “six”는 6, “seven”은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다.</li><li>입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다.</li></ul><p>입출력 예 #4</p><ul><li><code>s</code>에는 영단어로 바뀐 부분이 없습니다.</li></ul><hr><h5 id="제한시간-안내"><a href="#제한시간-안내" class="headerlink" title="제한시간 안내"></a>제한시간 안내</h5><ul><li>정확성 테스트 : 10초</li></ul></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">s</span>):</span></span><br><span class="line">    numbers = &#123;<span class="number">0</span>:<span class="string">&#x27;zero&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;one&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;two&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;three&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;four&#x27;</span>,<span class="number">5</span>:<span class="string">&#x27;five&#x27;</span>,<span class="number">6</span>:<span class="string">&#x27;six&#x27;</span>,<span class="number">7</span>:<span class="string">&#x27;seven&#x27;</span>,<span class="number">8</span>:<span class="string">&#x27;eight&#x27;</span>,<span class="number">9</span>:<span class="string">&#x27;nine&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> numbers.items():</span><br><span class="line">        s = s.replace(v,<span class="built_in">str</span>(k)) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>카카오 채용연계 인턴십에서 풀었던 첫 번째 문제.</p><p>문자열에서 영단어를 숫자로 변환하면 되는 간단한 문제다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4/">카카오</category>
      
      <category domain="https://sklubmk.github.io/tags/lv1/">lv1</category>
      
      <category domain="https://sklubmk.github.io/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/">문자열</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/13/1dd194db05c3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 더 맵게</title>
      <link>https://sklubmk.github.io/2021/07/13/32d615d6d313/</link>
      <guid>https://sklubmk.github.io/2021/07/13/32d615d6d313/</guid>
      <pubDate>Tue, 13 Jul 2021 14:29:55 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;더-맵게&quot;&gt;&lt;a href=&quot;#더-맵게&quot; class=&quot;headerlink&quot; title=&quot;더 맵게&quot;&gt;&lt;/a&gt;더 맵게&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="더-맵게"><a href="#더-맵게" class="headerlink" title="더 맵게"></a>더 맵게</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\<br>Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.</p><h5 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h5><ul><li>scoville의 길이는 2 이상 1,000,000 이하입니다.</li><li>K는 0 이상 1,000,000,000 이하입니다.</li><li>scoville의 원소는 각각 0 이상 1,000,000 이하입니다.</li><li>모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>scoville</th><th>K</th><th>return</th></tr></thead><tbody><tr><td>[1, 2, 3, 9, 10, 12]</td><td>7</td><td>2</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><ol><li><p>스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\<br>새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\<br>가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]</p></li><li><p>스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\<br>새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\<br>가진 음식의 스코빌 지수 = [13, 9, 10, 12]</p></li></ol><p>모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="keyword">as</span> h</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">scoville, K</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    h.heapify(scoville)</span><br><span class="line">    <span class="keyword">while</span> scoville[<span class="number">0</span>] &lt; K:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(scoville) == <span class="number">1</span>: <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">        v = h.heappop(scoville) + h.heappop(scoville) * <span class="number">2</span></span><br><span class="line">        h.heappush(scoville, v)</span><br><span class="line">        answer += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>heap을 사용하면 매우 간단히 풀 수 있는 문제다.</p><p>scoville 지수를 정렬한 뒤, 최소 값을 계산하여 이를 다시 갱신해야 한다.</p><p>이 때 heap 자료구조를 사용하면 빠르게 문제를 풀 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/heap/">heap</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/13/32d615d6d313/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV4) 도둑질</title>
      <link>https://sklubmk.github.io/2021/07/13/f77dc2a7284a/</link>
      <guid>https://sklubmk.github.io/2021/07/13/f77dc2a7284a/</guid>
      <pubDate>Mon, 12 Jul 2021 16:28:43 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;도둑질&quot;&gt;&lt;a href=&quot;#도둑질&quot; class=&quot;headerlink&quot; title=&quot;도둑질&quot;&gt;&lt;/a&gt;도둑질&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="도둑질"><a href="#도둑질" class="headerlink" title="도둑질"></a>도둑질</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.</p><p><img src="https://grepp-programmers.s3.amazonaws.com/files/ybm/e7dd4f51c3/a228c73d-1cbe-4d59-bb5d-833fd18d3382.png" alt="image.png"></p><p>각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.</p><p>각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.</li><li>money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>money</th><th>return</th></tr></thead><tbody><tr><td>[1, 2, 3, 1]</td><td>4</td></tr></tbody></table></div></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">money</span>):</span></span><br><span class="line"></span><br><span class="line">    f = [<span class="number">0</span>] * <span class="built_in">len</span>(money)</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = money[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(money)-<span class="number">1</span>):</span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i-<span class="number">2</span>] + money[i], f[i-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    s = [<span class="number">0</span>] * <span class="built_in">len</span>(money)</span><br><span class="line">    s[<span class="number">1</span>] = money[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(money)):</span><br><span class="line">        s[i] = <span class="built_in">max</span>(s[i-<span class="number">2</span>] + money[i], s[i-<span class="number">1</span>])        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f+s)</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>동적계획법(Dynamic Programming) 유형의 꽤나 깊은 생각을 요하는 문제다.</p><p>반복문을 돌며 현재 집을 기준으로 지난 집들의 최댓값을 누적시키는 것이 포인트다.</p><p>여기까지는 기본적인 DP의 유형을 따르지만, 첫 번째 집이 선택되는 경우와 그렇지 못한 경우에 따라 마지막 집을 선택할 수 있는지에대한 여부가 갈리기 때문에 이를 신경 쓰는 과정에서 다소 시간이 걸렸다.</p><p>또한, 직전 집의 최댓값을 바로 다음 인덱스의 집에서도 적용할 수 있다는 생각은 처음에 떠오르지 않았다.</p><p>몇 번의 시행착오를 거듭한 끝에 답을 구할 수 있었고, 아이러니하게도 풀이를 계속 고민할 수록 코드의 길이는 짧아졌다.</p><p>DP는 풀이에 도달하기 까지 깊은 생각을 요하지만, 막상 풀이는 매우 짧고 간결한 것 같다.</p><p>무언가 DP 유형의 문제를 풀면서 풀이가 지저분하게 길어지고 있다면, 현재 문제를 잘못 접근하고 있다는 생각을 할 필요가 있다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/lv4/">lv4</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/DP/">DP</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/13/f77dc2a7284a/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 등굣길</title>
      <link>https://sklubmk.github.io/2021/07/07/5a7de90493fd/</link>
      <guid>https://sklubmk.github.io/2021/07/07/5a7de90493fd/</guid>
      <pubDate>Tue, 06 Jul 2021 17:44:59 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;등굣길&quot;&gt;&lt;a href=&quot;#등굣길&quot; class=&quot;headerlink&quot; title=&quot;등굣길&quot;&gt;&lt;/a&gt;등굣길&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="등굣길"><a href="#등굣길" class="headerlink" title="등굣길"></a>등굣길</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.</p><p>아래 그림은 m = 4, n = 3 인 경우입니다.</p><p><img src="https://grepp-programmers.s3.amazonaws.com/files/ybm/056f54e618/f167a3bc-e140-4fa8-a8f8-326a99e0f567.png" alt="image0.png"></p><p>가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.</p><p>격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.<ul><li>m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.</li></ul></li><li>물에 잠긴 지역은 0개 이상 10개 이하입니다.</li><li>집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>m</th><th>n</th><th>puddles</th><th>return</th></tr></thead><tbody><tr><td>4</td><td>3</td><td>[[2, 2]]</td><td>4</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p><img src="https://grepp-programmers.s3.amazonaws.com/files/ybm/32c67958d5/729216f3-f305-4ad1-b3b0-04c2ba0b379a.png" alt="image1.png"></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">m, n, puddles</span>):</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    maps = [-<span class="number">1</span>]*(m*n)    </span><br><span class="line">    maps[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> puddles:</span><br><span class="line">        maps[(p[<span class="number">1</span>]-<span class="number">1</span>)*m + p[<span class="number">0</span>]-<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> maps[i+j*m] == <span class="number">0</span> <span class="keyword">or</span> (i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>) : <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">0</span> <span class="keyword">and</span> j != <span class="number">0</span> : maps[i+j*m] = maps[i+(j-<span class="number">1</span>)*m]</span><br><span class="line">            <span class="keyword">elif</span> i != <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span> : maps[i+j*m] = maps[i+j*m-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>: maps[i+j*m] = (maps[i+j*m-<span class="number">1</span>] + maps[i+(j-<span class="number">1</span>)*m]) % <span class="number">1000000007</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maps[m*n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>DP로 풀어야 효율성 케이스를 통과할 수 있는 문제다.</p><p>divide and conquer를 이용한 재귀함수로 아주 간단히 풀 수 있지만, 효율성에서 통과되지 못했다.</p><p>메모리를 활용한 DP 풀이로 다시 풀었을때도 몇가지 케이스를 계속 틀렸는데, 전체 맵을 1로 셋팅하고 i==0 이거나 j==0 인 경우를 무시하고 지나가서 였다. </p><p>그러다보니 i==0 이거나 j==0 에서 생긴 웅덩이 다음 길에서 1로 값이 세팅되어 있는 문제점이 있었다. 이를 해결하기 위해 다시 0부터 모든 인덱스를 탐색하며 풀이했다.</p><p>간단하게 DP의 핵심 개념을 연습하기 좋은 문제다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/DP/">DP</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/07/5a7de90493fd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) n진수 게임</title>
      <link>https://sklubmk.github.io/2021/07/07/fb634df71dff/</link>
      <guid>https://sklubmk.github.io/2021/07/07/fb634df71dff/</guid>
      <pubDate>Tue, 06 Jul 2021 17:44:59 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;N진수-게임&quot;&gt;&lt;a href=&quot;#N진수-게임&quot; class=&quot;headerlink&quot; title=&quot;N진수 게임&quot;&gt;&lt;/a&gt;N진수 게임&lt;/h1&gt;&lt;p&gt;JavaScript&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="N진수-게임"><a href="#N진수-게임" class="headerlink" title="N진수 게임"></a>N진수 게임</h1><p>JavaScript</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.</p><ol><li>숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.</li><li>10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.</li></ol><p>이렇게 게임을 진행할 경우,\<br><code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, ...</code>\<br>순으로 숫자를 말하면 된다.</p><p>한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는\<br><code>0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, ...</code>\<br>순으로 숫자를 말하면 된다.</p><p>이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.</p><h3 id="입력-형식"><a href="#입력-형식" class="headerlink" title="입력 형식"></a>입력 형식</h3><p>진법 <code>n</code>, 미리 구할 숫자의 갯수 <code>t</code>, 게임에 참가하는 인원 <code>m</code>, 튜브의 순서 <code>p</code> 가 주어진다.</p><ul><li>2 ≦ <code>n</code> ≦ 16</li><li>0 ＜ <code>t</code> ≦ 1000</li><li>2 ≦ <code>m</code> ≦ 100</li><li>1 ≦ <code>p</code> ≦ <code>m</code></li></ul><h3 id="출력-형식"><a href="#출력-형식" class="headerlink" title="출력 형식"></a>출력 형식</h3><p>튜브가 말해야 하는 숫자 <code>t</code>개를 공백 없이 차례대로 나타낸 문자열. 단, <code>10</code>~<code>15</code>는 각각 대문자 <code>A</code>~<code>F</code>로 출력한다.</p><h3 id="입출력-예제"><a href="#입출력-예제" class="headerlink" title="입출력 예제"></a>입출력 예제</h3><div class="table-container"><table><thead><tr><th>n</th><th>t</th><th>m</th><th>p</th><th>result</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>2</td><td>1</td><td>“0111”</td></tr><tr><td>16</td><td>16</td><td>2</td><td>1</td><td>“02468ACE11111111”</td></tr><tr><td>16</td><td>16</td><td>2</td><td>2</td><td>“13579BDF01234567”</td></tr></tbody></table></div><p><a href="http://tech.kakao.com/2017/11/14/kakao-blind-recruitment-round-3/">해설 보러가기</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n, t, m, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> number_char = &#123;<span class="string">&#x27;10&#x27;</span>:<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;11&#x27;</span>:<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;12&#x27;</span>:<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;13&#x27;</span>:<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;14&#x27;</span>:<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;15&#x27;</span>:<span class="string">&#x27;F&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">const</span> setChange = <span class="function">(<span class="params">v, N</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(v === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> buffer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span>(v &gt; <span class="number">0</span>)&#123;            </span><br><span class="line">            <span class="keyword">let</span> d = <span class="built_in">Math</span>.floor(v/N);</span><br><span class="line">            <span class="keyword">let</span> r = v % N;</span><br><span class="line">            v = d;</span><br><span class="line">            buffer += (r &lt; <span class="number">10</span> ? r : number_char[r+<span class="string">&#x27;&#x27;</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> buffer.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> answer = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> calc_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> totalWords = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(answer.length &lt; t)&#123;</span><br><span class="line">        <span class="keyword">while</span>(totalWords.length &lt; m*i+p )&#123;</span><br><span class="line">            totalWords += setChange(calc_number,n)</span><br><span class="line">            calc_number++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        answer += totalWords[m*i+p-<span class="number">1</span>]</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>가장 최근 본 코딩 테스트에서, 진법의 구현 문제가 나왔다.<br>언어에서 제공하는 함수들이 아니라 직접 N진법을 구현해야 했다.</p><p>그런데 오늘 우연히 고른 이 문제가 진법 구현을 다루고 있어 놀랐다.<br>이 문제 또한 N진법의 구현이 기본으로 시작된다.</p><p><code>javascript</code>는 <code>toString(N)</code>으로, <code>python</code>은 <code>bin</code>과 <code>hex</code> 함수로 진법을 쉽게 구현할 수 있다.<br>하지만 이런 문제를 통해 구현 능력을 연습해야 하기 때문에 다시 한 번 나는 N진법을 직접 구현해서 사용했다.</p><p><br/></p><p>이렇게 변환한 진법 값을 통해 전체 리스트에서 ‘튜브’가 뽑을 순서의 값을 반환하면 되는데,<br>순서는 규칙적으로 m(플레이 인원)번마다 돌아온다.</p><p>여기에 시작순서 p를 더해서, m*i + p의 값이 전체 리스트에서 튜브가 뽑아야할 값이 된다.</p><p><br/></p><p>그렇다면 전체 리스트는 어디까지 구해놔야 할까?   </p><p>나는 튜브가 뽑아야할 순서의 길이보다 작으면 새로 값을 붙여나가는 식으로 구현했고,<br>이 편이 메모리 낭비가 없는 방법이다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B5%AC%ED%98%84/">구현</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://sklubmk.github.io/tags/N%EC%A7%84%EB%B2%95/">N진법</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/07/fb634df71dff/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[CSS] rem과 em의 차이</title>
      <link>https://sklubmk.github.io/2021/07/07/f55f1052709b/</link>
      <guid>https://sklubmk.github.io/2021/07/07/f55f1052709b/</guid>
      <pubDate>Tue, 06 Jul 2021 17:44:59 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;💡-tl-dr&quot;&gt;&lt;a href=&quot;#💡-tl-dr&quot; class=&quot;headerlink&quot; title=&quot;💡 tl;dr&quot;&gt;&lt;/a&gt;💡 tl;dr&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;CSS의 &lt;code&gt;em&lt;/code&gt;과 &lt;code&gt;rem&lt;/code&gt; 단위의 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;em&lt;/code&gt;과 &lt;code&gt;rem&lt;/code&gt;의 차이점 및 활용&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="💡-tl-dr"><a href="#💡-tl-dr" class="headerlink" title="💡 tl;dr"></a>💡 tl;dr</h1><hr><ul><li>CSS의 <code>em</code>과 <code>rem</code> 단위의 정의</li><li><code>em</code>과 <code>rem</code>의 차이점 및 활용</li></ul><span id="more"></span><p><br/></p><h1 id="em과-rem은-무엇인가"><a href="#em과-rem은-무엇인가" class="headerlink" title="em과 rem은 무엇인가?"></a>em과 rem은 무엇인가?</h1><hr><ul><li><code>em</code>과 <code>rem</code> 모두 길이가 유연한 <strong>가변 단위</strong>로 크기 지정시 어디에나 사용 가능하다.</li><li>디자인에 설정된 <strong>폰트 크기</strong>에 따라 브라우저에 의해 <strong>픽셀</strong>값으로 변환된다.</li><li><code>px</code>값은 브라우저에서 절댓값으로 인식한다</li></ul><p><br/></p><div style="margin: 0.5rem auto;display: block; width: 80%"><img alt="([.sixteen] font-size: 16px) CSS 패딩에 1em을 지정" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435114283015.png" /><br/><img alt="padding: 16px로 변환" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435114311948.png"><br/><img alt="([.onesixty] font-size: 160px) CSS 패딩에 1em을 지정" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435114317164.png"><br/><img alt="padding: 160px로 변환" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435114322763.png"></div><p><br/></p><p><br/></p><h1 id="em과-rem의-차이점"><a href="#em과-rem의-차이점" class="headerlink" title="em과 rem의 차이점"></a>em과 rem의 차이점</h1><hr><p>차이점을 알아보기 전에 <code>em</code>과 <code>rem</code>이 실제 어떻게 적용되는지 알아야 한다. </p><p><br/></p><h2 id="어떻게-rem-단위가-픽셀-Pixel-값으로-변환되나"><a href="#어떻게-rem-단위가-픽셀-Pixel-값으로-변환되나" class="headerlink" title="어떻게 rem 단위가 픽셀(Pixel)값으로 변환되나"></a>어떻게 rem 단위가 픽셀(Pixel)값으로 변환되나</h2><ul><li><code>rem</code> 단위로 변환된 픽셀 크기는 페이지 <U>최상위(root) 요소</U>(<code>html</code> 요소)의 <strong>폰트 크기</strong>가 기준이 된다. </li><li>이 최상위 요소의 폰트 크기에 <code>rem</code> 단위로 지정한 숫자를 곱한 값이 마지막 변환된 값이 된다.</li></ul><p><br/></p><div style="margin: 0.5rem auto;display: block; width: 80%"><img alt="([html] font-size: 16px) CSS 패딩에 10rem을 지정하면" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435115208123.png" /><br/><img alt="padding: 160px로 변환" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435115219699.png"></div><p><br/></p><h2 id="em-단위가-픽셀값으로-변환되는-공식"><a href="#em-단위가-픽셀값으로-변환되는-공식" class="headerlink" title="em 단위가 픽셀값으로 변환되는 공식"></a>em 단위가 픽셀값으로 변환되는 공식</h2><ul><li><code>em</code> 단위의 픽셀값은 <U>스타일을 지정한 요소</U>의 <strong>폰트 크기</strong>를 곱한 값이 된다.</li></ul><p><br/> </p><div style="margin: 0.5rem auto;display: block; width: 80%"><img alt="([div] font-size: 18px) CSS 패딩에 10em을 지정하면" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435116006260.png" /><br/><img alt="padding: 180px로 변환(혹은 근사값)" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435116020241.png"></div><p><br/></p><h3 id="em-요소의-중요-사항"><a href="#em-요소의-중요-사항" class="headerlink" title="[em 요소의 중요 사항]"></a>[em 요소의 중요 사항]</h3><ul><li><code>em</code> 단위가 <U>상위 요소</U>의 폰트 크기와 직접 연관되어 있다고 <strong>잘못</strong> 알려져 있다. </li><li>W3 명세서의 의하면 <U>실제 사용된 요소</U>의 폰트 크기와 직접 연관되어 있다.</li><li>상위 요소의 폰트 크기가 em 값에 영향을 줄 수는 있지만, 이는 오로지 스타일 상속 때문이다.</li></ul><p><br/></p><p><br/></p><h2 id="em-단위에-미치는-스타일-상속의-영향"><a href="#em-단위에-미치는-스타일-상속의-영향" class="headerlink" title="em 단위에 미치는 스타일 상속의 영향"></a>em 단위에 미치는 스타일 상속의 영향</h2><hr><ul><li>모든 요소는 상위 요소로부터 폰트 크기를 상속 받기 때문에 <code>em</code> 단위 계산이 복잡할 수 있다.</li><li>보통 <code>em</code> 단위가 사용된 요소는 어떤 상위 요소로부터 폰트 크기를 상속 받았는지 알기 힘들다.</li><li>이런 복잡함을 피하려면 오로지 폰트 크기로 <code>px</code> 혹은 <code>vw</code>와 같이 상속에 영향을 받지 않는 단위를 일일이 지정해야 한다.</li></ul><p><br/></p><h2 id="em-상속의-예"><a href="#em-상속의-예" class="headerlink" title="em 상속의 예"></a>em 상속의 예</h2><div class="clean">[HTML]<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;upper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lower&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ?? padding size ?? --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br/>[STYLUS]<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.upper</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25em</span></span><br><span class="line"><span class="selector-class">.lower</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1.5em</span></span><br></pre></td></tr></table></figure></div><ul><li><p>최상위 요소(<code>html</code>)의 font 값(default) : <code>16px</code></p></li><li><p><code>upper</code> class <code>div</code>의 font-size 계산 : <code>16px</code> x <code>1.25</code> = <code>20px</code></p></li><li><p><code>lower</code> class <code>div</code>의 padding 계산 : <code>16px</code> x <code>1.25</code> x <code>1.5</code> = <code>30px</code>  </p></li></ul><p><br/></p><h3 id="lower-div에-font-size-em-추가"><a href="#lower-div에-font-size-em-추가" class="headerlink" title="[lower div에 font-size(em) 추가]"></a>[lower div에 font-size(em) 추가]</h3><div class="clean">[STYLUS]<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.upper</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25em</span></span><br><span class="line"><span class="selector-class">.lower</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1.5em</span></span><br></pre></td></tr></table></figure></div><ul><li><code>lower</code> class <code>div</code>의 padding 계산 : <code>16px</code> x <code>1.25</code> x <code>1.5</code> x <code>1.2</code> = <code>36px</code></li><li>상위 요소가 더 많아질수록 계산은 복잡해진다.</li></ul><p><br/></p><h3 id="lower-div에-font-size-px-추가"><a href="#lower-div에-font-size-px-추가" class="headerlink" title="[lower div에 font-size(px) 추가]"></a>[lower div에 font-size(px) 추가]</h3><div class="clean">[STYLUS]<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.upper</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.25em</span></span><br><span class="line"><span class="selector-class">.lower</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1.5em</span></span><br></pre></td></tr></table></figure></div><ul><li><code>lower</code> class <code>div</code>의 padding 계산 : <code>1.5</code> x <code>14px</code> = <code>21px</code></li><li><code>px</code>단위를 명시하면 상위 요소 상속을 걱정하지 않아도 된다.</li></ul><p><br/></p><p><br/></p><h2 id="브라우저-설정이-HTML-요소의-폰트-크기에-미치는-영향"><a href="#브라우저-설정이-HTML-요소의-폰트-크기에-미치는-영향" class="headerlink" title="브라우저 설정이 HTML 요소의 폰트 크기에 미치는 영향"></a>브라우저 설정이 HTML 요소의 폰트 크기에 미치는 영향</h2><ul><li>기본적으로 브라우저의 폰트 크기는 보통 16px로 설정되어 있다. </li><li>사용자에 의해 최소 9px부터 72px까지 변경될 수 있다.</li></ul><p><img src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435122258785.png" alt="브라우저의 font 크기 설정"></p><p><br/></p><h3 id="중요-사항"><a href="#중요-사항" class="headerlink" title="[중요 사항]"></a>[중요 사항]</h3><ul><li><p><code>html</code>요소의 폰트 크기는 고정값을 지정하지 않았다면 브라우저에 설정된 값을 상속받는다.</p></li><li><p><code>html</code>요소에 지정된 폰트 크기가 직접 <code>rem</code>값을 결정짓기도 하지만, 브라우저 설정값에서 전해졌을 수도 있다.</p></li><li><p>브라우저에 지정된 폰트 크기 설정값은 디자인에 사용된 모든 <code>rem</code> 단위의 값에 영향을 주며, 상속의 영향을 받는 모든 <code>em</code> 단위도 마찬가지다.</p></li></ul><p><br/></p><h3 id="브라우저-설정이-em-단위로-설정된-HTML-폰트-크기에-미치는-영향"><a href="#브라우저-설정이-em-단위로-설정된-HTML-폰트-크기에-미치는-영향" class="headerlink" title="[브라우저 설정이 em 단위로 설정된 HTML 폰트 크기에 미치는 영향]"></a>[브라우저 설정이 em 단위로 설정된 HTML 폰트 크기에 미치는 영향]</h3><ul><li><p><code>html</code>요소에 <code>em</code>기반의 폰트 크기를 지정했다면, 변환된 픽셀값은 <U>브라우저</U>에 지정된 폰트 크기의 배수가 된다.</p></li><li><p>만약 <code>html</code> 요소의 font-size 값이 <code>1.25em</code>로 지정되었다면, 최상위 요소의 폰트 크기는 브라우저에 설정된 폰트 크기의 1.25배가 된다.</p></li><li><p>이때 브라우저의 폰트 크기가 <code>16px</code>로 설정되어 있다면, 최상위 요소의 폰트 크기는 <code>20px</code>이 된다.  </p><ul><li>계산 : (1.25 x 16 = 20)</li></ul></li></ul><p><br/></p><h2 id="em과-rem-사이의-차이점-요약"><a href="#em과-rem-사이의-차이점-요약" class="headerlink" title="em과 rem 사이의 차이점 요약"></a>em과 rem 사이의 차이점 요약</h2><ul><li><p><code>rem</code>단위의 픽셀값 변환은 <code>html</code>요소의 폰트 크기에 따라 결정된다. 또 이 폰트 크기는 상속에 구애를 받지 않는 <U>절대 단위</U>를 지정해서 직접 덮어씌우지 않았다면, <strong>브라우저</strong>에 설정된 폰트 크기를 그대로 상속받게 된다.</p></li><li><p><code>em</code> 단위의 픽셀값 변환은 사용된 요소의 폰트 크기에 따라 결정된다. 이 폰트 크기 또한 상속에 구애를 받지 않는 <U>절대 단위</U>를 가지고 명시적으로 덮어씌우지 않았다면, <strong>상위 요소</strong>로부터 상속의 영향을 받는다.</p></li></ul><p><br/></p><p><br/></p><h1 id="왜-rem-단위를-써야-하는가"><a href="#왜-rem-단위를-써야-하는가" class="headerlink" title="왜 rem 단위를 써야 하는가"></a>왜 rem 단위를 써야 하는가</h1><hr><ul><li>요소의 상속 특성에 상관없이 일관된 크기를 돌려준다.</li><li>사용자가 설정한 폰트 크기에 따라 사이트에 배치된 모든 구성 요소가 적절하게 반응하는 길을 제공한다.  <ul><li>브라우저의 기본 폰트 크기 설정에따라 가변 텍스트 요소를 활용하여 사이트 레이아웃을 구성할 수 있다.</li></ul></li></ul><p><br/></p><p><img style="margin: 0.5rem auto;display: block; width: 80%" alt="16px 크기의 브라우저 폰트" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435127178843.png" /></p><p><br/></p><p><img style="margin: 0.5rem auto;display: block; width: 80%" alt="rem 단위를 쓰면 폰트 크기를 늘리거나 줄여도 레이아웃은 보전됨" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=600/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435127198166.png" /></p><p><br/></p><ul><li><code>rem</code>기반 레이아웃에서 <code>html</code>요소의 font-size로 고정된 <code>px</code>단위를 지정하는 것은 피해야 한다. </li><li>이는 사용자가 브라우저에 설정해 놓은 폰트 크기를 완전히 무시하게 만드는 일이다.</li><li><code>html</code> 요소의 폰트 크기를 바꾸고 싶다면 <code>em</code>이나 <code>rem</code>으로 지정해야 브라우저 폰트 비율이 유지된다.</li></ul><p><br/></p><p><br/></p><h1 id="왜-em-단위를-써야-하는가"><a href="#왜-em-단위를-써야-하는가" class="headerlink" title="왜 em 단위를 써야 하는가"></a>왜 em 단위를 써야 하는가</h1><hr><ul><li><code>html</code> 요소 말고도 다른 요소의 폰트 크기에 따라 변하는 특성이 있다.</li><li>디자인 요소가 지닌 특별한 상황에 따라 변동성이 요구될 때 사용하면 좋다.</li></ul><p>그러나 <code>em</code> 단위의 변동 상황을 늘 관리하기 힘드므로 꼭 필요할 때만 사용해야 한다.</p><p><br/></p><p><img style="margin: 0.5rem auto;display: block; width: 80%" alt="padding, margin, line-height에 em 사용" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=634/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435131685900.png" /></p><p><img style="margin: 0.5rem auto;display: block; width: 80%" alt="폰트 크기가 변해도 레이아웃에게 영향을 끼치지 않는다" src="https://cms-assets.tutsplus.com/cdn-cgi/image/width=634/uploads%2Fusers%2F53%2Fposts%2F23984%2Fimage-1435131700125.png" /></p><p><br/></p><p><br/></p><h1 id="실제-활용"><a href="#실제-활용" class="headerlink" title="실제 활용"></a>실제 활용</h1><hr><h2 id="em-단위를-써야할-때"><a href="#em-단위를-써야할-때" class="headerlink" title="em 단위를 써야할 때"></a>em 단위를 써야할 때</h2><ul><li>최상위 요소를 제외한 특정 요소의 font-size를 기준으로 그 크기가 바뀌어야 하는 곳.</li><li>어느 한 요소의 크기를 정할 때 해당 요소가 기본 폰트 크기로 지정되어 있지 않았을 때.</li><li><code>em</code> 사용시 상속에 따른 애매한 상황을 피하고 크기가 대칭적으로 변할 수 있도록, 지정한 요소의 폰트 크기는 <code>rem</code> 단위를 사용해야 한다.</li></ul><p>웬만하면 폰트 크기로 <code>em</code> 단위의 사용은 피하자.<br>보통 <code>rem</code> 단위를 쓰면 디자인을 관리하기에 더 편하다.</p><p><br/></p><h2 id="rem-단위를-써야할-때"><a href="#rem-단위를-써야할-때" class="headerlink" title="rem 단위를 써야할 때"></a>rem 단위를 써야할 때</h2><ul><li><code>em</code> 사용 예시를 제외하고, 브라우저에 설정된 폰트 크기에 따라 그 크기가 변해야 하는 모든 곳.</li><li>일반 높이, 너비, 패딩, 마진, 테두리 너비, 대부분의 폰트 크기, 그림자 등등 기본적으로 레이아웃의 모든 부분이 해당.</li></ul><p>한 마디로, 크기가 변해야 하는 곳이라면 rem 단위를 쓰는게 좋다.</p><p><br/></p><h2 id="em과-rem-모두-쓰지-말아야-하는-곳"><a href="#em과-rem-모두-쓰지-말아야-하는-곳" class="headerlink" title="em과 rem 모두 쓰지 말아야 하는 곳:"></a>em과 rem 모두 쓰지 말아야 하는 곳:</h2><h3 id="다중-칼럼-레이아웃의-너비"><a href="#다중-칼럼-레이아웃의-너비" class="headerlink" title="[다중 칼럼 레이아웃의 너비]"></a>[다중 칼럼 레이아웃의 너비]</h3><ul><li>레이아웃의 다중 칼럼은 보통 <code>%</code>기반의 단위를 써서 예상치 못한 화면 크기에도 유동적으로 반응할 수 있도록 해야 한다다.</li><li>칼럼이 하나일 경우에도 일반적으로 <code>max-width</code>에 <code>rem</code> 값을 지정해 놓아도 원만히 작동한다.</li></ul><p><br/></p><ul><li>예시</li></ul><div class="clean"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">75rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>이렇게 하면 칼럼의 크기는 유동적으로 변하지만, 동시에 그 안에 있는 글이 읽기 불편할 정도로 너무 넓어지는 것도 막을 수 있다.</p><p><br/></p><h3 id="요소의-크기가-절대-변하면-안-되는-상황일-때"><a href="#요소의-크기가-절대-변하면-안-되는-상황일-때" class="headerlink" title="[요소의 크기가 절대 변하면 안 되는 상황일 때]"></a>[요소의 크기가 절대 변하면 안 되는 상황일 때]</h3><ul><li>간혹 크기가 변하는 것을 막기 위해 고정된 값을 지정해야 하는 상황.</li><li>해당 요소의 크기가 변할 경우 레이아웃이 망가져 버릴 때.</li></ul><p>하지만 이런 경우는 별로 없으므로, <code>px</code> 단위를 꺼내 들기 전에 정말로 필요한 것인지 한 번 더 검토해 봐야 한다.</p><p><br/></p><p><br/></p><h1 id="총정리"><a href="#총정리" class="headerlink" title="총정리"></a>총정리</h1><hr><ul><li>디자인에 쓰인 <code>rem</code>과 <code>em</code> 단위는 폰트 크기를 기준으로 브라우저에 의해 픽셀값으로 변환된다.</li><li><code>em</code> 단위는 지정된 요소의 폰트 크기를 기준으로 한다.</li><li><code>rem</code> 단위는 <code>html</code> 요소의 폰트 크기를 기준으로 한다.</li><li><code>em</code> 단위는 모든 상위 부모 요소로부터의 폰트 크기를 상속받으면서 영향을 받을 수 있다.</li><li><p><code>rem</code> 단위는 브라우저에 설정된 폰트 크기를 상속받는 특성이 있다.</p></li><li><p><code>em</code> 단위는 최상위 요소에 지정된 폰트 크기 말고, 다른 특정 요소의 폰트 크기에 따라 그 크기가 변해야 하는 곳에 사용.</p></li><li><code>rem</code> 단위는 <code>em</code> 단위를 쓸 필요가 없고, 또 브라우저의 폰트 크기 설정에 따라 그 크기가 변해야 하는 곳에 사용.</li><li>폰트 크기 지정을 비롯해서 꼭 <code>em</code> 단위를 써야 하는 곳이 아니라면 <code>rem</code> 단위를 사용.</li><li>다중 칼럼 레이아웃의 너비에는 <code>em</code> 이나 <code>rem</code> 말고 <code>%</code>를 써야한다.</li><li>만약에 크기가 변할 경우 해당 요소의 레이아웃이 깨지는 걸 막을 수 없다면 <code>em</code>과 <code>rem</code> 모두 쓰면 안된다.</li></ul><p><br/></p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><p>해당 글은 <a href="https://webdesign.tutsplus.com/ko/tutorials/comprehensive-guide-when-to-use-em-vs-rem--cms-23984">“종합 안내: Rem 그리고 Em, 언제 써야 할까”</a>를 다시 요약한 글입니다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/css/">css</category>
      
      
      <category domain="https://sklubmk.github.io/tags/css/">css</category>
      
      <category domain="https://sklubmk.github.io/tags/res/">res</category>
      
      <category domain="https://sklubmk.github.io/tags/em/">em</category>
      
      <category domain="https://sklubmk.github.io/tags/px/">px</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/07/f55f1052709b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) 정수 삼각형</title>
      <link>https://sklubmk.github.io/2021/07/06/05ad696d31a2/</link>
      <guid>https://sklubmk.github.io/2021/07/06/05ad696d31a2/</guid>
      <pubDate>Mon, 05 Jul 2021 15:23:14 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;정수-삼각형&quot;&gt;&lt;a href=&quot;#정수-삼각형&quot; class=&quot;headerlink&quot; title=&quot;정수 삼각형&quot;&gt;&lt;/a&gt;정수 삼각형&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="정수-삼각형"><a href="#정수-삼각형" class="headerlink" title="정수 삼각형"></a>정수 삼각형</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p><img src="https://grepp-programmers.s3.amazonaws.com/files/production/97ec02cc39/296a0863-a418-431d-9e8c-e57f7a9722ac.png" alt="스크린샷 2018-09-14 오후 5.44.19.png"></p><p>위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.</p><p>삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>삼각형의 높이는 1 이상 500 이하입니다.</li><li>삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>triangle</th><th>result</th></tr></thead><tbody><tr><td>[[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]</td><td>30</td></tr></tbody></table></div><p><a href="http://stats.ioinformatics.org/countries/SWE">출처</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">triangle</span>):</span></span><br><span class="line">    t = triangle</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(t)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t[i])):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; j &lt; <span class="built_in">len</span>(t[i])-<span class="number">1</span>:t[i][j]+= <span class="built_in">max</span>(t[i-<span class="number">1</span>][j-<span class="number">1</span>], t[i-<span class="number">1</span>][j])</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: t[i][j] += t[i-<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span> : t[i][j] += t[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(t[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>DP 유형의 기본 예제.</p><p>배열의 반복문을 돌며 윗 층에서 내려올 수 있는 두 방향 왼쪽과 오른쪽 중 큰 값을 더하며 내려간다.  </p><p>이를통해 현재 기준 최대의 값을 할당할 수 있고, 계산이 끝난 뒤 마지막 배열에서 최대값을 찾으면 된다.</p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/DP/">DP</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/06/05ad696d31a2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV3) n으로 표현</title>
      <link>https://sklubmk.github.io/2021/07/04/efedbb0a3ffd/</link>
      <guid>https://sklubmk.github.io/2021/07/04/efedbb0a3ffd/</guid>
      <pubDate>Sun, 04 Jul 2021 14:57:27 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;N으로-표현&quot;&gt;&lt;a href=&quot;#N으로-표현&quot; class=&quot;headerlink&quot; title=&quot;N으로 표현&quot;&gt;&lt;/a&gt;N으로 표현&lt;/h1&gt;&lt;p&gt;Python3&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="N으로-표현"><a href="#N으로-표현" class="headerlink" title="N으로 표현"></a>N으로 표현</h1><p>Python3</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다.</p><p>12 = 5 + 5 + (5 / 5) + (5 / 5)\<br>12 = 55 / 5 + 5 / 5\<br>12 = (55 + 5) / 5</p><p>5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.\<br>이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>N은 1 이상 9 이하입니다.</li><li>number는 1 이상 32,000 이하입니다.</li><li>수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.</li><li>최솟값이 8보다 크면 -1을 return 합니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>N</th><th>number</th><th>return</th></tr></thead><tbody><tr><td>5</td><td>12</td><td>4</td></tr><tr><td>2</td><td>11</td><td>3</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>예제 #1\<br>문제에 나온 예와 같습니다.</p><p>예제 #2\<br><code>11 = 22 / 2</code>와 같이 2를 3번만 사용하여 표현할 수 있습니다.</p><p><a href="https://www.oi.edu.pl/old/php/show.php?ac=e181413&amp;module=show&amp;file=zadania/oi6/monocyfr">출처</a></p><p>※ 공지 - 2020년 9월 3일 테스트케이스가 추가되었습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">answer = -<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, number</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sol</span>(<span class="params">count, result</span>):</span></span><br><span class="line">        <span class="keyword">global</span> answer</span><br><span class="line">        temp = N</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">8</span> : <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> result == number :</span><br><span class="line">            <span class="keyword">if</span> answer &gt; count <span class="keyword">or</span> answer == -<span class="number">1</span>:</span><br><span class="line">                answer = count</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>-count):</span><br><span class="line">            </span><br><span class="line">            sol(count+i+<span class="number">1</span>, result + temp)</span><br><span class="line">            sol(count+i+<span class="number">1</span>, result - temp)</span><br><span class="line">            sol(count+i+<span class="number">1</span>, result * temp)</span><br><span class="line">            sol(count+i+<span class="number">1</span>, <span class="built_in">int</span>(result / temp))</span><br><span class="line">            </span><br><span class="line">            temp = (temp * <span class="number">10</span>) + N</span><br><span class="line">            </span><br><span class="line">    sol(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>난이도 3의 DP(Dynamic Programming, 동적 계획법) 문제다.<br>처음 접했을때 약 4번이나 풀이 방법을 바꿔가며 풀어봤지만 모두 실패했다.</p><p><br/></p><p>처음엔 BFS 처럼 사칙연산 기호들을 이어붙이는 식으로 풀이를 해보려 했다가 낭패를 봤다.</p><p><br/></p><p>두 번째에는 딕셔너리를 활용해 연산값을 계속 저장하며 문제를 풀어보려 시도했다. 결과는 역시나 실패. 테스트 케이스 몇 개가 끝까지 해결이 안되었다. 여기서 괄호의 개념을 도입해야 한다는 판단이 들었는데, 이마저 BFS 형식으로 구현하면 시간초과가 날 것이 분명했다. 또한 풀이때 연산 방향에 신경썼는데 지금 생각해보면 전혀 필요 없는 부분이라 그땐 왜 그랬는지 모르겠다. 집중력이 저하된 것 같다.</p><p><br/></p><p>세 번째 방법은 위에서 쓴 딕셔너리 내의 두 값을 자발적으로 비교하는 방식으로 진행했다. 역시나 풀리지 않는 테스트 케이스들과 시간 초과로 실패했다. 이론상 N값을 이용해 4번의 사칙연산 결과만 저장해 놓으면, 나머지 값들의 비교로 최대 8의 결과값을 구할 수 있다. 그러나 4번째의 딕셔너리 연산이 시간초과를 불러왔다.</p><p><br/></p><p>네 번째 방법은 위 세 번째 방법과 네 번째 방법을 합쳐서 활용했는데, 풀면서도 절대로 이런식의 풀이가 성공할리 없다는 확신이 들었다. 풀이가 구질구질(?)해지면 거진 실패를 했기 때문에, 그 감정이 스멀스멀 올라오기 시작했을때 손을 놓고 다른 방법을 강구했다.</p><p><br/></p><p>결국 해법은 비슷한 유형의 문제 풀이를 보고 찾을 수 있었다. 사실 구현 자체만 보면 모든 부분을 탐색하기 때문에 BFS 풀이의 느낌이 강하다.</p><p><br/></p><p>핵심은 temp 변수에 있다. 두 값을 단순히 붙이는 방법을 자리수 이동으로 해결하고, 이를 연산의 한 방법으로 사용한 것이 굉장히 창의적이여서 이해하기 힘든 부분이었다. 풀이 과정이 간단하니 코드 또한 훨씬 줄고 깔끔해졌다. 두고두고 다시 봐야할 풀이 같다.</p><p><br/></p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/DP/">DP</category>
      
      <category domain="https://sklubmk.github.io/tags/lv3/">lv3</category>
      
      
      <comments>https://sklubmk.github.io/2021/07/04/efedbb0a3ffd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>외장하드 오류코드-36 해결법 (Fix Drive Error Code-36 in Mac)</title>
      <link>https://sklubmk.github.io/2021/06/30/93d8ce98a240/</link>
      <guid>https://sklubmk.github.io/2021/06/30/93d8ce98a240/</guid>
      <pubDate>Wed, 30 Jun 2021 12:22:22 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img style=&quot;margin:auto;display: block&quot; alt=&quot;error code-36&quot; src=&quot;/img/post_images/etc/error36.png&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img style="margin:auto;display: block" alt="error code-36" src="/img/post_images/etc/error36.png"></p><span id="more"></span><p><br/></p><h1 id="선-요약"><a href="#선-요약" class="headerlink" title="선 요약"></a>선 요약</h1><p><br/></p><p>❓❓❓ Problem ❓❓❓</p><blockquote><ul><li>맥북과 윈도우를 오가며 공용으로 사용하던 NTFS 포맷의 외장하드에서 오류 발생 (mac)</li><li>파일 이동이 불가능한 현상 <code>(Error Code - 36)</code></li></ul></blockquote><p><br/></p><p>❕❕❕ Solution ❕❕❕</p><blockquote><p>❌ <code>dot_clean</code> 명령어 사용했으나 실패, 이후 설정 폴더들 사라지는 추가 문제 발생<br>❌ 파일 복구 시스템(disk drill, easyUS, etc .. ) 사용 -&gt; 온전히 복구 실패<br>✅ <code>windows OS</code> cmd 에서 <span style="color:red">chkdsk</span>로 해결</p></blockquote><p><br/></p><p><br/></p><h1 id="문제-발생"><a href="#문제-발생" class="headerlink" title="문제 발생"></a>문제 발생</h1><p><br/></p><p><code>Mac</code>과 <code>Windows</code> 를 동시에 사용하는 나는, 두 데스크탑에서 데이터를 공유하기 위해 USB 허브에 외장 드라이브를 물려 사용해왔다. 처음에 맥에서 외장하드를 연결했을때, 윈도우에서 사용하던 드라이브의 사용이 불가능 했다. 그 이유는 드라이브의 <code>파일 시스템</code> 때문이었다. 기존 사용하던 <code>FAT32</code> 파일 시스템이 맥에서는 사용이 안됐기 때문에, 어쩔 수 없이 <code>NTFS</code>로 포멧하여 사용해야 했다.</p><p><br/><br><br/></p><h2 id="❗️-Error-Code-36"><a href="#❗️-Error-Code-36" class="headerlink" title="❗️ Error Code 36"></a>❗️ Error Code 36</h2><blockquote><h3 id="The-Finder-can’t-complete-the-operation-because-some-data-in-“FileName”-can’t-be-read-or-written-Error-code-36"><a href="#The-Finder-can’t-complete-the-operation-because-some-data-in-“FileName”-can’t-be-read-or-written-Error-code-36" class="headerlink" title="The Finder can’t complete the operation because some data in “FileName” can’t be read or written. (Error code -36)"></a>The Finder can’t complete the operation because some data in “FileName” can’t be read or written. (Error code -36)</h3></blockquote><p><br/></p><p>그런데 어느 날 Mac에서 작성한 작업 파일이 드라이브에 복사가 되지 않았다.<br>문제는 error code 36이었다.</p><p>오류 코드 36은 맥 OS에서 자주 발생하는 나름 악명높은(?) 오류였다.</p><p>간단히 설명하면 NTFS 파일 시스템의 드라이브를 맥에서 이용할 때, 드라이브가 꼬이는 문제였다.<br>백업 전용 드라이브라 파일을 반드시 저장해야 하는데, 파일이 이동되지 않으니 참으로 난감한 상황이었다.</p><p><span style="color:#f46049"><em>이때 그냥 윈도우로 옮겨 저장했어야 했는데…</em></span> 🤔</p><p>당시엔 단순히 <strong>가벼운 오류</strong>라 생각해서 맥에서 이를 해결해보려 했다.</p><p><br/></p><p><br/></p><h2 id="시행착오"><a href="#시행착오" class="headerlink" title="시행착오"></a>시행착오</h2><p><br/></p><p>처음 구글링을 통해 시행한 방법은 <code>dot_clean</code> 이었다.<br>특정 macOS 파일을 HFS+/APFS 형식이 지정되지 않은 디스크(예: 파일 공유)에 복사하면 메타데이터가 파일에서 추출되어 dot(‘._’)로 시작하는 보이지 않는 파일에 넣는다고 한다.  </p><p>이런 숨겨진 시스템 파일을 전송하려는 시도에서 Error Code-36이 자주 발생한다고 한다.<br>이 dot 파일들을 쉽게 정리하는 명령어가 바로 <code>dot_clean</code> 이다.<br>이는 단순 파일 삭제가 아니라 원본과 병합하는 과정을 거치기 때문에 안전(?)하다고 한다.  </p><p>사용 방법은 간단하다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot_clean /Volumes/MY_VOLUME_PATH</span><br></pre></td></tr></table></figure><p>파일 이동이 안되는 드라이브의 경로를 입력해주면 된다.<br>그런데 나는 이때 딱히 변화를 감지하지 못했다.</p><p>그래서 볼륨의 루트 경로 한 번, 문제되는 폴더 경로 한 번.<br>총 2번의 <code>dot_clean</code>을 시행했다.<br>사실 각각 시행해도 달라지는건 없었다.  </p><p>문제는 연결을 잠시 해제(안전하게)하고 난 뒤였다.  </p><p>폴더 내부 파일의 <strong>절반</strong>이 날아가버린 것이다.</p><p><br/></p><p><br/></p><h2 id="이어지는-뻘짓"><a href="#이어지는-뻘짓" class="headerlink" title="이어지는 뻘짓"></a>이어지는 뻘짓</h2><p><br/></p><p>처음엔 너무 당황스러웠다. 마치 약을 먹었는데 그게 더 독이 되어버린 경우였다. </p><p>충분히 의심되는 여러 증상들(새 폴더를 생성하면 순식간에 Finder에서 사라지는 등)이 있었지만, 내 머릿속에는 따로 백업도 안된 채 날아간 중요 파일들에대한 걱정 뿐이였다. </p><p>나는 결국 데이터 복구 프로그램을 찾기 시작했다.</p><p>일단 시중의 Mac용 Drive 복구 프로그램중 제일 유명해보이는 Disk drill과 easyUS, 기타 이름모를 복구 프로그램들을 닥치는대로 받아가며 복구가 가능한지 시도해봤다.</p><p>그 중 가장 유의미하게 복구가 가능한 것으로 보여지는 것은 Disk drill이었다.<br>그러나 그 마저도 잃어버린 50% 파일 중 20%정도 남짓에 불과했다.<br>그 20% 안에는 중요 계약 서류들이 있어서 이것을 돈주고 복구해야 하는지 내적고민을 엄청나게 했다.</p><p>약 10만원 가량의 비용이었기 때문에 정말 앉아서 돈을 잃는 경우라고 생각했고, 조금은 이성을 되찾기로 했다.</p><p>이어지는 고민과 명상 도중 드는 생각은 Mac은 왜이렇게 불안정할까 였다.<br>윈도우에선 이런일이 없었는디… 라는 생각이 들었고,<br>이 흐름은 마침내 Windows의 chkdsk 기능으로 도달했다.</p><h4 id="🔥아-맞다-그런게-있었지-🔥"><a href="#🔥아-맞다-그런게-있었지-🔥" class="headerlink" title="🔥아 맞다 그런게 있었지!!!!! 🔥"></a><span style="color:rgb(220,60,70)"> 🔥아 맞다 그런게 있었지!!!!! 🔥</span></h4><p><br/></p><h2 id="CHKDSK로-해결"><a href="#CHKDSK로-해결" class="headerlink" title="CHKDSK로 해결"></a>CHKDSK로 해결</h2><p><br/></p><p>Windows의 CHKDSK 기능은 정말 막강하다.</p><p>CHKDSK는 다양한 메모리 관련 문제를 예방하고 해결하기 위한 윈도우의 자체적인 기능이다.<br>드라이브 포멧을 하던 중 이상이 생겼을 때도, 이 CHKDSK 기능을 활용하여 고쳤던 기억이 났다.</p><p>사용법 또한 간단하다. CMD 창을 켠 후</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chkdsk DRIVE_PATH /f /r</span><br><span class="line"><span class="meta">#</span><span class="bash"> DRIVE_PATH 는 자신의 볼륨 주소 (D:, F: 등)</span></span><br></pre></td></tr></table></figure><p>를 입력하면 된다.</p><blockquote><p>/f는 디스크에 있는 파일 시스템 오류를 자동으로 수정한다. (빠르다)</p><p>/r은 불량 섹터를 검사하고 발견되면 복구를 시도한다.<br>작업시간이 매우 느리므로 주의 ❗ ️(수 시간 소요, 도중 취소 불가)</p></blockquote><p><br/></p><p><br/></p><p><img src="/img/post_images/etc/feelsogood.jpg" alt=""></p><p><br/></p><p>이 작업을 하자 거짓말처럼 드라이브가 깨끗히 복구되었고,<br>심지어 맥에서 생성한 빈 폴더마저 나타났다.</p><p>이 문제 때문에 몇 시간을 골머리 썩히며 고생했지만,<br>정말 다행인 점은 복구 프로그램을 결제하지 않았다는 사실이다.</p><p>요즘 맥을 메인으로 사용하다보니 이러한 메모리 관련 문제가 자주 발생하는데,<br>그때 마다 정말 윈도우가 선녀였다는 생각이 들곤 한다.</p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EB%94%94%EB%B2%84%EA%B9%85/">디버깅</category>
      
      <category domain="https://sklubmk.github.io/categories/%EB%94%94%EB%B2%84%EA%B9%85/%EA%B8%B0%ED%83%80-%EC%98%A4%EB%A5%98/">기타 오류</category>
      
      
      <category domain="https://sklubmk.github.io/tags/Error/">Error</category>
      
      <category domain="https://sklubmk.github.io/tags/Mac/">Mac</category>
      
      <category domain="https://sklubmk.github.io/tags/%EB%94%94%EB%B2%84%EA%B9%85/">디버깅</category>
      
      <category domain="https://sklubmk.github.io/tags/Drive/">Drive</category>
      
      <category domain="https://sklubmk.github.io/tags/Code-36/">Code-36</category>
      
      
      <comments>https://sklubmk.github.io/2021/06/30/93d8ce98a240/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 124 나라의 숫자</title>
      <link>https://sklubmk.github.io/2021/06/30/4eb67bcb6e9d/</link>
      <guid>https://sklubmk.github.io/2021/06/30/4eb67bcb6e9d/</guid>
      <pubDate>Tue, 29 Jun 2021 17:00:33 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;124-나라의-숫자&quot;&gt;&lt;a href=&quot;#124-나라의-숫자&quot; class=&quot;headerlink&quot; title=&quot;124 나라의 숫자&quot;&gt;&lt;/a&gt;124 나라의 숫자&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="124-나라의-숫자"><a href="#124-나라의-숫자" class="headerlink" title="124 나라의 숫자"></a>124 나라의 숫자</h1><p>JavaScript, Python</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.</p><ol><li>124 나라에는 자연수만 존재합니다.</li><li>124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.</li></ol><p>예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.</p><div class="table-container"><table><thead><tr><th>10진법</th><th>124 나라</th><th>10진법</th><th>124 나라</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>6</td><td>14</td></tr><tr><td>2</td><td>2</td><td>7</td><td>21</td></tr><tr><td>3</td><td>4</td><td>8</td><td>22</td></tr><tr><td>4</td><td>11</td><td>9</td><td>24</td></tr><tr><td>5</td><td>12</td><td>10</td><td>41</td></tr></tbody></table></div><p>자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>n은 500,000,000이하의 자연수 입니다.</li></ul><hr><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>n</th><th>result</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>4</td><td>11</td></tr></tbody></table></div></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params">num,count</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num === <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cal = <span class="built_in">Math</span>.floor(num /<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">var</span> rest = num % <span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( rest === <span class="number">0</span> )&#123;</span><br><span class="line">                cal--;</span><br><span class="line">                rest = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> three(cal,count+<span class="number">1</span>)  + rest * <span class="built_in">Math</span>.pow(<span class="number">10</span>,count)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    answer = three(n,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> answer+<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        </span><br><span class="line">        n, r = <span class="built_in">divmod</span>(n, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">            r = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        answer += (r * (<span class="number">10</span> ** count))</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(answer)</span><br></pre></td></tr></table></figure><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>진법 변환을 요구하는 문제다.</p><p>언뜻 보면 단순히 4진법에서 (3 -&gt; 4)만 변한듯 오해할 수 있으나 124나라 표기법에는 0이 없다는 점을 잊어선 안된다. </p><p><br/></p><div class="table-container"><table><thead><tr><th>10진법</th><th>3진법</th><th>124나라</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td><span style="color:red">10</span></td><td><span style="color:red">4</span></td></tr><tr><td>4</td><td>11</td><td>11</td></tr><tr><td>5</td><td>12</td><td>12</td></tr><tr><td>6</td><td><span style="color:red">20</span></td><td><span style="color:red">14</span></td></tr><tr><td>7</td><td>21</td><td>21</td></tr><tr><td>8</td><td>22</td><td>22</td></tr><tr><td>9</td><td><span style="color:red">100</span></td><td><span style="color:red">24</span></td></tr><tr><td>10</td><td>101</td><td>41</td></tr></tbody></table></div><p><br/></p><p>3진법과 124나라의 진법을 자세히 살펴보면 핵심은 <span style="color:red">4</span>에 있다는 것을 알 수 있다.</p><p>124나라의 4는 자리 변환이 일어나는 3진법의 10의 성질을 갖고 있다.</p><p>따라서 3을 나누어 몫과 나머지를 반복하는 3진법 계산식에서 나머지가 0일때 4의 특성을 입혔다. (몫 -1, 나머지 &lt;- 4)</p><p>이 방법을 통해 문제를 해결할 수 있었고, 다른 사람들의 풀이도 이와 비슷한 양상을 보였다.</p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://sklubmk.github.io/tags/N%EC%A7%84%EB%B2%95/">N진법</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      
      <comments>https://sklubmk.github.io/2021/06/30/4eb67bcb6e9d/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) H-Index</title>
      <link>https://sklubmk.github.io/2021/06/30/1f72074cd119/</link>
      <guid>https://sklubmk.github.io/2021/06/30/1f72074cd119/</guid>
      <pubDate>Tue, 29 Jun 2021 17:00:33 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;H-Index&quot;&gt;&lt;a href=&quot;#H-Index&quot; class=&quot;headerlink&quot; title=&quot;H-Index&quot;&gt;&lt;/a&gt;H-Index&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a>H-Index</h1><p>JavaScript, Python</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과<a href="https://programmers.co.kr/learn/courses/30/lessons/42747#fn1">1</a>에 따르면, H-Index는 다음과 같이 구합니다.</p><p>어떤 과학자가 발표한 논문 <code>n</code>편 중, <code>h</code>번 이상 인용된 논문이 <code>h</code>편 이상이고 나머지 논문이 h번 이하 인용되었다면 <code>h</code>의 최댓값이 이 과학자의 H-Index입니다.</p><p>어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.</p><h5 id="제한사항"><a href="#제한사항" class="headerlink" title="제한사항"></a>제한사항</h5><ul><li>과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.</li><li>논문별 인용 횟수는 0회 이상 10,000회 이하입니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>citations</th><th>return</th></tr></thead><tbody><tr><td>[3, 0, 6, 1, 5]</td><td>3</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.</p><p>※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다.</p><hr><ol><li><a href="https://en.wikipedia.org/wiki/H-index">https://en.wikipedia.org/wiki/H-index</a> “위키백과” <a href="https://programmers.co.kr/learn/courses/30/lessons/42747#fnref1">↩</a></li></ol></blockquote><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">citations</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> sorted = citations.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sorted.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(answer &gt; sorted[i])</span><br><span class="line">            <span class="keyword">return</span> answer;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = (sorted[i] &lt;= (i+<span class="number">1</span>) ? sorted[i] : i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">citations</span>):</span></span><br><span class="line">    h = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(citations,reverse=<span class="literal">True</span>)):</span><br><span class="line">        <span class="keyword">if</span> h &gt; c:</span><br><span class="line">            <span class="keyword">return</span> h</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            h = (c <span class="keyword">if</span> c &lt;= (i+<span class="number">1</span>) <span class="keyword">else</span> i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>정렬(sort)하지 않고서는 O(N<sup>2</sup>)이상의 풀이 방법이 없었다.</p><p>배열을 내림정렬을 한 뒤, 앞에서 부터 index와 값을 비교하여 최대값을 갱신시켜주면 된다.</p><p>여기서 index는 자연스럽게 현재 값보다 같거나 큰 값들의 개수가 된다(정확히는 i+1이).</p><p>내가 염려했던 부분은 <code>[5,5,5,5,0]</code>와 같은 배열이었는데, 이 배열의 h값은 4가 나와야 한다.</p><p>즉, 배열에 포함되어 있지 않은 값으로도 h가 갱신되어야 한다.</p><p>따라서 index와 값을 비교하여 더 낮은 값으로 갱신을 진행했다.</p><p>정렬 한 뒤에는 O(N)풀이 인데, 평균적으로는 훨씬 적을 것으로 예상된다.</p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%A0%95%EB%A0%AC/">정렬</category>
      
      
      <comments>https://sklubmk.github.io/2021/06/30/1f72074cd119/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 괄호 변환</title>
      <link>https://sklubmk.github.io/2021/06/30/a12417826dd1/</link>
      <guid>https://sklubmk.github.io/2021/06/30/a12417826dd1/</guid>
      <pubDate>Tue, 29 Jun 2021 17:00:33 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;괄호-변환&quot;&gt;&lt;a href=&quot;#괄호-변환&quot; class=&quot;headerlink&quot; title=&quot;괄호 변환&quot;&gt;&lt;/a&gt;괄호 변환&lt;/h1&gt;&lt;p&gt;Javascript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="괄호-변환"><a href="#괄호-변환" class="headerlink" title="괄호 변환"></a>괄호 변환</h1><p>Javascript, Python</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>카카오에 신입 개발자로 입사한 “콘”은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.\<br>수정해야 할 소스 파일이 너무 많아서 고민하던 “콘”은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다.</p><h3 id="용어의-정의"><a href="#용어의-정의" class="headerlink" title="용어의 정의"></a>용어의 정의</h3><p>‘(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 <code>균형잡힌 괄호 문자열</code>이라고 부릅니다.\<br>그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 <code>올바른 괄호 문자열</code>이라고 부릅니다.\<br>예를 들어, <code>&quot;(()))(&quot;</code>와 같은 문자열은 “균형잡힌 괄호 문자열” 이지만 “올바른 괄호 문자열”은 아닙니다.\<br>반면에 <code>&quot;(())()&quot;</code>와 같은 문자열은 “균형잡힌 괄호 문자열” 이면서 동시에 “올바른 괄호 문자열” 입니다.</p><p>‘(‘ 와 ‘)’ 로만 이루어진 문자열 w가 “균형잡힌 괄호 문자열” 이라면 다음과 같은 과정을 통해 “올바른 괄호 문자열”로 변환할 수 있습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.</span><br><span class="line">2. 문자열 w를 두 &quot;균형잡힌 괄호 문자열&quot; u, v로 분리합니다. 단, u는 &quot;균형잡힌 괄호 문자열&quot;로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.</span><br><span class="line">3. 문자열 u가 &quot;올바른 괄호 문자열&quot; 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.</span><br><span class="line"> 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.</span><br><span class="line">4. 문자열 u가 &quot;올바른 괄호 문자열&quot;이 아니라면 아래 과정을 수행합니다.</span><br><span class="line"> 4-1. 빈 문자열에 첫 번째 문자로 &#x27;(&#x27;를 붙입니다.</span><br><span class="line"> 4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.</span><br><span class="line"> 4-3. &#x27;)&#x27;를 다시 붙입니다.</span><br><span class="line"> 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.</span><br><span class="line"> 4-5. 생성된 문자열을 반환합니다.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>“균형잡힌 괄호 문자열” p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 “올바른 괄호 문자열”로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요.</p><h3 id="매개변수-설명"><a href="#매개변수-설명" class="headerlink" title="매개변수 설명"></a>매개변수 설명</h3><ul><li>p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다.</li><li>문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다.</li><li>만약 p가 이미 “올바른 괄호 문자열”이라면 그대로 return 하면 됩니다.</li></ul><hr><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><div class="table-container"><table><thead><tr><th>p</th><th>result</th></tr></thead><tbody><tr><td><code>&quot;(()())()&quot;</code></td><td><code>&quot;(()())()&quot;</code></td></tr><tr><td><code>&quot;)(&quot;</code></td><td><code>&quot;()&quot;</code></td></tr><tr><td><code>&quot;()))((()&quot;</code></td><td><code>&quot;()(())()&quot;</code></td></tr></tbody></table></div><h3 id="입출력-예에-대한-설명"><a href="#입출력-예에-대한-설명" class="headerlink" title="입출력 예에 대한 설명"></a>입출력 예에 대한 설명</h3><p>입출력 예 #1\<br>이미 “올바른 괄호 문자열” 입니다.</p><p>입출력 예 #2</p><ul><li>두 문자열 u, v로 분리합니다.<ul><li>u = <code>&quot;)(&quot;</code></li><li>v = <code>&quot;&quot;</code></li></ul></li><li>u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다.<ul><li>v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다.</li><li>u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 <code>&quot;&quot;</code>이 됩니다.</li><li>따라서 생성되는 문자열은 <code>&quot;(&quot;</code> + <code>&quot;&quot;</code> + <code>&quot;)&quot;</code> + <code>&quot;&quot;</code>이며, 최종적으로 <code>&quot;()&quot;</code>로 변환됩니다.</li></ul></li></ul><p>입출력 예 #3</p><ul><li>두 문자열 u, v로 분리합니다.<ul><li>u = <code>&quot;()&quot;</code></li><li>v = <code>&quot;))((()&quot;</code></li></ul></li><li>문자열 u가 “올바른 괄호 문자열”이므로 그대로 두고, v에 대해 재귀적으로 수행합니다.</li><li>다시 두 문자열 u, v로 분리합니다.<ul><li>u = <code>&quot;))((&quot;</code></li><li>v = <code>&quot;()&quot;</code></li></ul></li><li>u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다.<ul><li>v에 대해 1단계부터 재귀적으로 수행하면 <code>&quot;()&quot;</code>이 반환됩니다.</li><li>u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 <code>&quot;()&quot;</code>이 됩니다.</li><li>따라서 생성되는 문자열은 <code>&quot;(&quot;</code> + <code>&quot;()&quot;</code> + <code>&quot;)&quot;</code> + <code>&quot;()&quot;</code>이며, 최종적으로 <code>&quot;(())()&quot;</code>를 반환합니다.</li></ul></li><li>처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면 <code>&quot;()&quot;</code> + <code>&quot;(())()&quot;</code> = <code>&quot;()(())()&quot;</code>가 됩니다.</li></ul><hr><p>혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 <a href="https://programmers.co.kr/learn/courses/10336?utm_source=programmers&amp;utm_medium=test_course10336&amp;utm_campaign=course_10336">(클릭)</a></p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="python-1차-풀이"><a href="#python-1차-풀이" class="headerlink" title="python 1차 풀이"></a>python 1차 풀이</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">p</span>):</span></span><br><span class="line">    count_s = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;)&#x27;</span>:-<span class="number">1</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">changeU</span>(<span class="params">u</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([ <span class="string">&#x27;)&#x27;</span> <span class="keyword">if</span> s == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">for</span> s <span class="keyword">in</span> u[<span class="number">1</span>:-<span class="number">1</span>]])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitUV</span>(<span class="params">s</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        isRight = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            count += count_s[c]</span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span>:</span><br><span class="line">                isRight = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> count == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> (isRight, count == <span class="number">0</span>,s[:i+<span class="number">1</span>],s[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sol</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        r,b,u,v = splitUV(s)</span><br><span class="line">        <span class="keyword">if</span> r:</span><br><span class="line">            <span class="keyword">return</span> u + sol(v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + sol(v) + <span class="string">&#x27;)&#x27;</span> + changeU(u)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> sol(p)</span><br><span class="line">```  </span><br><span class="line"><span class="comment">#### python 1차풀이 간략화</span></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">p</span>):</span></span><br><span class="line">    <span class="keyword">if</span> p ==<span class="string">&#x27;&#x27;</span>: <span class="keyword">return</span> p</span><br><span class="line">    r = <span class="literal">True</span>; count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(p):</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;(&#x27;</span>: count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &lt; <span class="number">0</span> : r = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> r:</span><br><span class="line">                <span class="keyword">return</span> p[:i+<span class="number">1</span>] + solution(p[i+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>+solution(p[i+<span class="number">1</span>:])+<span class="string">&#x27;)&#x27;</span>+ <span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;)&#x27;</span> <span class="keyword">if</span> s == <span class="string">&#x27;(&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;(&#x27;</span> <span class="keyword">for</span> s <span class="keyword">in</span> p[<span class="number">1</span>:i]])</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p><a href="https://sklubmk.github.io/2021/06/30/til/algorithm%20test/programmers/lv2/%EC%98%AC%EB%B0%94%EB%A5%B8%20%EA%B4%84%ED%98%B8/">올바른 괄호</a> 문제의 심화 버전.</p><p>실제 대기업 코딩 테스트에서도 흡사한 유형의 문제가 출제되었다.</p><p>풀이는 올바른 괄호 문제에서와 같이 count 변수를 이용해 올바른 괄호와 균형잡힌 괄호 여부를 판단했고,</p><p>문제의 요구사항대로 재귀함수를 이용해 어려움없이 결과값을 도출했다.</p><p><br/></p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/%EA%B4%84%ED%98%B8/">괄호</category>
      
      
      <comments>https://sklubmk.github.io/2021/06/30/a12417826dd1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[프로그래머스] (LV2) 기능개발</title>
      <link>https://sklubmk.github.io/2021/06/30/d276f8a57701/</link>
      <guid>https://sklubmk.github.io/2021/06/30/d276f8a57701/</guid>
      <pubDate>Tue, 29 Jun 2021 17:00:33 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;기능개발&quot;&gt;&lt;a href=&quot;#기능개발&quot; class=&quot;headerlink&quot; title=&quot;기능개발&quot;&gt;&lt;/a&gt;기능개발&lt;/h1&gt;&lt;p&gt;JavaScript, Python&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="기능개발"><a href="#기능개발" class="headerlink" title="기능개발"></a>기능개발</h1><p>JavaScript, Python</p><span id="more"></span><blockquote><h6 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h6><p>프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.</p><p>또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.</p><p>먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</p><h5 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h5><ul><li>작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.</li><li>작업 진도는 100 미만의 자연수입니다.</li><li>작업 속도는 100 이하의 자연수입니다.</li><li>배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.</li></ul><h5 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h5><div class="table-container"><table><thead><tr><th>progresses</th><th>speeds</th><th>return</th></tr></thead><tbody><tr><td>[93, 30, 55]</td><td>[1, 30, 5]</td><td>[2, 1]</td></tr><tr><td>[95, 90, 99, 99, 80, 99]</td><td>[1, 1, 1, 1, 1, 1]</td><td>[1, 3, 2]</td></tr></tbody></table></div><h5 id="입출력-예-설명"><a href="#입출력-예-설명" class="headerlink" title="입출력 예 설명"></a>입출력 예 설명</h5><p>입출력 예 #1\<br>첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\<br>두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.\<br>세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.</p><p>따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.</p><p>입출력 예 #2\<br>모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.</p><p>따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.</p><p>※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다.</p></blockquote><p><br/></p><p><br/></p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p><br/></p><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solution</span>(<span class="params">progresses, speeds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> answer = [];</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(progresses.length)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(progresses[<span class="number">0</span>] &lt; <span class="number">100</span>)</span><br><span class="line">            progresses = progresses.map(<span class="function">(<span class="params">a,index</span>)=&gt;</span>a+speeds[index])</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(progresses.length &amp;&amp; progresses[<span class="number">0</span>] &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                progresses.shift();</span><br><span class="line">                speeds.shift();</span><br><span class="line">            &#125;</span><br><span class="line">            answer.push(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">progresses, speeds</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(progresses):</span><br><span class="line">        <span class="keyword">if</span> progresses[<span class="number">0</span>] &gt;= <span class="number">100</span>:</span><br><span class="line">            progresses.pop(<span class="number">0</span>)</span><br><span class="line">            speeds.pop(<span class="number">0</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">elif</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            answer.append(count)</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(progresses):</span><br><span class="line">            progresses[i] += speeds[i]</span><br><span class="line"></span><br><span class="line">    answer.append(count)        </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><br/></p><p><br/></p><h1 id="설명"><a href="#설명" class="headerlink" title="설명"></a>설명</h1><p><br/></p><p>자료구조 큐를 활용한 문제다.</p><p>python의 list와 javascript array에서 각각 일반적인 FIFO의 큐를 구현할 수 있다.</p><table>    <tr>        <td>    </td>        <td>python</td>        <td>javascript</td>    </tr>    <tr>        <td>삽입</td>        <td>append(v)</td>        <td>push(v)</td>    </tr>    <tr>        <td>삭제</td>        <td>pop(0)</td>        <td>shift()</td>    </tr></table><p><br/></p><p>해당 문제에선 Queue의 삭제 기능만을 사용하여 쉽게 구현할 수 있었다.</p><p><br/></p>]]></content:encoded>
      
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      
      <category domain="https://sklubmk.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://sklubmk.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</category>
      
      <category domain="https://sklubmk.github.io/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</category>
      
      <category domain="https://sklubmk.github.io/tags/python/">python</category>
      
      <category domain="https://sklubmk.github.io/tags/javascript/">javascript</category>
      
      <category domain="https://sklubmk.github.io/tags/lv2/">lv2</category>
      
      <category domain="https://sklubmk.github.io/tags/queue/">queue</category>
      
      
      <comments>https://sklubmk.github.io/2021/06/30/d276f8a57701/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
