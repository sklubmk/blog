{"pages":[],"posts":[{"title":"카멜마운트 UMA-2 모니터암 + 선정리 후기","text":"이 포스팅은 쿠팡 파트너스 활동의 일환으로, 이에 따른 일정액의 수수료를 제공받습니다. 🙌 선요약 필자는 Dell U2718Q 제품과 U2414H 제품을 사용중이다. 덧붙여 맥+데탑+PS4의 조합을 위해 HDMI, USB 선택기를 사용한다. 그러다보니 선들이 매우 혼잡스러웠고, 카멜 마운트 UMA-2 모니터암 2개로 혼내줬다. 선정리가 필요해 필자는 듀얼모니터로 4k 모니터인 dell u2718q와 fhd모니터인 u2414h를 사용중이다. 이 모니터들로 데스크탑, 맥북(현재는 맥 미니로 대체), 플스를 사용중이고 이를 위해 HDMI 선택기와 USB 선택기를 각각 사용하고 있다. 그렇기 때문에 책상 뒷편은 복잡한 선들로 뒤덮였다. 이런 것들은 실제로 컴퓨터 작업을 할때 꽤나 신경이 쓰이고, 알게 모르게 나의 정신 에너지를 갉아먹고 있다는 생각이 들었다. 그래서 나는 모니터암을 사기로 결심했다. 모니터암 후보는 굉장히 많았다. 나는 보통 물건을 고를 때 다음과 같은 것들을 참고한다. 유명 리뷰 유튜버가 ‘광고’ 없이 찍은 리뷰를 참고한다. 구글링으로 각종 커뮤니티 관련 게시물을 참고한다. 쿠팡(혹은 네이버쇼핑) 리뷰를 확인한다. 지인에게 자문을 구한다. 그런 기준들에서 공통적으로 카멜 마운트 브랜드가 거론되었고, 내게 적합하다고 판단했다. 그 중에서도 UMA-2 제품을 사기로 마음먹었는데, 알루미늄 소재라는 점과 10kg까지 버티는 중량 때문이었다. 내가 사용하는 U2718Q 4K 모니터 무게가 9.3kg이나 나가기 때문이다. 아래는 순서대로 UMA-2, UMA-2H(10~20kg 고중량)다.나는 두 가지 제품을 고민하던 끝에 UMA-2를 선택했다. 설치 Before &amp; After 설치 전 이랬던 선들이... 이렇게 정리됐다 모니터암의 위력은 대단했다! 빨간 선은 보조 모니터의 썬더볼트3 to hdmi 케이블인데, 3m 이상 제품을 구할수가 없었다. 어찌됐든 굉장히 만족할 정도로 정리가 됐다. 왜 다들 모니터암 모니터암 하는지 알 수 있었다. 무엇보다 알루미늄 소재인 UMA-2의 고급스러움이 굉장히 만족스럽다. 모니터암 입문을 고민하고 있다면, 정말 강력히 추천한다. 리뷰 끝.","link":"/2021/06/26/review/UMA2%20%ED%9B%84%EA%B8%B0/"},{"title":"외장하드 오류코드-36 해결법 (Fix Drive Error Code-36 in Mac)","text":"선 요약 ❓❓❓ Problem ❓❓❓ 맥북과 윈도우를 오가며 공용으로 사용하던 NTFS 포맷의 외장하드에서 오류 발생 (mac) 파일 이동이 불가능한 현상 (Error Code - 36) ❕❕❕ Solution ❕❕❕ ❌ dot_clean 명령어 사용했으나 실패, 이후 설정 폴더들 사라지는 추가 문제 발생❌ 파일 복구 시스템(disk drill, easyUS, etc .. ) 사용 -&gt; 온전히 복구 실패✅ windows OS cmd 에서 chkdsk로 해결 문제 발생 Mac과 Windows 를 동시에 사용하는 나는, 두 데스크탑에서 데이터를 공유하기 위해 USB 허브에 외장 드라이브를 물려 사용해왔다. 처음에 맥에서 외장하드를 연결했을때, 윈도우에서 사용하던 드라이브의 사용이 불가능 했다. 그 이유는 드라이브의 파일 시스템 때문이었다. 기존 사용하던 FAT32 파일 시스템이 맥에서는 사용이 안됐기 때문에, 어쩔 수 없이 NTFS로 포멧하여 사용해야 했다. ❗️ Error Code 36 The Finder can’t complete the operation because some data in “FileName” can’t be read or written. (Error code -36) 그런데 어느 날 Mac에서 작성한 작업 파일이 드라이브에 복사가 되지 않았다.문제는 error code 36이었다. 오류 코드 36은 맥 OS에서 자주 발생하는 나름 악명높은(?) 오류였다. 간단히 설명하면 NTFS 파일 시스템의 드라이브를 맥에서 이용할 때, 드라이브가 꼬이는 문제였다.백업 전용 드라이브라 파일을 반드시 저장해야 하는데, 파일이 이동되지 않으니 참으로 난감한 상황이었다. 이때 그냥 윈도우로 옮겨 저장했어야 했는데… 🤔 당시엔 단순히 가벼운 오류라 생각해서 맥에서 이를 해결해보려 했다. 시행착오 처음 구글링을 통해 시행한 방법은 dot_clean 이었다.특정 macOS 파일을 HFS+/APFS 형식이 지정되지 않은 디스크(예: 파일 공유)에 복사하면 메타데이터가 파일에서 추출되어 dot(‘._’)로 시작하는 보이지 않는 파일에 넣는다고 한다. 이런 숨겨진 시스템 파일을 전송하려는 시도에서 Error Code-36이 자주 발생한다고 한다.이 dot 파일들을 쉽게 정리하는 명령어가 바로 dot_clean 이다.이는 단순 파일 삭제가 아니라 원본과 병합하는 과정을 거치기 때문에 안전(?)하다고 한다. 사용 방법은 간단하다. 1dot_clean /Volumes/MY_VOLUME_PATH 파일 이동이 안되는 드라이브의 경로를 입력해주면 된다.그런데 나는 이때 딱히 변화를 감지하지 못했다. 그래서 볼륨의 루트 경로 한 번, 문제되는 폴더 경로 한 번.총 2번의 dot_clean을 시행했다.사실 각각 시행해도 달라지는건 없었다. 문제는 연결을 잠시 해제(안전하게)하고 난 뒤였다. 폴더 내부 파일의 절반이 날아가버린 것이다. 이어지는 뻘짓 처음엔 너무 당황스러웠다. 마치 약을 먹었는데 그게 더 독이 되어버린 경우였다. 충분히 의심되는 여러 증상들(새 폴더를 생성하면 순식간에 Finder에서 사라지는 등)이 있었지만, 내 머릿속에는 따로 백업도 안된 채 날아간 중요 파일들에대한 걱정 뿐이였다. 나는 결국 데이터 복구 프로그램을 찾기 시작했다. 일단 시중의 Mac용 Drive 복구 프로그램중 제일 유명해보이는 Disk drill과 easyUS, 기타 이름모를 복구 프로그램들을 닥치는대로 받아가며 복구가 가능한지 시도해봤다. 그 중 가장 유의미하게 복구가 가능한 것으로 보여지는 것은 Disk drill이었다.그러나 그 마저도 잃어버린 50% 파일 중 20%정도 남짓에 불과했다.그 20% 안에는 중요 계약 서류들이 있어서 이것을 돈주고 복구해야 하는지 내적고민을 엄청나게 했다. 약 10만원 가량의 비용이었기 때문에 정말 앉아서 돈을 잃는 경우라고 생각했고, 조금은 이성을 되찾기로 했다. 이어지는 고민과 명상 도중 드는 생각은 Mac은 왜이렇게 불안정할까 였다.윈도우에선 이런일이 없었는디… 라는 생각이 들었고,이 흐름은 마침내 Windows의 chkdsk 기능으로 도달했다. 🔥아 맞다 그런게 있었지!!!!! 🔥 CHKDSK로 해결 Windows의 CHKDSK 기능은 정말 막강하다. CHKDSK는 다양한 메모리 관련 문제를 예방하고 해결하기 위한 윈도우의 자체적인 기능이다.드라이브 포멧을 하던 중 이상이 생겼을 때도, 이 CHKDSK 기능을 활용하여 고쳤던 기억이 났다. 사용법 또한 간단하다. CMD 창을 켠 후 12chkdsk DRIVE_PATH /f /r# DRIVE_PATH 는 자신의 볼륨 주소 (D:, F: 등) 를 입력하면 된다. 이 때 /f는 디스크에 있는 파일 시스템 오류를 자동으로 수정하고,/r은 불량 섹터를 검사하고 발견되면 복구를 시도한다. (대신 오래 걸린다) 이 작업을 하자 거짓말처럼 드라이브가 깨끗히 복구되었고,심지어 맥에서 생성한 빈 폴더마저 나타났다. 이 문제 때문에 몇 시간을 골머리 썩히며 고생했지만,정말 다행인 점은 복구 프로그램을 결제하지 않았다는 사실이다. 요즘 맥을 메인으로 사용하다보니 이러한 메모리 관련 문제가 자주 발생하는데,그때 마다 정말 윈도우가 선녀였다는 생각이 들곤 한다.","link":"/2021/06/30/til/debugging/%EC%99%B8%EC%9E%A5%ED%95%98%EB%93%9C%20NTFS%ED%8F%AC%EB%A7%B7%20%EC%98%A4%EB%A5%98%EC%BD%94%EB%93%9C%20-36%20%ED%95%B4%EA%B2%B0%EB%B2%95/"},{"title":"[프로그래머스] 3진법 뒤집기","text":"3진법 뒤집기JavaScript, Python 문제 설명자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 100,000,000 이하인 자연수입니다. 입출력 예 n result 45 7 125 229 입출력 예 설명입출력 예 #1 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 45 1200 0021 7 따라서 7을 return 해야 합니다. 입출력 예 #2 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 125 11122 22111 229 따라서 229를 return 해야 합니다. 풀이 javascript123456789101112131415161718192021222324252627282930313233function solution(n) { var answer = 0; function toBaseThree(num){ var value = '' var maxPow = 1 while( num/(maxPow*3) &gt;= 1) maxPow *= 3 for(let i = maxPow; i&gt;=1; i/=3){ var val = Math.floor(num / i) value += val num %= i } return value } toBaseThree(n).split('').forEach((v,i)=&gt;{ answer += (v * Math.pow(3,i)) }) return answer}``` #### python```pythondef solution(n): answer = '' while n &gt;= 1: n, d = divmod(n,3) answer += str(d) answer = int(answer,3) return answer 설명 문제에서 요구되는 능력은 사용하는 언어의 진법 표현 방법을 아느냐(python 풀이)와 진법 변환을 직접 구현할 수 있느냐(javascript 풀이)이다. 자바스크립트로 풀때는 직접 진법 변환을 구현해보고 싶어서 위와같이 풀었고, 파이썬에서는 내장 함수를 이용했다. javascript 또한 toString() 함수를 이용해 진법을 표현할 수 있다.","link":"/2021/06/18/til/algorithm%20test/programmers/lv1/3%EC%A7%84%EB%B2%95%20%EB%92%A4%EC%A7%91%EA%B8%B0/"},{"title":"[프로그래머스] 2016년","text":"2016년JavaScript, Python 문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요. 제한 조건 2016년은 윤년입니다. 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 “TUE” 풀이 javascript1234567891011function solution(a, b) { var daysOfMonth = [31,29,31,30,31,30,31,31,30,31,30,31] var days = [&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;,&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;] var getDaySum = (index)=&gt;{ let result = 0 for(let i = 0; i &lt; index; i++) result += daysOfMonth[i] return result } return days[ (getDaySum(a-1) + b-1) % 7]} Date 클래스 이용 풀이12345678910111213function solution(a, b) { var date = new Date(2016, (a - 1), b); return date.toString().slice(0, 3).toUpperCase();}``` #### python```pythonimport datetimedef solution(a, b): d = datetime.datetime(2016,a,b) - datetime.datetime(2016,1,1) return ('FRI','SAT','SUN','MON','TUE','WED','THU')[d.days % 7] 설명 기본적인 Date 객체 활용 문제다. 해당 문제는 실제 날짜를 활용했기 때문에 가볍게 Date 객체를 활용하여 풀 수 있다.(2번째, 3번째 풀이) 그러나 가끔 등장하는 가상의 날짜를 이용한 문제를 맞이하면 단순히 Date 객체를 활용하여 문제를 풀기 어려울 수 있다. (30일로만 이루어진 달, 가상의 윤달 및 윤년 설정 등) 따라서 직접 달마다 날짜 수를 설정해 문제를 푸는 방법을 연습해둬야 한다(1번째 풀이)","link":"/2021/06/18/til/algorithm%20test/programmers/lv1/2016%EB%85%84/"},{"title":"[프로그래머스] k번째 수","text":"K번째수JavaScript, Python 문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 출처 풀이 javascript12345678910111213function solution(array, commands) { var answer = []; const compare = (a,b)=&gt;a-b for(let i =0; i &lt; commands.length; i ++){ // 입력값 검증 if((commands[i][1] - commands[i][0] + 1) &lt; commands[i][2]) continue; var divided = array.slice(commands[i][0]-1,commands[i][1]).sort(compare) answer.push(divided[commands[i][2]-1]) } return answer;} python12def solution(array, commands): return [sorted(array[i-1:j])[k-1] for [i,j,k] in commands] 설명 자르고, 정렬하고, 인덱싱하면 되는 간단한 문제다. javascript 풀이의 경우 따로 문제에서 언급하지 않은 입력값 검증을 추가했다.","link":"/2021/06/18/til/algorithm%20test/programmers/lv1/k%EB%B2%88%EC%A7%B8%20%EC%88%98/"},{"title":"[프로그래머스] 124 나라의 숫자","text":"124 나라의 숫자JavaScript, Python 문제 설명124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 풀이 javascript1234567891011121314151617181920212223function solution(n) { var answer = ''; function three(num,count){ if(num === 0) return 0 else{ var cal = Math.floor(num /3); var rest = num % 3; if( rest === 0 ){ cal--; rest = 4; } return three(cal,count+1) + rest * Math.pow(10,count) } } answer = three(n,0) return answer+'';} 12345678910111213141516def solution(n): answer = 0 count = 0 while n &gt; 0: n, r = divmod(n, 3) if r == 0: n -= 1; r = 4; answer += (r * (10 ** count)) count += 1; return str(answer) 설명 진법 변환을 요구하는 문제다. 언뜻 보면 단순히 4진법에서 (3 -&gt; 4)만 변한듯 오해할 수 있으나 124나라 표기법에는 0이 없다는 점을 잊어선 안된다. 10진법 3진법 124나라 1 1 1 2 2 2 3 10 4 4 11 11 5 12 12 6 20 14 7 21 21 8 22 22 9 100 24 10 101 41 3진법과 124나라의 진법을 자세히 살펴보면 핵심은 4에 있다는 것을 알 수 있다. 124나라의 4는 자리 변환이 일어나는 3진법의 10의 성질을 갖고 있다. 따라서 3을 나누어 몫과 나머지를 반복하는 3진법 계산식에서 나머지가 0일때 4의 특성을 입혔다. (몫 -1, 나머지 &lt;- 4) 이 방법을 통해 문제를 해결할 수 있었고, 다른 사람들의 풀이도 이와 비슷한 양상을 보였다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/124%20%EB%82%98%EB%9D%BC%EC%9D%98%20%EC%88%AB%EC%9E%90/"},{"title":"[프로그래머스] H-Index","text":"H-IndexJavaScript 문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. ※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다. https://en.wikipedia.org/wiki/H-index “위키백과” ↩ 풀이 javascript123456789101112function solution(citations) { var answer = 0; var sorted = citations.sort((a,b)=&gt;b-a) for(let i = 0; i &lt; sorted.length; i++){ if(answer &gt; sorted[i]) return answer; else answer = (sorted[i] &lt;= (i+1) ? sorted[i] : i+1) } return answer} 12345678def solution(citations): h = 0 for i, c in enumerate(sorted(citations,reverse=True)): if h &gt; c: return h else: h = (c if c &lt;= (i+1) else i+1) return h 설명 정렬(sort)하지 않고서는 O(N2)이상의 풀이 방법이 없었다. 배열을 내림정렬을 한 뒤, 앞에서 부터 index와 값을 비교하여 최대값을 갱신시켜주면 된다. 여기서 index는 자연스럽게 현재 값보다 같거나 큰 값들의 개수가 된다(정확히는 i+1이). 내가 염려했던 부분은 [5,5,5,5,0]와 같은 배열이었는데, 이 배열의 h값은 4가 나와야 한다. 즉, 배열에 포함되어 있지 않은 값으로도 h가 갱신되어야 한다. 따라서 index와 값을 비교하여 더 낮은 값으로 갱신을 진행했다. 정렬 한 뒤에는 O(N)풀이 인데, 평균적으로는 훨씬 적을 것으로 예상된다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/H-Index/"},{"title":"[프로그래머스] 가장 큰 정사각형 찾기","text":"가장 큰 정사각형 찾기JavaScript, Python 문제 설명1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다. 입출력 예 board answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 설명입출력 예 #1위의 예시와 같습니다. 입출력 예 #2| 0 | 0 | 1 | 1 || 1 | 1 | 1 | 1 |로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다. 풀이 javascript123456789101112131415161718function solution(board) { var answer = 0; answer = board.filter((b)=&gt;b.filter((v)=&gt;v===1).length).length &gt; 0 ? 1 : 0 for (let y = 1; y &lt; board.length; y++) { for (let x = 1; x &lt; board[0].length; x++) { if (board[y][x] === 1) { board[y][x] = (Math.min(board[y][x - 1], board[y - 1][x - 1], board[y - 1][x])) + 1; if (board[y][x] &gt; answer) { answer = board[y][x]; } } } } return answer * answer;} 123456789101112def solution(board): answer = 0 if sum([sum(b) for b in board]) == 0 else 1 for i in range(1,len(board)): for j in range(1,len(board[i])): if board[i][j]: board[i][j] = min(board[i][j-1],board[i-1][j-1],board[i-1][j]) + 1 if board[i][j] &gt; answer: answer = board[i][j] return answer ** 2 설명 배열의 정사각형 부분을 간략히 표현하기 위한 방법을 고민했다. 가장 단순하게 각 점마다 사각형을 확인해보는 함수는 O(N4)까지 효율성이 떨어졌기 때문에, 되도록 O(N2)을 이용하는 방법을 고민했다. 각 열 혹은 행의 합을 이용해서 풀이할 수 있는 방법이 있을까 생각해봤다(스도쿠). 그러나 각 라인 값의 합 만으로는 정사각형을 특정할 수 없었고 결국 배열을 다시 확인하는 작업이 수반되어야 했다. 그러던 중 탐색해 나아갈때마다 값을 누적하는 방식의 풀이를 접하게 되었고, 현재 탐색 점 기준 왼쪽 위로 2x2 사각형의 값을 누적하는 방식의 풀이법을 알게 되었다. 이 때, 3영역의 값 중 최소값을 불러오는데, 이는 사각형을 온전히 이루고 있는지 판단하기 위한 방법이다. 시작 1 1 1 1 1 1 1 1 1 1단계 (1,1)(1,1) -&gt; [ 상단 : 1 , 좌측 : 1 , 좌측 상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 1 1 1 1 2단계 (1,2)(1,2) -&gt; [ 상단 : 1 ,좌측 : 1 ,좌측상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 2 1 1 1 3단계 (2,1)(2,1) -&gt; [ 상단 : 1 ,좌측 : 1 ,좌측상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 2 1 2 1 4단계 (2,2)(2,2) -&gt; [ 상단 : 2 ,좌측 : 2 ,좌측상단 : 2 ] 이므로 -&gt; 3 1 1 1 1 2 2 1 2 3 이 과정에서 탐색 값 중 0의 값이 포함되어 있다면 현재 값은 오직 1을 갖는다. 따라서 해당 방법으로 (i,j)가 온전한 사각형인지, 만약 그렇다면 얼만큼의 크기를 갖는지 알 수 있다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EA%B0%80%EC%9E%A5%20%ED%81%B0%20%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95%20%EC%B0%BE%EA%B8%B0/"},{"title":"[프로그래머스] 가장 큰 수","text":"가장 큰 수JavaScript, Python 문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 입출력 예 numbers return [6, 10, 2] “6210” [3, 30, 34, 5, 9] “9534330” 풀이 javascript12345678function solution(numbers) { const sortFunc = (a,b) =&gt; { return ((b+'') + (a+''))*1 - ((a+'')+(b+''))*1 } var answer = numbers.sort(sortFunc).join(''); return answer*1 ? answer : &quot;0&quot;} 12345678910from functools import cmp_to_keydef solution(numbers): def sort_func(a,b): if int(a+b) &gt; int(b+a) : return -1 else : return 1 return str(int(''.join(sorted([str(i) for i in numbers],key=cmp_to_key(sort_func))))) 설명 문자열 그대로 합친숫자(ex: 6+10 = 610)를 기준으로 정렬하여 풀었다. 자바스크립트에서는 정렬 기준 비교 함수를 직접 지정할 수 있지만, 파이썬에서는 기본함수에서 이를 제공하지 않는다. 따라서 functools 패키지의 cpm_to_key함수를 써야한다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EA%B0%80%EC%9E%A5%20%ED%81%B0%20%EC%88%98/"},{"title":"[프로그래머스] 구명 보트","text":"구명보트JavaScript, Python 문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 풀이 javascript1234567891011121314151617181920212223242526272829303132333435363738function solution(people, limit) { let answer = 0; let s = 0, e = people.length-1; people = people.sort((a,b)=&gt;a-b) while(s &lt; e){ if(people[s] &gt; limit/2) return answer + e - s + 1 if(people[s] + people[e] &lt;= limit){ answer++; s++; e--; } else{ answer++; e--; } } return s === e ? answer + 1 : answer;}``` #### python```pythondef solution(people, limit): answer = 0 s = 0 e = len(people)-1 people.sort() while people[s] &lt;= limit/2 and s &lt; e: if people[s] + people[e] &gt; limit: e -= 1 else: e -= 1 s += 1 answer += 1 return answer + e - s + 1 설명 구명보트에는 최대 2명까지 탑승할 수 있다는 것이 가장 큰 힌트였다.그렇지 않으면 적은 무게의 사람들이 3명 이상 탈 수 있는데, 이 경우 문제가 매우 복잡해진다. 최대 2명이 탈 수 있다면, 몸무게가 큰 사람들과 작은 사람들을 함께 태우면 된다.따라서 배열을 무게순으로 정렬하고, 인덱스 시작과 끝에 header와 tail에 해당하는 변수를 설정한다. 그 뒤 현재 선택된 무거운 사람(변수 e)과 현재 선택된 가벼운 사람(변수 s)을 비교한다. 이 때, s와 e에 해당하는 두 사람의 무게를 비교하여 두 사람 무게의 합이 limit 무게를 안넘으면 둘을 모두 탑승시킨다. 그 뒤 s를 한칸 뒤로, e를 한칸 앞으로 땡긴다. 두 사람 무게의 합이 limit 무게를 넘으면 큰 사람만 탑승시킨다. 그 뒤 e를 한칸 앞으로 땡긴다. 만약 현재 탑승하지 않은 가장 가벼운 사람(s)의 무게가 limit/2 초과하면 남은 모든 사람을 각자 혼자 태운다. 이 과정을 반복시키면 함께 탈 수 있는 2명 보트의 개수를 최적화 할 수 있다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EA%B5%AC%EB%AA%85%20%EB%B3%B4%ED%8A%B8/"},{"title":"[프로그래머스] 괄호 변환","text":"괄호 변환Python 문제 설명카카오에 신입 개발자로 입사한 “콘”은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.수정해야 할 소스 파일이 너무 많아서 고민하던 “콘”은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의‘(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.예를 들어, &quot;(()))(&quot;와 같은 문자열은 “균형잡힌 괄호 문자열” 이지만 “올바른 괄호 문자열”은 아닙니다.반면에 &quot;(())()&quot;와 같은 문자열은 “균형잡힌 괄호 문자열” 이면서 동시에 “올바른 괄호 문자열” 입니다. ‘(‘ 와 ‘)’ 로만 이루어진 문자열 w가 “균형잡힌 괄호 문자열” 이라면 다음과 같은 과정을 통해 “올바른 괄호 문자열”로 변환할 수 있습니다. 12345678910111. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.2. 문자열 w를 두 &quot;균형잡힌 괄호 문자열&quot; u, v로 분리합니다. 단, u는 &quot;균형잡힌 괄호 문자열&quot;로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.3. 문자열 u가 &quot;올바른 괄호 문자열&quot; 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.4. 문자열 u가 &quot;올바른 괄호 문자열&quot;이 아니라면 아래 과정을 수행합니다. 4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 4-3. ')'를 다시 붙입니다. 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 4-5. 생성된 문자열을 반환합니다. “균형잡힌 괄호 문자열” p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 “올바른 괄호 문자열”로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요. 매개변수 설명 p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다. 만약 p가 이미 “올바른 괄호 문자열”이라면 그대로 return 하면 됩니다. 입출력 예 p result &quot;(()())()&quot; &quot;(()())()&quot; &quot;)(&quot; &quot;()&quot; &quot;()))((()&quot; &quot;()(())()&quot; 입출력 예에 대한 설명입출력 예 #1이미 “올바른 괄호 문자열” 입니다. 입출력 예 #2 두 문자열 u, v로 분리합니다. u = &quot;)(&quot; v = &quot;&quot; u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 &quot;&quot;이 됩니다. 따라서 생성되는 문자열은 &quot;(&quot; + &quot;&quot; + &quot;)&quot; + &quot;&quot;이며, 최종적으로 &quot;()&quot;로 변환됩니다. 입출력 예 #3 두 문자열 u, v로 분리합니다. u = &quot;()&quot; v = &quot;))((()&quot; 문자열 u가 “올바른 괄호 문자열”이므로 그대로 두고, v에 대해 재귀적으로 수행합니다. 다시 두 문자열 u, v로 분리합니다. u = &quot;))((&quot; v = &quot;()&quot; u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 &quot;()&quot;이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 &quot;()&quot;이 됩니다. 따라서 생성되는 문자열은 &quot;(&quot; + &quot;()&quot; + &quot;)&quot; + &quot;()&quot;이며, 최종적으로 &quot;(())()&quot;를 반환합니다. 처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면 &quot;()&quot; + &quot;(())()&quot; = &quot;()(())()&quot;가 됩니다. 혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 (클릭) 풀이 python 1차 풀이123456789101112131415161718192021222324252627282930313233343536373839def solution(p): count_s = {'(':1,')':-1} def changeU(u): return ''.join([ ')' if s == '(' else '(' for s in u[1:-1]]) def splitUV(s): count = 0 isRight = True for i,c in enumerate(s): count += count_s[c] if count &lt; 0: isRight = False elif count == 0: return (isRight, count == 0,s[:i+1],s[i+1:]) def sol(s): if s == '': return '' r,b,u,v = splitUV(s) if r: return u + sol(v) else: return '(' + sol(v) + ')' + changeU(u) return sol(p)``` #### python 1차풀이 간략화```pythondef solution(p): if p =='': return p r = True; count = 0 for i,v in enumerate(p): if v == '(': count += 1 else: count -= 1 if count &lt; 0 : r = False if count == 0: if r: return p[:i+1] + solution(p[i+1:]) else: return '('+solution(p[i+1:])+')'+ ''.join([')' if s == '(' else '(' for s in p[1:i]]) 설명 올바른 괄호 문제의 심화 버전. 실제 대기업 코딩 테스트에서도 흡사한 유형의 문제가 출제되었다. 풀이는 올바른 괄호 문제에서와 같이 count 변수를 이용해 올바른 괄호와 균형잡힌 괄호 여부를 판단했고, 문제의 요구사항대로 재귀함수를 이용해 어려움없이 결과값을 도출했다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EA%B4%84%ED%98%B8%20%EB%B3%80%ED%99%98/"},{"title":"[프로그래머스] 기능개발","text":"기능개발JavaScript, Python 문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명입출력 예 #1첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 입출력 예 #2모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. ※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다. 풀이 javascript1234567891011121314151617181920function solution(progresses, speeds) { var answer = []; var c = 0; while(progresses.length){ if(progresses[0] &lt; 100) progresses = progresses.map((a,index)=&gt;a+speeds[index]) else{ var count = 0; while(progresses.length &amp;&amp; progresses[0] &gt;= 100){ count++; progresses.shift(); speeds.shift(); } answer.push(count); } } return answer;} python123456789101112131415161718def solution(progresses, speeds): answer = [] count = 0 while len(progresses): if progresses[0] &gt;= 100: progresses.pop(0) speeds.pop(0) count += 1 continue; elif count &gt; 0: answer.append(count) count = 0 for i, v in enumerate(progresses): progresses[i] += speeds[i] answer.append(count) return answer 설명 자료구조 큐를 활용한 문제다. python의 list와 javascript array에서 각각 일반적인 FIFO의 큐를 구현할 수 있다. python javascript 삽입 append(v) push(v) 삭제 pop(0) shift() 해당 문제에선 Queue의 삭제 기능만을 사용하여 쉽게 구현할 수 있었다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/"},{"title":"[프로그래머스] 메뉴 리뉴얼","text":"메뉴 리뉴얼JavaScript, Python 문제 설명레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 “스카피”는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다. 예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,(각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.) 손님 번호 주문한 단품메뉴 조합 1번 손님 A, B, C, F, G 2번 손님 A, C 3번 손님 C, D, E 4번 손님 A, C, D, E 5번 손님 B, C, F, G 6번 손님 A, C, D, E, H 가장 많이 함께 주문된 단품메뉴 조합에 따라 “스카피”가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다. 코스 종류 메뉴 구성 설명 요리 2개 코스 A, C 1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다. 요리 3개 코스 C, D, E 3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다. 요리 4개 코스 B, C, F, G 1번, 5번 손님으로부터 총 2번 주문됐습니다. 요리 4개 코스 A, C, D, E 4번, 6번 손님으로부터 총 2번 주문됐습니다. [문제]각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, “스카피”가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, “스카피”가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] orders 배열의 크기는 2 이상 20 이하입니다. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다. 각 문자열은 알파벳 대문자로만 이루어져 있습니다. 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다. course 배열의 크기는 1 이상 10 이하입니다. course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다. course 배열에는 같은 값이 중복해서 들어있지 않습니다. 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요. 배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다. 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다. orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다. [입출력 예] orders course result [&quot;ABCFG&quot;, &quot;AC&quot;, &quot;CDE&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;ACDEH&quot;] [2,3,4] [&quot;AC&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;CDE&quot;] [&quot;ABCDE&quot;, &quot;AB&quot;, &quot;CD&quot;, &quot;ADE&quot;, &quot;XYZ&quot;, &quot;XYZ&quot;, &quot;ACD&quot;] [2,3,5] [&quot;ACD&quot;, &quot;AD&quot;, &quot;ADE&quot;, &quot;CD&quot;, &quot;XYZ&quot;] [&quot;XYZ&quot;, &quot;XWY&quot;, &quot;WXA&quot;] [2,3,4] [&quot;WX&quot;, &quot;XY&quot;] 입출력 예에 대한 설명 입출력 예 #1문제의 예시와 같습니다. 입출력 예 #2AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다. 입출력 예 #3WX가 두 번, XY가 두 번 주문됐습니다.3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다. 풀이javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function solution(orders, course) { var answer = []; var list = []; var counter = {}; function combination(source, target, n, r, count) { if(r === 0) list.push(target.sort().join('')); else if(n === 0 || n &lt; r) return; else { target.push(source[count]); combination(source, Object.assign([], target), n - 1, r - 1, count + 1); target.pop(); combination(source, Object.assign([], target), n - 1, r, count + 1); } } course.forEach((c)=&gt;{ orders.forEach((o)=&gt;{ var order = o.split('') combination(order, [], o.length, c, 0) }) counter[c] = 2; }) var freqTable = list.reduce((acc, menu) =&gt; { acc[menu] = (acc[menu] || 0) + 1 return acc },{}); var filteredData = {}; Object.entries(freqTable).forEach( ([key, value]) =&gt; { if(value &gt; counter[key.length]){ counter[key.length] = value; filteredData[key.length] = [key]; } else if(value === counter[key.length]){ if(!filteredData[key.length]) filteredData[key.length] = [key]; else filteredData[key.length].push(key); } } ) return Object.values(filteredData).reduce((a,b)=&gt;a.concat(b),[]).sort();} python12345678910111213141516171819202122from itertools import combinationsdef solution(orders, course): answer = [] for i in course: d = {} for o in orders: if len(o) &lt; i: continue for c in list(combinations(list(o), i)): k = ''.join(sorted(c)) if k in d: d[k] += 1; else: d[k] = 1 if len(d.values()): m = max(d.values()) if m &lt; 2 : continue; for maxValues in [mk for mk in d if d[mk] == m]: answer.append(maxValues) return sorted(answer) 설명 javascript를 너무나 힘들게 만드는 순열 조합 문제다. javascript에는 타 언어와는 달리 순열 조합 함수가 내장되어 있지 않기 때문에 이를 직접 구현해야 한다. javascript에서 재귀함수로 구현한 n 개중 r 개를 뽑는 조합 함수123456789101112function combination(source, target, n, r, count) { if(r === 0) list.push(target.sort().join('')); else if(n === 0 || n &lt; r) return; else { target.push(source[count]); combination(source, Object.assign([], target), n - 1, r - 1, count + 1); target.pop(); combination(source, Object.assign([], target), n - 1, r, count + 1); } } 그러나 파이썬은 이야기가 다르다. python 에서는 itertools 패키지에 순열, 조합 등의 기능들이 들어있어 이를 쉽게 사용할 수 있다.그러다 보니 두 언어의 코드량 차이도 엄청나다. 사실 풀이는 크게 다르지 않다. 주어진 orders의 조합을 구해서 dictionary에 쌓은 뒤,course 길이마다 요구하는 최대값들을 추려 결과 배열에 추가하는 코드다. 실제로 카카오 2021 채용 코딩테스트에서 풀었던 문제인데, javascript만 알던 나는난생 처음 짜보는 combination 함수에 많은 시간을 소진했다. 이런 차별점 때문에 뒤늦게 Python 공부를 시작하긴 했지만 다소 아쉬움이 남는 부분이다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EB%A9%94%EB%89%B4%20%EB%A6%AC%EB%89%B4%EC%96%BC/"},{"title":"[프로그래머스] 다리를 지나는 트럭","text":"다리를 지나는 트럭JavaScript 문제 설명트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다. 예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 출처 ※ 공지 - 2020년 4월 06일 테스트케이스가 추가되었습니다. 풀이javascript12345678910111213141516171819202122232425function solution(bridge_length, weight, truck_weights) { var answer = 0; var on_bridge_weight = 0; var on_bridge = []; while(truck_weights.length || on_bridge.length){ on_bridge.forEach((truck)=&gt;{ truck[0]--; }) if(on_bridge.length &amp;&amp; on_bridge[0][0] === 0){ on_bridge_weight -= on_bridge.shift()[1]; } if(on_bridge_weight + truck_weights[0] &lt;= weight){ var cur_truck = truck_weights.shift() on_bridge.push([bridge_length,cur_truck]); on_bridge_weight += cur_truck; } answer++; } return answer;} python1234567891011121314151617181920212223def solution(bridge_length, weight, truck_weights): b = [] answer = 0 while len(truck_weights) or len(b): answer += 1 returns = -1 for i in range(len(b)): if b[i][1] == 1: returns = i else: b[i][1] -= 1 for i in range(returns+1): b.pop(0) count = sum(map(lambda a:a[0],b)) if len(truck_weights) and count + truck_weights[0] &lt;= weight: t = truck_weights.pop(0) b.append([t,bridge_length]) count += t return answer python 간략화12345678910111213141516def solution(bridge_length, weight, truck_weights): q = [0] * bridge_length q_sum = 0 answer = 0 while q: answer += 1 q_sum -= q.pop(0) if truck_weights: if q_sum + truck_weights[0] &lt;= weight: t_pop = truck_weights.pop(0) q.append(t_pop) q_sum += t_pop else: q.append(0) return answer 설명 큐와 스택의 심화 문제다.다리(bridge)의 상태를 큐로 표현하여 풀었다. 문제에서 주어진 트럭의 무게 배열을 중심으로 while문을 이용한 풀이는 O(N3)를 보였다.그러나 인터넷에는 bridge를 중심으로 풀이한 O(N2) 풀이가 있다.python의 pop(0)은 O(N)을 가지는 것을 감안해도 매우 효율적인 방법이다. 당연히 풀이 코드 또한 훨씬 간결하다. (인터넷의 풀이에는 sum을 while문 안에서 사용하여 효율성이 조금 떨어졌는데, sum 변수를 활용하여 이를 개선시켰다.) 앞으로도 문제에서 주어진 변수에만 집중하는 버릇을 경계해야겠다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EB%8B%A4%EB%A6%AC%EB%A5%BC%20%EC%A7%80%EB%82%98%EB%8A%94%20%ED%8A%B8%EB%9F%AD/"},{"title":"[프로그래머스] 멀쩡한 사각형","text":"멀쩡한 사각형JavaScript 문제 설명가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요. 제한사항 W, H : 1억 이하의 자연수 입출력 예 W H result 8 12 80 입출력 예 설명입출력 예 #1가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다. 풀이 javascript1234567891011function solution(w, h) { if (w === h) return w * h - w; if (w === 1 || h === 1) return 0; let answer = 0; for(let i = 1; i &lt; w; i++) answer += Math.floor( h * i / w ) return answer * 2;} python 최소공배수 풀이123from math import gcddef solution(w,h): return w * h - (w+h) + gcd(w, h) 설명 알고리즘 보단 창의력을 요하는 수학 문제에 가깝다.문제의 인덱스마다 감소하는 진한 사각형의 개수를 구하는 식으로 풀었다. 그런데 최대공약수를 이용한 풀이도 존재했다. w와 h 입장에서 선이 지나가서 못쓸만한 사각형들을 모두 빼고,중복으로 제거된 칸의 개수(최대공약수) 만큼 더하면 된다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EB%A9%80%EC%A9%A1%ED%95%9C%20%EC%82%AC%EA%B0%81%ED%98%95/"},{"title":"[프로그래머스] 올바른 괄호","text":"올바른 괄호 Python 문제 설명괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어 “()()” 또는 “(())()” 는 올바른 괄호입니다. “)()(“ 또는 “(()(“ 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다. 입출력 예 s answer “()()” true “(())()” true “)()(“ false “(()(“ false 입출력 예 설명입출력 예 #1,2,3,4문제의 예시와 같습니다. 풀이 python12345678def solution(s): count = 0 char_value = {'(':1,')':-1} for c in s: count += char_value[c] if count &lt; 0: return False return count == 0 설명 대기업을 비롯한 여러 코딩테스트에서 마주쳤던 괄호 유형의 기본 문제다. 매우 기본적인 문제라 스택을 굳이 사용할 필요가 없었다. 핵심은 여는괄호( ‘(‘ ) 에서는 +값을, 닫히는 괄호( ‘)’ )에서는 -값을 더해서 한 번이라도 count 값이 0보다 낮아지면 올바른 괄호가 아니라는 것이다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EC%98%AC%EB%B0%94%EB%A5%B8%20%EA%B4%84%ED%98%B8/"},{"title":"[프로그래머스] 문자열 압축","text":"문자열 압축JavaScript, Python 문제 설명데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s result &quot;aabbaccc&quot; 7 &quot;ababcdcdababcdcd&quot; 9 &quot;abcabcdede&quot; 8 &quot;abcabcabcabcdededededede&quot; 14 &quot;xababcdcdababcdcd&quot; 17 입출력 예에 대한 설명입출력 예 #1 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #2 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #3 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #4 문자열을 2개 단위로 자르면 “abcabcabcabc6de” 가 됩니다.문자열을 3개 단위로 자르면 “4abcdededededede” 가 됩니다.문자열을 4개 단위로 자르면 “abcabcabcabc3dede” 가 됩니다.문자열을 6개 단위로 자를 경우 “2abcabc2dedede”가 되며, 이때의 길이가 14로 가장 짧습니다. 입출력 예 #5 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다. 혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 (클릭) 풀이javascript123456789101112131415161718192021222324252627282930function solution(s) { let answer = s.length; let word = '' let curWord = '' for(let i = 1; i&lt;= s.length/2; i++){ word = '' curWord = '' const splits = s.split('') let wordCount = 1; while(splits.length &gt; 0){ if(word.length &gt;= answer) break; let split_word = splits.splice(0,i).join('') if(split_word === curWord) wordCount++; else{ if(curWord) word += (wordCount &gt; 1? wordCount : '') + curWord wordCount = 1; curWord = split_word } } word += (wordCount &gt; 1? wordCount : '') + curWord if(word.length &lt; answer) answer = word.length } return answer} python123456789101112131415161718192021222324def solution(s): answer = len(s) for i in range(1,int(len(s)/2)+1): c = '' word = '' str_ = s b = 0 while str_: if len(word) &gt; answer: break; if c == str_[0:i]: b+=1 else: word += ( str(b) + c if b &gt; 1 else c) c = str_[0:i] b = 1 str_ = str_[i:] if len(str_) &lt; i: word += ((str(b) if b &gt;1 else '') + c + str_) if answer &gt; len(word): answer = len(word) return answer 설명 brute force를 이용한 무지성 무차별 대입 문제다. 1개부터 최소 s의길이/2 까지는 반복문을 돌려야 하며,그 때마다 문자열을 탐색하고, 반복적으로 slice 해야한다. 보통의 경우 slice 함수는 O(N)을 따르므로이 풀이의 복잡도는 O(N3)이 된다.","link":"/2021/06/30/til/algorithm%20test/programmers/lv2/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EC%95%95%EC%B6%95/"}],"tags":[{"name":"카멜마운트","slug":"카멜마운트","link":"/tags/%EC%B9%B4%EB%A9%9C%EB%A7%88%EC%9A%B4%ED%8A%B8/"},{"name":"모니터암","slug":"모니터암","link":"/tags/%EB%AA%A8%EB%8B%88%ED%84%B0%EC%95%94/"},{"name":"후기","slug":"후기","link":"/tags/%ED%9B%84%EA%B8%B0/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"UMA-2","slug":"UMA-2","link":"/tags/UMA-2/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"디버깅","slug":"디버깅","link":"/tags/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"Drive","slug":"Drive","link":"/tags/Drive/"},{"name":"Code-36","slug":"Code-36","link":"/tags/Code-36/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"lv1","slug":"lv1","link":"/tags/lv1/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"N진법","slug":"N진법","link":"/tags/N%EC%A7%84%EB%B2%95/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Date","slug":"Date","link":"/tags/Date/"},{"name":"lv2","slug":"lv2","link":"/tags/lv2/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"괄호","slug":"괄호","link":"/tags/%EA%B4%84%ED%98%B8/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"순열 조합","slug":"순열-조합","link":"/tags/%EC%88%9C%EC%97%B4-%EC%A1%B0%ED%95%A9/"},{"name":"수학","slug":"수학","link":"/tags/%EC%88%98%ED%95%99/"}],"categories":[{"name":"일상","slug":"일상","link":"/categories/%EC%9D%BC%EC%83%81/"},{"name":"디버깅","slug":"디버깅","link":"/categories/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"후기","slug":"일상/후기","link":"/categories/%EC%9D%BC%EC%83%81/%ED%9B%84%EA%B8%B0/"},{"name":"기타 오류","slug":"디버깅/기타-오류","link":"/categories/%EB%94%94%EB%B2%84%EA%B9%85/%EA%B8%B0%ED%83%80-%EC%98%A4%EB%A5%98/"},{"name":"알고리즘","slug":"TIL/알고리즘","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"프로그래머스","slug":"TIL/알고리즘/프로그래머스","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"lv2","slug":"TIL/알고리즘/프로그래머스/lv2","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/"},{"name":"lv1","slug":"TIL/알고리즘/프로그래머스/lv1","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/"}]}