{"pages":[],"posts":[{"title":"카멜마운트 UMA-2 모니터암 + 선정리 후기","text":"이 포스팅은 쿠팡 파트너스 활동의 일환으로, 이에 따른 일정액의 수수료를 제공받습니다. 🙌 선요약 필자는 Dell U2718Q 제품과 U2414H 제품을 사용중이다. 덧붙여 맥+데탑+PS4의 조합을 위해 HDMI, USB 선택기를 사용한다. 그러다보니 선들이 매우 혼잡스러웠고, 카멜 마운트 UMA-2 모니터암 2개로 혼내줬다. 선정리가 필요해 필자는 듀얼모니터로 4k 모니터인 dell u2718q와 fhd모니터인 u2414h를 사용중이다. 이 모니터들로 데스크탑, 맥북(현재는 맥 미니로 대체), 플스를 사용중이고 이를 위해 HDMI 선택기와 USB 선택기를 각각 사용하고 있다. 그렇기 때문에 책상 뒷편은 복잡한 선들로 뒤덮였다. 이런 것들은 실제로 컴퓨터 작업을 할때 꽤나 신경이 쓰이고, 알게 모르게 나의 정신 에너지를 갉아먹고 있다는 생각이 들었다. 그래서 나는 모니터암을 사기로 결심했다. 모니터암 후보는 굉장히 많았다. 나는 보통 물건을 고를 때 다음과 같은 것들을 참고한다. 유명 리뷰 유튜버가 ‘광고’ 없이 찍은 리뷰를 참고한다. 구글링으로 각종 커뮤니티 관련 게시물을 참고한다. 쿠팡(혹은 네이버쇼핑) 리뷰를 확인한다. 지인에게 자문을 구한다. 그런 기준들에서 공통적으로 카멜 마운트 브랜드가 거론되었고, 내게 적합하다고 판단했다. 그 중에서도 UMA-2 제품을 사기로 마음먹었는데, 알루미늄 소재라는 점과 10kg까지 버티는 중량 때문이었다. 내가 사용하는 U2718Q 4K 모니터 무게가 9.3kg이나 나가기 때문이다. 아래는 순서대로 UMA-2, UMA-2H(10~20kg 고중량)다.나는 두 가지 제품을 고민하던 끝에 UMA-2를 선택했다. 설치 Before &amp; After 설치 전 이랬던 선들이... ![엄청나게 지저분한 선들...](/img/post_images/일상/후기/line_before.jpeg \"엄청나게 지저분한 선들...\") 이렇게 정리됐다 ![깔끔하게 세팅된 책상 (선택기들이 아쉽다)](/img/post_images/일상/후기/line_after.jpeg \"깔끔하게 세팅된 책상\") >모니터암의 위력은 대단했다! 빨간 선은 보조 모니터의 썬더볼트3 to hdmi 케이블인데, 3m 이상 제품을 구할수가 없었다. 어찌됐든 굉장히 만족할 정도로 정리가 됐다. 왜 다들 모니터암 모니터암 하는지 알 수 있었다. 무엇보다 알루미늄 소재인 UMA-2의 고급스러움이 굉장히 만족스럽다. 모니터암 입문을 고민하고 있다면, 정말 강력히 추천한다. 리뷰 끝.","link":"/2021/06/26/3fd9ccd635f7/"},{"title":"gitalk Redirect UriError in Hexo","text":"Abstractin _config.yml file _permalink_ option, change ‘:title’ to other optionSee here : permalinks example before : permalink: ‘:year/:month/:day/:title‘after : permalink: ‘:year/:month/:day/:hash‘ Hexo 블로그에서 Gitalk Redirect_url 오류 해결법 증상Hexo blog comments 기능 중 하나인 Gitalk의 초기화가 되지 않는 현상 원인Redirect_url의 encoding 문제.한글이나 특수 문자가 섞여 있을 경우 오류가 나는것으로 예상 솔루션 ‘_config.yml’ 파일의 permalink 값에서 title을 hash로 변경한다. url에서 title값을 hash값으로 변경해주는 값으로써, url에서 인코딩 문제를 일으킨 한글이나 특수문자가 사라진다. 더 이상 url을 통해 글을 구분할 수 없다는 단점이 있다. 옵션 값 참조 : permalinks","link":"/2021/06/13/f46a05dfa79c/"},{"title":"외장하드 오류코드-36 해결법 (Fix Drive Error Code-36 in Mac)","text":"선 요약 ❓❓❓ Problem ❓❓❓ 맥북과 윈도우를 오가며 공용으로 사용하던 NTFS 포맷의 외장하드에서 오류 발생 (mac) 파일 이동이 불가능한 현상 (Error Code - 36) ❕❕❕ Solution ❕❕❕ ❌ dot_clean 명령어 사용했으나 실패, 이후 설정 폴더들 사라지는 추가 문제 발생❌ 파일 복구 시스템(disk drill, easyUS, etc .. ) 사용 -&gt; 온전히 복구 실패✅ windows OS cmd 에서 chkdsk로 해결 문제 발생 Mac과 Windows 를 동시에 사용하는 나는, 두 데스크탑에서 데이터를 공유하기 위해 USB 허브에 외장 드라이브를 물려 사용해왔다. 처음에 맥에서 외장하드를 연결했을때, 윈도우에서 사용하던 드라이브의 사용이 불가능 했다. 그 이유는 드라이브의 파일 시스템 때문이었다. 기존 사용하던 FAT32 파일 시스템이 맥에서는 사용이 안됐기 때문에, 어쩔 수 없이 NTFS로 포멧하여 사용해야 했다. ❗️ Error Code 36 The Finder can’t complete the operation because some data in “FileName” can’t be read or written. (Error code -36) 그런데 어느 날 Mac에서 작성한 작업 파일이 드라이브에 복사가 되지 않았다.문제는 error code 36이었다. 오류 코드 36은 맥 OS에서 자주 발생하는 나름 악명높은(?) 오류였다. 간단히 설명하면 NTFS 파일 시스템의 드라이브를 맥에서 이용할 때, 드라이브가 꼬이는 문제였다.백업 전용 드라이브라 파일을 반드시 저장해야 하는데, 파일이 이동되지 않으니 참으로 난감한 상황이었다. 이때 그냥 윈도우로 옮겨 저장했어야 했는데… 🤔 당시엔 단순히 가벼운 오류라 생각해서 맥에서 이를 해결해보려 했다. 시행착오 처음 구글링을 통해 시행한 방법은 dot_clean 이었다.특정 macOS 파일을 HFS+/APFS 형식이 지정되지 않은 디스크(예: 파일 공유)에 복사하면 메타데이터가 파일에서 추출되어 dot(‘._’)로 시작하는 보이지 않는 파일에 넣는다고 한다. 이런 숨겨진 시스템 파일을 전송하려는 시도에서 Error Code-36이 자주 발생한다고 한다.이 dot 파일들을 쉽게 정리하는 명령어가 바로 dot_clean 이다.이는 단순 파일 삭제가 아니라 원본과 병합하는 과정을 거치기 때문에 안전(?)하다고 한다. 사용 방법은 간단하다. 1dot_clean /Volumes/MY_VOLUME_PATH 파일 이동이 안되는 드라이브의 경로를 입력해주면 된다.그런데 나는 이때 딱히 변화를 감지하지 못했다. 그래서 볼륨의 루트 경로 한 번, 문제되는 폴더 경로 한 번.총 2번의 dot_clean을 시행했다.사실 각각 시행해도 달라지는건 없었다. 문제는 연결을 잠시 해제(안전하게)하고 난 뒤였다. 폴더 내부 파일의 절반이 날아가버린 것이다. 이어지는 뻘짓 처음엔 너무 당황스러웠다. 마치 약을 먹었는데 그게 더 독이 되어버린 경우였다. 충분히 의심되는 여러 증상들(새 폴더를 생성하면 순식간에 Finder에서 사라지는 등)이 있었지만, 내 머릿속에는 따로 백업도 안된 채 날아간 중요 파일들에대한 걱정 뿐이였다. 나는 결국 데이터 복구 프로그램을 찾기 시작했다. 일단 시중의 Mac용 Drive 복구 프로그램중 제일 유명해보이는 Disk drill과 easyUS, 기타 이름모를 복구 프로그램들을 닥치는대로 받아가며 복구가 가능한지 시도해봤다. 그 중 가장 유의미하게 복구가 가능한 것으로 보여지는 것은 Disk drill이었다.그러나 그 마저도 잃어버린 50% 파일 중 20%정도 남짓에 불과했다.그 20% 안에는 중요 계약 서류들이 있어서 이것을 돈주고 복구해야 하는지 내적고민을 엄청나게 했다. 약 10만원 가량의 비용이었기 때문에 정말 앉아서 돈을 잃는 경우라고 생각했고, 조금은 이성을 되찾기로 했다. 이어지는 고민과 명상 도중 드는 생각은 Mac은 왜이렇게 불안정할까 였다.윈도우에선 이런일이 없었는디… 라는 생각이 들었고,이 흐름은 마침내 Windows의 chkdsk 기능으로 도달했다. 🔥아 맞다 그런게 있었지!!!!! 🔥 CHKDSK로 해결 Windows의 CHKDSK 기능은 정말 막강하다. CHKDSK는 다양한 메모리 관련 문제를 예방하고 해결하기 위한 윈도우의 자체적인 기능이다.드라이브 포멧을 하던 중 이상이 생겼을 때도, 이 CHKDSK 기능을 활용하여 고쳤던 기억이 났다. 사용법 또한 간단하다. CMD 창을 켠 후 12chkdsk DRIVE_PATH /f /r# DRIVE_PATH 는 자신의 볼륨 주소 (D:, F: 등) 를 입력하면 된다. /f는 디스크에 있는 파일 시스템 오류를 자동으로 수정한다. (빠르다) /r은 불량 섹터를 검사하고 발견되면 복구를 시도한다.작업시간이 매우 느리므로 주의 ❗ ️(수 시간 소요, 도중 취소 불가) 이 작업을 하자 거짓말처럼 드라이브가 깨끗히 복구되었고,심지어 맥에서 생성한 빈 폴더마저 나타났다. 이 문제 때문에 몇 시간을 골머리 썩히며 고생했지만,정말 다행인 점은 복구 프로그램을 결제하지 않았다는 사실이다. 요즘 맥을 메인으로 사용하다보니 이러한 메모리 관련 문제가 자주 발생하는데,그때 마다 정말 윈도우가 선녀였다는 생각이 들곤 한다.","link":"/2021/06/30/2e9ce59f5c23/"},{"title":"[TypeScript] 타입스크립트 시작하기","text":"타입스크립트가 필요한 이유 타입스크립트는 자바스크립트의 슈퍼셋이다JS의 모든 기능을 사용할 수 있을 뿐만 아니라, 추가 장점 기능들을 모두 사용할 수 있는 슈퍼셋이다. 자바스크립트를 대체한다가 아닌 슈퍼셋의 입장으로 공생의 전략을 취하는 언어다. TypeScript 예시 코드123456789101112// custom type을 생성하여 명시적 선언 가능type Centimeter = number;type RainbowColor = 'red'|'orange'|'yellow'|'green'|'blue'|'navy'|'purple';// 변수 뒤에 :type을 명시 let age:number = 10;let weight:number = 80;let height:Centimeter = 176; let color:RainbowColor = 'orange';// it will be errorcolor = 'black'; JS 프로젝트를 TS 프로젝트로 바꾸기 [parcel.js 기준] 변경할 파일의 파일명 확장자 변경 변경된 파일명 참조값 확인 tsconfig.json 파일 생성 폴더 root에 tsconfig.json 파일을 생성 tsconfig.json 옵션 1234567891011{ &quot;compilerOptions&quot;: { &quot;strict&quot;: true, &quot;target&quot;: &quot;ES5&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;alwaysStrict&quot;: true, &quot;noImplicitAny&quot;: true, &quot;sourceMap&quot;: true, &quot;downlevelIteration&quot;: true }} strict : 코드 작성시 TS 규칙을 강하게 적용할지 여부 target : TS 파일을 컴파일하여 생성된 JS 파일이 사용할 문법체계 버전 module : 모듈 시스템 버전 선택 alwaysStrict : 코드를 ECMAScript Strict 모드로 분석하고 각 소스파일들에 적용 noImplicitAny : Any 타입 사용 여부 (true 선택시 명확히 타입 기술 필요) sourceMap : TS 결과를 출력해놓은 dist 폴더에 소스맵 파일 저장 여부 소스맵 파일 : 변환된 JS파일에서 문제점을 찾기 어려울 수 있으므로 작성한 TS 코드를 그대로 저장해 놓은 데이터 파일 downlevelIteration : 다운레벨링(이전 버전의 자바스크립트로 변환) 방법 결정 활성화시 importHelpers 를 통해 tslib 를 사용하여 인라인 자바스크립트의 양을 줄일 수 있음 비활성화시 모든 object의 루프가 기존 루프(for/ of for)로 다운레벨화 TSConfig 상세 문서","link":"/2021/07/22/f45e47e55d93/"},{"title":"[프로그래머스] 2016년","text":"2016년JavaScript, Python 문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요. 제한 조건 2016년은 윤년입니다. 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 “TUE” 풀이 javascript1234567891011function solution(a, b) { var daysOfMonth = [31,29,31,30,31,30,31,31,30,31,30,31] var days = [&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;,&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;] var getDaySum = (index)=&gt;{ let result = 0 for(let i = 0; i &lt; index; i++) result += daysOfMonth[i] return result } return days[ (getDaySum(a-1) + b-1) % 7]} Date 클래스 이용 풀이1234567891011121314function solution(a, b) { var date = new Date(2016, (a - 1), b); return date.toString().slice(0, 3).toUpperCase();}``` #### python```pythonimport datetimedef solution(a, b): d = datetime.datetime(2016,a,b) - datetime.datetime(2016,1,1) return ('FRI','SAT','SUN','MON','TUE','WED','THU')[d.days % 7] 설명 기본적인 Date 객체 활용 문제다. 해당 문제는 실제 날짜를 활용했기 때문에 가볍게 Date 객체를 활용하여 풀 수 있다.(2번째, 3번째 풀이) 그러나 가끔 등장하는 가상의 날짜를 이용한 문제를 맞이하면 단순히 Date 객체를 활용하여 문제를 풀기 어려울 수 있다. (30일로만 이루어진 달, 가상의 윤달 및 윤년 설정 등) 따라서 직접 달마다 날짜 수를 설정해 문제를 푸는 방법을 연습해둬야 한다(1번째 풀이)","link":"/2021/07/07/4fb39c8d33cc/"},{"title":"[프로그래머스] k번째 수","text":"K번째수JavaScript, Python 문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\\[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\\[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 출처 풀이 javascript12345678910111213function solution(array, commands) { var answer = []; const compare = (a,b)=&gt;a-b for(let i =0; i &lt; commands.length; i ++){ // 입력값 검증 if((commands[i][1] - commands[i][0] + 1) &lt; commands[i][2]) continue; var divided = array.slice(commands[i][0]-1,commands[i][1]).sort(compare) answer.push(divided[commands[i][2]-1]) } return answer;} python12def solution(array, commands): return [sorted(array[i-1:j])[k-1] for [i,j,k] in commands] 설명 자르고, 정렬하고, 인덱싱하면 되는 간단한 문제다. javascript 풀이의 경우 따로 문제에서 언급하지 않은 입력값 검증을 추가했다.","link":"/2021/06/18/d42954fddad0/"},{"title":"[프로그래머스] 3진법 뒤집기","text":"3진법 뒤집기JavaScript, Python 문제 설명자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 100,000,000 이하인 자연수입니다. 입출력 예 n result 45 7 125 229 입출력 예 설명입출력 예 #1 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 45 1200 0021 7 따라서 7을 return 해야 합니다. 입출력 예 #2 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 125 11122 22111 229 따라서 229를 return 해야 합니다. 풀이 javascript12345678910111213141516171819202122232425262728293031323334function solution(n) { var answer = 0; function toBaseThree(num){ var value = '' var maxPow = 1 while( num/(maxPow*3) &gt;= 1) maxPow *= 3 for(let i = maxPow; i&gt;=1; i/=3){ var val = Math.floor(num / i) value += val num %= i } return value } toBaseThree(n).split('').forEach((v,i)=&gt;{ answer += (v * Math.pow(3,i)) }) return answer}``` #### python```pythondef solution(n): answer = '' while n &gt;= 1: n, d = divmod(n,3) answer += str(d) answer = int(answer,3) return answer 설명 문제에서 요구되는 능력은 사용하는 언어의 진법 표현 방법을 아느냐(python 풀이)와 진법 변환을 직접 구현할 수 있느냐(javascript 풀이)이다. 자바스크립트로 풀때는 직접 진법 변환을 구현해보고 싶어서 위와같이 풀었고, 파이썬에서는 내장 함수를 이용했다. javascript 또한 toString() 함수를 이용해 진법을 표현할 수 있다.","link":"/2021/07/07/a55747eb33ef/"},{"title":"[프로그래머스] 숫자 문자열과 영단어","text":"숫자 문자열과 영단어Python3 문제 설명 네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다. 1478 → “one4seveneight” 234567 → “23four5six7” 10203 → “1zerotwozero3” 이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요. 참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다. 숫자 영단어 0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 제한사항 1 ≤ s의 길이 ≤ 50 s가 “zero” 또는 “0”으로 시작하는 경우는 주어지지 않습니다. return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다. 입출력 예 s result &quot;one4seveneight&quot; 1478 &quot;23four5six7&quot; 234567 &quot;2three45sixseven&quot; 234567 &quot;123&quot; 123 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 “three”는 3, “six”는 6, “seven”은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다. 입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다. 입출력 예 #4 s에는 영단어로 바뀐 부분이 없습니다. 제한시간 안내 정확성 테스트 : 10초 풀이 12345def solution(s): numbers = {0:'zero',1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine'} for k,v in numbers.items(): s = s.replace(v,str(k)) return int(s) 설명 카카오 채용연계 인턴십에서 풀었던 첫 번째 문제. 문자열에서 영단어를 숫자로 변환하면 되는 간단한 문제다.","link":"/2021/07/13/03d200f6b7d0/"},{"title":"[프로그래머스] 정수 삼각형","text":"정수 삼각형Python3 문제 설명 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요. 제한사항 삼각형의 높이는 1 이상 500 이하입니다. 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다. 입출력 예 triangle result [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] 30 출처 풀이 python12345678def solution(triangle): t = triangle for i in range(1, len(t)): for j in range(len(t[i])): if 0 &lt; j &lt; len(t[i])-1:t[i][j]+= max(t[i-1][j-1], t[i-1][j]) elif j == 0: t[i][j] += t[i-1][j] else : t[i][j] += t[i-1][j-1] return max(t[-1]) 설명 DP 유형의 기본 예제. 배열의 반복문을 돌며 윗 층에서 내려올 수 있는 두 방향 왼쪽과 오른쪽 중 큰 값을 더하며 내려간다. 이를통해 현재 기준 최대의 값을 할당할 수 있고, 계산이 끝난 뒤 마지막 배열에서 최대값을 찾으면 된다.","link":"/2021/07/06/04e4722f4615/"},{"title":"[프로그래머스] 체육복","text":"체육복Python3 문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #1\\1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #2\\3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 출처 ※ 공지 - 2019년 2월 18일 지문이 리뉴얼되었습니다.\\※ 공지 - 2019년 2월 27일, 28일 테스트케이스가 추가되었습니다. 풀이 1234567891011121314def solution(n, lost, reserve): answer = 0 for idx, std in enumerate(tuple(lost)): if std in reserve: lost.remove(std) reserve.remove(std) elif std-1 in reserve: lost.remove(std) reserve.remove(std-1) elif (std+1 in reserve) and (std+1 not in lost): lost.remove(std) reserve.remove(std+1) answer = n-len(lost) return answer 설명 탐욕법을 사용하여 간단하게 해결할 수 있는 기본 문제다. 문제의 조건대로 lost의 배열을 조회하며 lost와 reserve를 수정한다. lost 배열의 반복문을 돌며 lost 배열을 수정하면 반복문에 문제가 생기므로 tuple을 통해 값을 복사하여 반복문을 시행해야 한다. 각 for문의 선택이 다른 선택에 관여하지 않으므로, 탐욕법 풀이가 가능한 문제다.","link":"/2021/07/22/39a5af197eb7/"},{"title":"[프로그래머스] n으로 표현","text":"N으로 표현Python3 문제 설명아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다. 12 = 5 + 5 + (5 / 5) + (5 / 5)\\12 = 55 / 5 + 5 / 5\\12 = (55 + 5) / 5 5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.\\이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요. 제한사항 N은 1 이상 9 이하입니다. number는 1 이상 32,000 이하입니다. 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다. 최솟값이 8보다 크면 -1을 return 합니다. 입출력 예 N number return 5 12 4 2 11 3 입출력 예 설명예제 #1\\문제에 나온 예와 같습니다. 예제 #2\\11 = 22 / 2와 같이 2를 3번만 사용하여 표현할 수 있습니다. 출처 ※ 공지 - 2020년 9월 3일 테스트케이스가 추가되었습니다. 풀이 python123456789101112131415161718192021222324answer = -1def solution(N, number): def sol(count, result): global answer temp = N if count &gt; 8 : return if result == number : if answer &gt; count or answer == -1: answer = count return for i in range(8-count): sol(count+i+1, result + temp) sol(count+i+1, result - temp) sol(count+i+1, result * temp) sol(count+i+1, int(result / temp)) temp = (temp * 10) + N sol(0,0) return answer 설명 난이도 3의 DP(Dynamic Programming, 동적 계획법) 문제다.처음 접했을때 약 4번이나 풀이 방법을 바꿔가며 풀어봤지만 모두 실패했다. 처음엔 BFS 처럼 사칙연산 기호들을 이어붙이는 식으로 풀이를 해보려 했다가 낭패를 봤다. 두 번째에는 딕셔너리를 활용해 연산값을 계속 저장하며 문제를 풀어보려 시도했다. 결과는 역시나 실패. 테스트 케이스 몇 개가 끝까지 해결이 안되었다. 여기서 괄호의 개념을 도입해야 한다는 판단이 들었는데, 이마저 BFS 형식으로 구현하면 시간초과가 날 것이 분명했다. 또한 풀이때 연산 방향에 신경썼는데 지금 생각해보면 전혀 필요 없는 부분이라 그땐 왜 그랬는지 모르겠다. 집중력이 저하된 것 같다. 세 번째 방법은 위에서 쓴 딕셔너리 내의 두 값을 자발적으로 비교하는 방식으로 진행했다. 역시나 풀리지 않는 테스트 케이스들과 시간 초과로 실패했다. 이론상 N값을 이용해 4번의 사칙연산 결과만 저장해 놓으면, 나머지 값들의 비교로 최대 8의 결과값을 구할 수 있다. 그러나 4번째의 딕셔너리 연산이 시간초과를 불러왔다. 네 번째 방법은 위 세 번째 방법과 네 번째 방법을 합쳐서 활용했는데, 풀면서도 절대로 이런식의 풀이가 성공할리 없다는 확신이 들었다. 풀이가 구질구질(?)해지면 거진 실패를 했기 때문에, 그 감정이 스멀스멀 올라오기 시작했을때 손을 놓고 다른 방법을 강구했다. 결국 해법은 비슷한 유형의 문제 풀이를 보고 찾을 수 있었다. 사실 구현 자체만 보면 모든 부분을 탐색하기 때문에 BFS 풀이의 느낌이 강하다. 핵심은 temp 변수에 있다. 두 값을 단순히 붙이는 방법을 자리수 이동으로 해결하고, 이를 연산의 한 방법으로 사용한 것이 굉장히 창의적이여서 이해하기 힘든 부분이었다. 풀이 과정이 간단하니 코드 또한 훨씬 줄고 깔끔해졌다. 두고두고 다시 봐야할 풀이 같다.","link":"/2021/07/04/3d07c80169c5/"},{"title":"[프로그래머스] 등굣길","text":"등굣길Python3 문제 설명계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요. 제한사항 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다. 입출력 예 m n puddles return 4 3 [[2, 2]] 4 입출력 예 설명 풀이 python1234567891011121314151617def solution(m, n, puddles): if m == 1 or n == 1: return 1 maps = [-1]*(m*n) maps[0] = 1 for p in puddles: maps[(p[1]-1)*m + p[0]-1] = 0 for i in range(m): for j in range(n): if maps[i+j*m] == 0 or (i == 0 and j == 0) : continue elif i == 0 and j != 0 : maps[i+j*m] = maps[i+(j-1)*m] elif i != 0 and j == 0 : maps[i+j*m] = maps[i+j*m-1] else: maps[i+j*m] = (maps[i+j*m-1] + maps[i+(j-1)*m]) % 1000000007 return maps[m*n-1] 설명 DP로 풀어야 효율성 케이스를 통과할 수 있는 문제다. divide and conquer를 이용한 재귀함수로 아주 간단히 풀 수 있지만, 효율성에서 통과되지 못했다. 메모리를 활용한 DP 풀이로 다시 풀었을때도 몇가지 케이스를 계속 틀렸는데, 전체 맵을 1로 셋팅하고 i==0 이거나 j==0 인 경우를 무시하고 지나가서 였다. 그러다보니 i==0 이거나 j==0 에서 생긴 웅덩이 다음 길에서 1로 값이 세팅되어 있는 문제점이 있었다. 이를 해결하기 위해 다시 0부터 모든 인덱스를 탐색하며 풀이했다. 간단하게 DP의 핵심 개념을 연습하기 좋은 문제다.","link":"/2021/07/07/c80365b37de0/"},{"title":"[프로그래머스] 미로 탈출","text":"미로 탈출Python3 문제 설명신규 게임 ‘카카오 미로 탈출’이 출시되어, 라이언이 베타테스터로 참가했습니다. 위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정으로 이동하면, 이동한 함정과 연결된 모든 화살표의 방향이 바뀝니다.\\출발지점인 1번 방에서 탈출이 가능한 3번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다. 그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다. 방이 n개일 때, 방 번호는 1부터 n까지 사용됩니다. 화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다. 화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다. 그림에 표시된 빨간색 방인 2번 방은 함정입니다. 함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다. 위 그림 1번 방에서 2번 방으로 이동하는 순간 1에서 2로 이동할 수 있던 길은 2에서 1로 이동할 수 있는 길로 바뀌고, 3에서 2로 이동할 수 있던 길은 2에서 3으로 이동할 수 있는 길로 바뀝니다. 똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다. 미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다. 1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다. 함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다. 2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다. 탈출에 성공했습니다. 총 이동시간은 5입니다. 방의 개수를 나타내는 정수 n, 출발 방의 번호 start, 도착 방의 번호 end, 통로와 이동시간을 나타내는 2차원 정수 배열 roads, 함정 방의 번호를 담은 정수 배열 traps이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ n ≤ 1,000 1 ≤ start ≤ n 1 ≤ end ≤ n 1 ≤ roads의 행 길이 ≤ 3,000 roads의 행은 [P, Q, S]로 이루어져 있습니다. P에서 Q로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 S만큼 시간이 걸립니다. 1 ≤ P ≤ n 1 ≤ Q ≤ n P ≠ Q 1 ≤ S ≤ 3,000 서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다. 0 ≤ traps의 길이 ≤ 10 1 ≤ traps의 원소 ≤ n 시작 방과 도착 방은 함정이 아닙니다. 항상 미로를 탈출할 수 있는 경우만 주어집니다. 입출력 예 n start end roads traps result 3 1 3 [[1, 2, 2], [3, 2, 3]] [2] 5 4 1 4 [[1, 2, 1], [3, 2, 1], [2, 4, 1]] [2, 3] 4 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 1 → 2 → 3 → 2 → 4 순서로 이동하면 됩니다. 총 이동시간은 4입니다. 제한시간 안내 정확성 테스트 : 10초 풀이 1234567891011121314151617181920212223242526272829303132333435363738394041import heapq as hdef solution(n, start, end, roads, traps): start -=1; end -=1; INF = float(&quot;inf&quot;); graph = [[] for _ in range(n)] trap_dict = {trap-1:idx for idx, trap in enumerate(traps)}; nodes = []; isVisit = [[False]*n for _ in range(1&lt;&lt;len(traps))] for road in roads: start_i, end_i, cost = road graph[start_i-1].append([end_i-1,cost,0]) graph[end_i-1].append([start_i-1,cost,1]) h.heappush(nodes,(0,start,0)) while nodes: cur_time, cur_node, state = h.heappop(nodes); if cur_node == end : return cur_time; if isVisit[state][cur_node] == True: continue; else: isVisit[state][cur_node] = True; for next_node, next_cost, road_type in graph[cur_node]: next_state = state cur_isTrap = 1 if cur_node in trap_dict else 0; next_isTrap = 1 if next_node in trap_dict else 0; if cur_isTrap == 0 and next_isTrap == 0: if road_type == 1: continue elif (cur_isTrap + next_isTrap) == 1: node_i = cur_node if cur_isTrap == 1 else next_node isTrapOn = (state &amp; (1&lt;&lt;trap_dict[node_i]))&gt;&gt;trap_dict[node_i] if isTrapOn != road_type: continue else: isTrapOn = (state &amp; (1&lt;&lt;trap_dict[cur_node]))&gt;&gt;trap_dict[cur_node] n_isTrapOn = (state &amp; (1&lt;&lt;trap_dict[next_node]))&gt;&gt;trap_dict[next_node] if (isTrapOn ^ n_isTrapOn) != road_type: continue if next_isTrap == 1: next_state = state ^ (1&lt;&lt;trap_dict[next_node]) h.heappush(nodes,(cur_time+next_cost, next_node, next_state)) 설명 상반기 카카오 인턴 코딩테스트에서 출제된 문제인데, 당시 5번과 더불어 나의 숨을 조여온 기억이 난다. 시험 당시 4, 5번을 건들지도 못한 내가 테스트에 통과했을 정도니 당시 문제를 푸는 사람들도 나처럼 체감 난이도가 상당했을 것이다. 어쨌든 해당 문제의 해설은 이곳 에서 친절하게 알려주고 있다. 물론 코드는 제외하고 말이다. 전체적인 풀이 핵심은 dijkstra를 적용하되, 함정 노드들의 상태를 구분해야 한다는 것이다. 위 링크의 해설대로 해당 문제에서는 일반적 dijkstra 하고는 다르게 지나온 노드를 다시 방문해야 할 순간이 있다. 그러나 이것은 일종의 트릭으로, 모든 함정들의 발동 조건이 같은 상황에서 같은 노드를 방문할 일은 없다. 즉, 함정의 발동상태에 따라 isVisit 여부를 달리 체크해야 하고, 이를 제외하면 일반적 dijkstra처럼 문제를 풀면 된다. 나는 여기에 heap queue를 활용하여 거리를 따로 저장하고 갱신할 필요 없이 늘 최소경로를 찾아가는 식으로 구현했다. 함정들의 상태를 관리하는 방법으로는 bit mask를 이용했다. 문제의 제한사항대로 함정 노드는 최대 10개기 때문에, 최대 2^{10} 인 1024개의 상태를 구분하면 된다. 이는 문제에서 주어진 traps의 길이를 시프트 연산으로 할당한다. heapq에서 꺼낸 노드의 상태(state)와 노드번호(cur_node)로 중복방문을 검증하고, 마지막엔 방문하게될 다음 노드의 상태도 계산하여 heapq에 넣어줘야 한다. 이때 다음 방문할 노드가 함정이라면, 다음 노드의 함정이 작동된 상태를 시프트연산을 통해 갱신하여 넘겨줘야 한다. 여기서 trap_dict는 각 함정의 노드번호를 key로 갖는 딕셔너리다. value에는 각 함정의 순서를 넣었는데, 이는 비트마스크에서 각 함정을 뜻하는 자릿수로 사용된다. 처음 그래프 링크들을 할당할때도 정방향과 역방향을 구분하여 넣어준다. 이때 append로 할당되는 배열은 [목적지 노드번호, 이동비용, 다리의 방향] 이다.start 노드에게는 정방향인 다리를, end 노드에게는 역방향인 다리를 각 할당한다. 그런 뒤 현재 노드와 이동할 다음 노드의 함정 여부를 파악하고, 만약 상황에 맞지 않는 방향의 다리라면 건너지 않고 다음 다리를 살펴본다. 이때 state에 시프트 연산을 가하여 각 자리수에 해당하는 함정이 작동되어있는 상태인지 판단한다. 여기서 4가지 기준으로 상황을 판단할 수 있다. 일반노드 → 일반노드 일반노드 → 함정노드 함정노드 → 일반노드 함정노드 → 함정노드 여기서 1번은 함정의 상태와 상관없이 늘 정방향인 다리로만 이동 가능하다. 2번 3번은 해당하는 함정노드가 작동되면 역방향, 그렇지 않으면 정방향의 다리로만 이동 가능하다. 4번에서는 두 함정이 모두 작동되거나 모두 작동하지 않았을때는 정방향, 둘 중 하나만 작동한 상태라면 역방향만 이동 가능하다. 만약 모든 조건에 맞는 노드라면 state를 갱신하고 heapq에 넣어주면 되고, 이렇게 각 최단거리에 해당하는 노드를 방문하며 end에 도달하면 그 값을 return하면 된다. 🔴 질문이나 개선이 필요한 부분 등 적극적인 피드백 환영! 🔴","link":"/2021/07/15/81c20813e6cf/"},{"title":"[프로그래머스] 도둑질","text":"도둑질 Python3 문제 설명도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다. 각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요. 제한사항 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다. money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다. 입출력 예 money return [1, 2, 3, 1] 4 풀이 python123456789101112131415def solution(money): f = [0] * len(money) f[0] = f[1] = money[0] for i in range(2, len(money)-1): f[i] = max(f[i-2] + money[i], f[i-1]) s = [0] * len(money) s[1] = money[1] for i in range(2, len(money)): s[i] = max(s[i-2] + money[i], s[i-1]) return max(f+s) 설명 동적계획법(Dynamic Programming) 유형의 꽤나 깊은 생각을 요하는 문제다. 반복문을 돌며 현재 집을 기준으로 지난 집들의 최댓값을 누적시키는 것이 포인트다. 여기까지는 기본적인 DP의 유형을 따르지만, 첫 번째 집이 선택되는 경우와 그렇지 못한 경우에 따라 마지막 집을 선택할 수 있는지에대한 여부가 갈리기 때문에 이를 신경 쓰는 과정에서 다소 시간이 걸렸다. 또한, 직전 집의 최댓값을 바로 다음 인덱스의 집에서도 적용할 수 있다는 생각은 처음에 떠오르지 않았다. 몇 번의 시행착오를 거듭한 끝에 답을 구할 수 있었고, 아이러니하게도 풀이를 계속 고민할 수록 코드의 길이는 짧아졌다. DP는 풀이에 도달하기 까지 깊은 생각을 요하지만, 막상 풀이는 매우 짧고 간결한 것 같다. 무언가 DP 유형의 문제를 풀면서 풀이가 지저분하게 길어지고 있다면, 현재 문제를 잘못 접근하고 있다는 생각을 할 필요가 있다.","link":"/2021/07/13/9a8dfd4b707d/"},{"title":"[프로그래머스] 124 나라의 숫자","text":"124 나라의 숫자JavaScript, Python 문제 설명124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 풀이 javascript1234567891011121314151617181920212223function solution(n) { var answer = ''; function three(num,count){ if(num === 0) return 0 else{ var cal = Math.floor(num /3); var rest = num % 3; if( rest === 0 ){ cal--; rest = 4; } return three(cal,count+1) + rest * Math.pow(10,count) } } answer = three(n,0) return answer+'';} 12345678910111213141516def solution(n): answer = 0 count = 0 while n &gt; 0: n, r = divmod(n, 3) if r == 0: n -= 1; r = 4; answer += (r * (10 ** count)) count += 1; return str(answer) 설명 진법 변환을 요구하는 문제다. 언뜻 보면 단순히 4진법에서 (3 -&gt; 4)만 변한듯 오해할 수 있으나 124나라 표기법에는 0이 없다는 점을 잊어선 안된다. 10진법 3진법 124나라 1 1 1 2 2 2 3 10 4 4 11 11 5 12 12 6 20 14 7 21 21 8 22 22 9 100 24 10 101 41 3진법과 124나라의 진법을 자세히 살펴보면 핵심은 4에 있다는 것을 알 수 있다. 124나라의 4는 자리 변환이 일어나는 3진법의 10의 성질을 갖고 있다. 따라서 3을 나누어 몫과 나머지를 반복하는 3진법 계산식에서 나머지가 0일때 4의 특성을 입혔다. (몫 -1, 나머지 &lt;- 4) 이 방법을 통해 문제를 해결할 수 있었고, 다른 사람들의 풀이도 이와 비슷한 양상을 보였다.","link":"/2021/06/30/637f6cdb5470/"},{"title":"[프로그래머스] H-Index","text":"H-IndexJavaScript, Python 문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. ※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다. https://en.wikipedia.org/wiki/H-index “위키백과” ↩ 풀이 javascript123456789101112function solution(citations) { var answer = 0; var sorted = citations.sort((a,b)=&gt;b-a) for(let i = 0; i &lt; sorted.length; i++){ if(answer &gt; sorted[i]) return answer; else answer = (sorted[i] &lt;= (i+1) ? sorted[i] : i+1) } return answer} 12345678def solution(citations): h = 0 for i, c in enumerate(sorted(citations,reverse=True)): if h &gt; c: return h else: h = (c if c &lt;= (i+1) else i+1) return h 설명 정렬(sort)하지 않고서는 O(N2)이상의 풀이 방법이 없었다. 배열을 내림정렬을 한 뒤, 앞에서 부터 index와 값을 비교하여 최대값을 갱신시켜주면 된다. 여기서 index는 자연스럽게 현재 값보다 같거나 큰 값들의 개수가 된다(정확히는 i+1이). 내가 염려했던 부분은 [5,5,5,5,0]와 같은 배열이었는데, 이 배열의 h값은 4가 나와야 한다. 즉, 배열에 포함되어 있지 않은 값으로도 h가 갱신되어야 한다. 따라서 index와 값을 비교하여 더 낮은 값으로 갱신을 진행했다. 정렬 한 뒤에는 O(N)풀이 인데, 평균적으로는 훨씬 적을 것으로 예상된다.","link":"/2021/07/07/e7499cd19d97/"},{"title":"[프로그래머스] n진수 게임","text":"JavaScript 문제 설명N진수 게임튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다. 이렇게 게임을 진행할 경우,\\0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, ...\\순으로 숫자를 말하면 된다. 한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는\\0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, ...\\순으로 숫자를 말하면 된다. 이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라. 입력 형식진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다. 2 ≦ n ≦ 16 0 ＜ t ≦ 1000 2 ≦ m ≦ 100 1 ≦ p ≦ m 출력 형식튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다. 입출력 예제 n t m p result 2 4 2 1 “0111” 16 16 2 1 “02468ACE11111111” 16 16 2 2 “13579BDF01234567” 해설 보러가기 풀이javascript123456789101112131415161718192021222324252627282930313233function solution(n, t, m, p) { const number_char = {'10':'A','11':'B','12':'C','13':'D','14':'E','15':'F'} const setChange = (v, N) =&gt; { if(v === 0) return 0; let buffer = '' while(v &gt; 0){ let d = Math.floor(v/N); let r = v % N; v = d; buffer += (r &lt; 10 ? r : number_char[r+'']) } return buffer.split('').reverse().join(''); } let answer = ''; let i = 0 let calc_number = 0 let totalWords = '' while(answer.length &lt; t){ while(totalWords.length &lt; m*i+p ){ totalWords += setChange(calc_number,n) calc_number++; } answer += totalWords[m*i+p-1] i++; } return answer;} 설명 가장 최근 본 코딩 테스트에서, 진법의 구현 문제가 나왔다.언어에서 제공하는 함수들이 아니라 직접 N진법을 구현해야 했다. 그런데 오늘 우연히 고른 이 문제가 진법 구현을 다루고 있어 놀랐다.이 문제 또한 N진법의 구현이 기본으로 시작된다. javascript는 toString(N)으로, python은 bin과 hex 함수로 진법을 쉽게 구현할 수 있다.하지만 이런 문제를 통해 구현 능력을 연습해야 하기 때문에 다시 한 번 나는 N진법을 직접 구현해서 사용했다. 이렇게 변환한 진법 값을 통해 전체 리스트에서 ‘튜브’가 뽑을 순서의 값을 반환하면 되는데,순서는 규칙적으로 m(플레이 인원)번마다 돌아온다. 여기에 시작순서 p를 더해서, m*i + p의 값이 전체 리스트에서 튜브가 뽑아야할 값이 된다. 그렇다면 전체 리스트는 어디까지 구해놔야 할까? 나는 튜브가 뽑아야할 순서의 길이보다 작으면 새로 값을 붙여나가는 식으로 구현했고,이 편이 메모리 낭비가 없는 방법이다.","link":"/2021/07/07/8fc07391b329/"},{"title":"[프로그래머스] 구명 보트","text":"구명보트JavaScript, Python 문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 풀이 javascript123456789101112131415161718192021function solution(people, limit) { let answer = 0; let s = 0, e = people.length-1; people = people.sort((a,b)=&gt;a-b) while(s &lt; e){ if(people[s] &gt; limit/2) return answer + e - s + 1 if(people[s] + people[e] &lt;= limit){ answer++; s++; e--; } else{ answer++; e--; } } return s === e ? answer + 1 : answer;} python12345678910111213def solution(people, limit): answer = 0 s = 0 e = len(people)-1 people.sort() while people[s] &lt;= limit/2 and s &lt; e: if people[s] + people[e] &gt; limit: e -= 1 else: e -= 1 s += 1 answer += 1 return answer + e - s + 1 설명 구명보트에는 최대 2명까지 탑승할 수 있다는 것이 가장 큰 힌트였다.그렇지 않으면 적은 무게의 사람들이 3명 이상 탈 수 있는데, 이 경우 문제가 매우 복잡해진다. 최대 2명이 탈 수 있다면, 몸무게가 큰 사람들과 작은 사람들을 함께 태우면 된다.따라서 배열을 무게순으로 정렬하고, 인덱스 시작과 끝에 header와 tail에 해당하는 변수를 설정한다. 그 뒤 현재 선택된 무거운 사람(변수 e)과 현재 선택된 가벼운 사람(변수 s)을 비교한다. 이 때, s와 e에 해당하는 두 사람의 무게를 비교하여 두 사람 무게의 합이 limit 무게를 안넘으면 둘을 모두 탑승시킨다. 그 뒤 s를 한칸 뒤로, e를 한칸 앞으로 땡긴다. 두 사람 무게의 합이 limit 무게를 넘으면 큰 사람만 탑승시킨다. 그 뒤 e를 한칸 앞으로 땡긴다. 만약 현재 탑승하지 않은 가장 가벼운 사람(s)의 무게가 limit/2 초과하면 남은 모든 사람을 각자 혼자 태운다. 이 과정을 반복시키면 함께 탈 수 있는 2명 보트의 개수를 최적화 할 수 있다.","link":"/2021/06/30/af7c778c73b3/"},{"title":"[프로그래머스] 괄호 변환","text":"괄호 변환Javascript, Python 문제 설명카카오에 신입 개발자로 입사한 “콘”은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.\\수정해야 할 소스 파일이 너무 많아서 고민하던 “콘”은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의‘(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.\\그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.\\예를 들어, &quot;(()))(&quot;와 같은 문자열은 “균형잡힌 괄호 문자열” 이지만 “올바른 괄호 문자열”은 아닙니다.\\반면에 &quot;(())()&quot;와 같은 문자열은 “균형잡힌 괄호 문자열” 이면서 동시에 “올바른 괄호 문자열” 입니다. ‘(‘ 와 ‘)’ 로만 이루어진 문자열 w가 “균형잡힌 괄호 문자열” 이라면 다음과 같은 과정을 통해 “올바른 괄호 문자열”로 변환할 수 있습니다. 12345678910111. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.2. 문자열 w를 두 &quot;균형잡힌 괄호 문자열&quot; u, v로 분리합니다. 단, u는 &quot;균형잡힌 괄호 문자열&quot;로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.3. 문자열 u가 &quot;올바른 괄호 문자열&quot; 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.4. 문자열 u가 &quot;올바른 괄호 문자열&quot;이 아니라면 아래 과정을 수행합니다. 4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 4-3. ')'를 다시 붙입니다. 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 4-5. 생성된 문자열을 반환합니다. “균형잡힌 괄호 문자열” p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 “올바른 괄호 문자열”로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요. 매개변수 설명 p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다. 만약 p가 이미 “올바른 괄호 문자열”이라면 그대로 return 하면 됩니다. 입출력 예 p result &quot;(()())()&quot; &quot;(()())()&quot; &quot;)(&quot; &quot;()&quot; &quot;()))((()&quot; &quot;()(())()&quot; 입출력 예에 대한 설명입출력 예 #1\\이미 “올바른 괄호 문자열” 입니다. 입출력 예 #2 두 문자열 u, v로 분리합니다. u = &quot;)(&quot; v = &quot;&quot; u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 &quot;&quot;이 됩니다. 따라서 생성되는 문자열은 &quot;(&quot; + &quot;&quot; + &quot;)&quot; + &quot;&quot;이며, 최종적으로 &quot;()&quot;로 변환됩니다. 입출력 예 #3 두 문자열 u, v로 분리합니다. u = &quot;()&quot; v = &quot;))((()&quot; 문자열 u가 “올바른 괄호 문자열”이므로 그대로 두고, v에 대해 재귀적으로 수행합니다. 다시 두 문자열 u, v로 분리합니다. u = &quot;))((&quot; v = &quot;()&quot; u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 &quot;()&quot;이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 &quot;()&quot;이 됩니다. 따라서 생성되는 문자열은 &quot;(&quot; + &quot;()&quot; + &quot;)&quot; + &quot;()&quot;이며, 최종적으로 &quot;(())()&quot;를 반환합니다. 처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면 &quot;()&quot; + &quot;(())()&quot; = &quot;()(())()&quot;가 됩니다. 혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 (클릭) 풀이 python 1차 풀이123456789101112131415161718192021222324252627282930313233343536373839def solution(p): count_s = {'(':1,')':-1} def changeU(u): return ''.join([ ')' if s == '(' else '(' for s in u[1:-1]]) def splitUV(s): count = 0 isRight = True for i,c in enumerate(s): count += count_s[c] if count &lt; 0: isRight = False elif count == 0: return (isRight, count == 0,s[:i+1],s[i+1:]) def sol(s): if s == '': return '' r,b,u,v = splitUV(s) if r: return u + sol(v) else: return '(' + sol(v) + ')' + changeU(u) return sol(p)``` #### python 1차풀이 간략화```pythondef solution(p): if p =='': return p r = True; count = 0 for i,v in enumerate(p): if v == '(': count += 1 else: count -= 1 if count &lt; 0 : r = False if count == 0: if r: return p[:i+1] + solution(p[i+1:]) else: return '('+solution(p[i+1:])+')'+ ''.join([')' if s == '(' else '(' for s in p[1:i]]) 설명 올바른 괄호 문제의 심화 버전. 실제 대기업 코딩 테스트에서도 흡사한 유형의 문제가 출제되었다. 풀이는 올바른 괄호 문제에서와 같이 count 변수를 이용해 올바른 괄호와 균형잡힌 괄호 여부를 판단했고, 문제의 요구사항대로 재귀함수를 이용해 어려움없이 결과값을 도출했다.","link":"/2021/06/30/7b55ae06b1c7/"},{"title":"[프로그래머스] 다리를 지나는 트럭","text":"다리를 지나는 트럭JavaScript, Python 문제 설명트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.\\※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다. 예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 출처 ※ 공지 - 2020년 4월 06일 테스트케이스가 추가되었습니다. 풀이javascript12345678910111213141516171819202122232425function solution(bridge_length, weight, truck_weights) { var answer = 0; var on_bridge_weight = 0; var on_bridge = []; while(truck_weights.length || on_bridge.length){ on_bridge.forEach((truck)=&gt;{ truck[0]--; }) if(on_bridge.length &amp;&amp; on_bridge[0][0] === 0){ on_bridge_weight -= on_bridge.shift()[1]; } if(on_bridge_weight + truck_weights[0] &lt;= weight){ var cur_truck = truck_weights.shift() on_bridge.push([bridge_length,cur_truck]); on_bridge_weight += cur_truck; } answer++; } return answer;} python1234567891011121314151617181920212223def solution(bridge_length, weight, truck_weights): b = [] answer = 0 while len(truck_weights) or len(b): answer += 1 returns = -1 for i in range(len(b)): if b[i][1] == 1: returns = i else: b[i][1] -= 1 for i in range(returns+1): b.pop(0) count = sum(map(lambda a:a[0],b)) if len(truck_weights) and count + truck_weights[0] &lt;= weight: t = truck_weights.pop(0) b.append([t,bridge_length]) count += t return answer python 간략화123456789101112131415def solution(bridge_length, weight, truck_weights): q = [0] * bridge_length q_sum = 0 answer = 0 while q: answer += 1 q_sum -= q.pop(0) if truck_weights: if q_sum + truck_weights[0] &lt;= weight: t_pop = truck_weights.pop(0) q.append(t_pop) q_sum += t_pop else: q.append(0) return answer 설명 큐와 스택의 심화 문제다.다리(bridge)의 상태를 큐로 표현하여 풀었다. 문제에서 주어진 트럭의 무게 배열을 중심으로 while문을 이용한 풀이는 O(N3)를 보였다.그러나 인터넷에는 bridge를 중심으로 풀이한 O(N2) 풀이가 있다. python의 pop(0)은 O(N)을 가지는 것을 감안해도 매우 효율적인 방법이다.당연히 풀이 코드 또한 훨씬 간결하다. (인터넷의 풀이에는 sum을 while문 안에서 사용하여 효율성이 조금 떨어졌는데,sum 변수를 활용하여 이를 개선시켰다.) 앞으로도 문제에서 주어진 변수에만 집중하는 버릇을 경계해야겠다.","link":"/2021/06/30/15b4a4d4d13d/"},{"title":"[프로그래머스] 기능개발","text":"기능개발JavaScript, Python 문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명입출력 예 #1\\첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\\두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.\\세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 입출력 예 #2\\모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. ※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다. 풀이 javascript1234567891011121314151617181920function solution(progresses, speeds) { var answer = []; var c = 0; while(progresses.length){ if(progresses[0] &lt; 100) progresses = progresses.map((a,index)=&gt;a+speeds[index]) else{ var count = 0; while(progresses.length &amp;&amp; progresses[0] &gt;= 100){ count++; progresses.shift(); speeds.shift(); } answer.push(count); } } return answer;} python123456789101112131415161718def solution(progresses, speeds): answer = [] count = 0 while len(progresses): if progresses[0] &gt;= 100: progresses.pop(0) speeds.pop(0) count += 1 continue; elif count &gt; 0: answer.append(count) count = 0 for i, v in enumerate(progresses): progresses[i] += speeds[i] answer.append(count) return answer 설명 자료구조 큐를 활용한 문제다. python의 list와 javascript array에서 각각 일반적인 FIFO의 큐를 구현할 수 있다. python javascript 삽입 append(v) push(v) 삭제 pop(0) shift() 해당 문제에선 Queue의 삭제 기능만을 사용하여 쉽게 구현할 수 있었다.","link":"/2021/06/30/4a5a9e5057a2/"},{"title":"[프로그래머스] 멀쩡한 사각형","text":"멀쩡한 사각형JavaScript, Python 문제 설명가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.\\가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요. 제한사항 W, H : 1억 이하의 자연수 입출력 예 W H result 8 12 80 입출력 예 설명입출력 예 #1\\가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다. 풀이 javascript1234567891011function solution(w, h) { if (w === h) return w * h - w; if (w === 1 || h === 1) return 0; let answer = 0; for(let i = 1; i &lt; w; i++) answer += Math.floor( h * i / w ) return answer * 2;} python 최소공배수 풀이123from math import gcddef solution(w,h): return w * h - (w+h) + gcd(w, h) 설명 알고리즘 보단 창의력을 요하는 수학 문제에 가깝다.문제의 인덱스마다 감소하는 진한 사각형의 개수를 구하는 식으로 풀었다. 그런데 최대공약수를 이용한 풀이도 존재했다. w와 h 입장에서 선이 지나가서 못쓸만한 사각형들을 모두 빼고,중복으로 제거된 칸의 개수(최대공약수) 만큼 더하면 된다.","link":"/2021/06/30/aa511e633040/"},{"title":"[프로그래머스] 메뉴 리뉴얼","text":"메뉴 리뉴얼JavaScript, Python 문제 설명레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.\\기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 “스카피”는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.\\단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다. 예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,\\(각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.) 손님 번호 주문한 단품메뉴 조합 1번 손님 A, B, C, F, G 2번 손님 A, C 3번 손님 C, D, E 4번 손님 A, C, D, E 5번 손님 B, C, F, G 6번 손님 A, C, D, E, H 가장 많이 함께 주문된 단품메뉴 조합에 따라 “스카피”가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다. 코스 종류 메뉴 구성 설명 요리 2개 코스 A, C 1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다. 요리 3개 코스 C, D, E 3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다. 요리 4개 코스 B, C, F, G 1번, 5번 손님으로부터 총 2번 주문됐습니다. 요리 4개 코스 A, C, D, E 4번, 6번 손님으로부터 총 2번 주문됐습니다. [문제]각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, “스카피”가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, “스카피”가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] orders 배열의 크기는 2 이상 20 이하입니다. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다. 각 문자열은 알파벳 대문자로만 이루어져 있습니다. 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다. course 배열의 크기는 1 이상 10 이하입니다. course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다. course 배열에는 같은 값이 중복해서 들어있지 않습니다. 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요. 배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다. 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다. orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다. [입출력 예] orders course result [&quot;ABCFG&quot;, &quot;AC&quot;, &quot;CDE&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;ACDEH&quot;] [2,3,4] [&quot;AC&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;CDE&quot;] [&quot;ABCDE&quot;, &quot;AB&quot;, &quot;CD&quot;, &quot;ADE&quot;, &quot;XYZ&quot;, &quot;XYZ&quot;, &quot;ACD&quot;] [2,3,5] [&quot;ACD&quot;, &quot;AD&quot;, &quot;ADE&quot;, &quot;CD&quot;, &quot;XYZ&quot;] [&quot;XYZ&quot;, &quot;XWY&quot;, &quot;WXA&quot;] [2,3,4] [&quot;WX&quot;, &quot;XY&quot;] 입출력 예에 대한 설명 입출력 예 #1\\문제의 예시와 같습니다. 입출력 예 #2\\AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.\\요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다. 입출력 예 #3\\WX가 두 번, XY가 두 번 주문됐습니다.\\3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.\\또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다. 풀이javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function solution(orders, course) { var answer = []; var list = []; var counter = {}; function combination(source, target, n, r, count) { if(r === 0) list.push(target.sort().join('')); else if(n === 0 || n &lt; r) return; else { target.push(source[count]); combination(source, Object.assign([], target), n - 1, r - 1, count + 1); target.pop(); combination(source, Object.assign([], target), n - 1, r, count + 1); } } course.forEach((c)=&gt;{ orders.forEach((o)=&gt;{ var order = o.split('') combination(order, [], o.length, c, 0) }) counter[c] = 2; }) var freqTable = list.reduce((acc, menu) =&gt; { acc[menu] = (acc[menu] || 0) + 1 return acc },{}); var filteredData = {}; Object.entries(freqTable).forEach( ([key, value]) =&gt; { if(value &gt; counter[key.length]){ counter[key.length] = value; filteredData[key.length] = [key]; } else if(value === counter[key.length]){ if(!filteredData[key.length]) filteredData[key.length] = [key]; else filteredData[key.length].push(key); } } ) return Object.values(filteredData).reduce((a,b)=&gt;a.concat(b),[]).sort();} python12345678910111213141516171819202122from itertools import combinationsdef solution(orders, course): answer = [] for i in course: d = {} for o in orders: if len(o) &lt; i: continue for c in list(combinations(list(o), i)): k = ''.join(sorted(c)) if k in d: d[k] += 1; else: d[k] = 1 if len(d.values()): m = max(d.values()) if m &lt; 2 : continue; for maxValues in [mk for mk in d if d[mk] == m]: answer.append(maxValues) return sorted(answer) 설명 javascript를 너무나 힘들게 만드는 순열 조합 문제다. javascript에는 타 언어와는 달리 순열 조합 함수가 내장되어 있지 않기 때문에 이를 직접 구현해야 한다. javascript에서 재귀함수로 구현한 n 개중 r 개를 뽑는 조합 함수12345678910111213const list = []function combination(source, target, n, r, count) { if(r === 0) list.push(target.sort().join('')); else if(n === 0 || n &lt; r) return; else { target.push(source[count]); combination(source, Object.assign([], target), n - 1, r - 1, count + 1); target.pop(); combination(source, Object.assign([], target), n - 1, r, count + 1); } } 그러나 파이썬은 이야기가 다르다. python 에서는 itertools 패키지에 순열, 조합 등의 기능들이 들어있어 이를 쉽게 사용할 수 있다.그러다 보니 두 언어의 코드량 차이도 엄청나다. 사실 풀이는 크게 다르지 않다. 주어진 orders의 조합을 구해서 dictionary에 쌓은 뒤,course 길이마다 요구하는 최대값들을 추려 결과 배열에 추가하는 코드다. 실제로 카카오 2021 채용 코딩테스트에서 풀었던 문제인데, javascript만 알던 나는난생 처음 짜보는 combination 함수에 많은 시간을 소진했다. 이런 차별점 때문에 뒤늦게 Python 공부를 시작하긴 했지만 다소 아쉬움이 남는 부분이다.","link":"/2021/06/30/6aeb0e7e8527/"},{"title":"[프로그래머스] 삼각 달팽이","text":"삼각 달팽이JavaScript, Python 문제 설명정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 1,000 이하입니다. 입출력 예 n result 4 [1,2,9,3,10,8,4,5,6,7] 5 [1,2,12,3,13,11,4,14,15,10,5,6,7,8,9] 6 [1,2,15,3,16,14,4,17,21,13,5,18,19,20,12,6,7,8,9,10,11] 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 문제 예시와 같습니다. 풀이javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function solution(n) { if (n === 1) return [1]; var state = 0; // 아래 왼쪽 방향 시작 var count = n; var value = 1; var currentFloor = 1; var currentIndex = 0; var answer = Array.from(Array(n*(n+1)/2),()=&gt;0); while(count &gt; 0){ for(let i = 0; i &lt; count; i++){ answer[currentIndex] = value++; if(state === 0){ // 아래 왼쪽 방향 if(i !== count-1) currentIndex += currentFloor++; else{ currentIndex++; state = 1; } } else if (state === 1){ // 오른쪽 방향 if(i !== count-1) currentIndex++; else{ currentIndex -= currentFloor--; state = 2; } } else { // 왼쪽 위 방향 if(i !== count-1) currentIndex -= currentFloor--; else{ currentIndex += currentFloor++; state = 0; } } } count--; } return answer;} python1234567891011121314151617def solution(n): floor = 1; index = 0; flags = 1; size = int(n * (n+1) / 2) answer = [0] * size for i in range(size): answer[index] = i+1 index_count = {'1':floor,'0':1,'-1':-floor} next_index = index + index_count[str(flags)] if not (0 &lt;= next_index &lt; size) or answer[next_index] != 0: flags = (flags-1 if flags != -1 else 1) index = index + index_count[str(flags)] floor += flags return answer 설명 처음 접했을 때는, 반복되는 패턴의 삼각형을 기준으로 분할정복을 사용하려 했다.하지만 각기 처리된 삼각형들의 매끄러운 병합 과정이 떠오르지 않았다. 그래서 n(n+1)/2 개의 숫자를 체우는 반복문을 만들어 한 번에 해결했는데,매 번 현재의 층(floor)와 방향을 초기화하며 배열에 값을 할당한다. javascript풀이에서는 count 변수를 이용해 첫 직선이 n칸을 할당하고,그 다음 직선부터 1칸씩 감소한 4, 3, 2, 1칸을 할당하는 규칙성을 이용했다. 상태 개념을 이용할 것이라 count 활용은 굳이 필요 없는 방법이지만최대한 분할정복 방법으로 풀어보려던 시도라고 보면 된다. 이와 다르게 Python 풀이는 깔끔하게 현재의 상태(층수, 방향)만 이용한다.두 방법 모두 O(N2)의 시간복잡도를 나타낸다. 그 와중에 python의 a &lt; X &lt; b 연산 허용은 정말 적응이 안된다.","link":"/2021/06/30/f32163cbe81c/"},{"title":"[프로그래머스] 문자열 압축","text":"문자열 압축JavaScript, Python 문제 설명데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.\\간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s result &quot;aabbaccc&quot; 7 &quot;ababcdcdababcdcd&quot; 9 &quot;abcabcdede&quot; 8 &quot;abcabcabcabcdededededede&quot; 14 &quot;xababcdcdababcdcd&quot; 17 입출력 예에 대한 설명입출력 예 #1 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #2 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #3 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #4 문자열을 2개 단위로 자르면 “abcabcabcabc6de” 가 됩니다.\\문자열을 3개 단위로 자르면 “4abcdededededede” 가 됩니다.\\문자열을 4개 단위로 자르면 “abcabcabcabc3dede” 가 됩니다.\\문자열을 6개 단위로 자를 경우 “2abcabc2dedede”가 되며, 이때의 길이가 14로 가장 짧습니다. 입출력 예 #5 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.\\따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.\\이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다. 혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 (클릭) 풀이javascript123456789101112131415161718192021222324252627282930function solution(s) { let answer = s.length; let word = '' let curWord = '' for(let i = 1; i&lt;= s.length/2; i++){ word = '' curWord = '' const splits = s.split('') let wordCount = 1; while(splits.length &gt; 0){ if(word.length &gt;= answer) break; let split_word = splits.splice(0,i).join('') if(split_word === curWord) wordCount++; else{ if(curWord) word += (wordCount &gt; 1? wordCount : '') + curWord wordCount = 1; curWord = split_word } } word += (wordCount &gt; 1? wordCount : '') + curWord if(word.length &lt; answer) answer = word.length } return answer} python123456789101112131415161718192021222324def solution(s): answer = len(s) for i in range(1,int(len(s)/2)+1): c = '' word = '' str_ = s b = 0 while str_: if len(word) &gt; answer: break; if c == str_[0:i]: b+=1 else: word += ( str(b) + c if b &gt; 1 else c) c = str_[0:i] b = 1 str_ = str_[i:] if len(str_) &lt; i: word += ((str(b) if b &gt;1 else '') + c + str_) if answer &gt; len(word): answer = len(word) return answer 설명 brute force를 이용한 _무지성_ 무차별 대입 문제다. 1개부터 최소 s의길이/2 까지는 반복문을 돌려야 하며,그 때마다 문자열을 탐색하고, 반복적으로 slice 해야한다. 보통의 경우 slice 함수는 O(N)을 따르므로이 풀이의 복잡도는 O(N3)이 된다.","link":"/2021/06/30/05d5f2d85dbc/"},{"title":"[프로그래머스] 표 편집","text":"표 편집Python3 문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다 위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다. &quot;U X&quot;: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다. &quot;D X&quot;: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다. &quot;C&quot; : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다. &quot;Z&quot; : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다. 예를 들어 위 표에서 &quot;D 2&quot;를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, &quot;C&quot;를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 “네오”가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다). 다음으로 &quot;U 3&quot;을 수행한 다음 &quot;C&quot;를 수행한 후의 표 상태는 아래 그림과 같습니다. 다음으로 &quot;D 4&quot;를 수행한 다음 &quot;C&quot;를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다. 다음으로 &quot;U 2&quot;를 수행하면 현재 선택된 행은 2행이 됩니다. 위 상태에서 &quot;Z&quot;를 수행할 경우 가장 최근에 제거된 &quot;라이언&quot;이 적힌 행이 원래대로 복구됩니다. 다시한번 &quot;Z&quot;를 수행하면 그 다음으로 최근에 제거된 &quot;콘&quot;이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요.\\ 이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 &quot;O&quot;, 삭제된 행은 &quot;X&quot;로 표시하면 다음과 같습니다. 처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요. 제한사항 5 ≤ n ≤ 1,000,000 0 ≤ k &lt; n 1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 &quot;U X&quot;, &quot;D X&quot;, &quot;C&quot;, &quot;Z&quot; 중 하나입니다. X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다. X가 나타내는 자연수에 ‘,’ 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다. cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다. 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다. 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 &quot;이름&quot; 열을 사용하였으나, &quot;이름&quot;열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. &quot;이름&quot;열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요. 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) “Z”가 명령어로 주어지는 경우는 없습니다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요. 정확성 테스트 케이스 제한 사항 5 ≤ n ≤ 1,000 1 ≤ cmd의 원소 개수 ≤ 1,000 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 n k cmd result 8 2 [&quot;D 2&quot;,&quot;C&quot;,&quot;U 3&quot;,&quot;C&quot;,&quot;D 4&quot;,&quot;C&quot;,&quot;U 2&quot;,&quot;Z&quot;,&quot;Z&quot;] &quot;OOOOXOOO&quot; 8 2 [&quot;D 2&quot;,&quot;C&quot;,&quot;U 3&quot;,&quot;C&quot;,&quot;D 4&quot;,&quot;C&quot;,&quot;U 2&quot;,&quot;Z&quot;,&quot;Z&quot;,&quot;U 1&quot;,&quot;C&quot;] &quot;OOXOXOOO&quot; 입출력 예 설명입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다. 10번째 명령어 &quot;U 1&quot;을 수행하면 &quot;어피치&quot;가 적힌 2행이 선택되며, 마지막 명령어 &quot;C&quot;를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 &quot;제이지&quot;가 적힌 행을 선택합니다. 따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수 풀이 python 풀이 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def solution(n, k, cmd): nodes = {} for i in range(n): nodes[i] = {'U':i-1, 'D':i+1, 'O':True} removed = [] def up(cur, x): while x &gt; 0 and nodes[cur]['U'] &gt; -1: cur = nodes[cur]['U'] x -= 1 return cur def down(cur, x): while x &gt; 0 and nodes[cur]['D'] &lt; n: cur = nodes[cur]['D'] x -= 1 return cur def remove(x): if nodes[x]['U'] &gt; -1: nodes[nodes[x]['U']]['D'] = nodes[x]['D'] if nodes[x]['D'] &lt; n: nodes[nodes[x]['D']]['U'] = nodes[x]['U'] cur = nodes[x]['D'] else: cur = nodes[x]['U'] removed.append(x) nodes[x]['O'] = False return cur def upLink(x, cur): if cur &lt; 0 or nodes[cur]['U'] &lt; 0 : return elif nodes[nodes[cur]['U']]['O'] == True: nodes[nodes[cur]['U']]['D'] = x else: upLink(x, nodes[cur]['U']) def downLink(x, cur): if cur &gt;= n or nodes[cur]['D'] &gt;= n: return elif nodes[nodes[cur]['D']]['O'] == True: nodes[nodes[cur]['D']]['U'] = x else: downLink(x, nodes[cur]['D']) def insert(x): upLink(x,x) downLink(x,x) nodes[x]['O'] = True for c in cmd: cs = c.split(' ') if cs[0] == 'U': k = up(k, int(cs[1])) elif cs[0] == 'D': k = down(k, int(cs[1])) elif cs[0] == 'C': k = remove(k) else: insert(removed.pop()) answer = '' for i in range(n): answer += 'O' if nodes[i]['O'] else 'X' return answer python 풀이 21234567891011121314151617181920212223242526272829def solution(n, k, cmd): removed = [] up = [i - 1 for i in range(n + 2)] down = [i + 1 for i in range(n + 2)] k += 1 for c in cmd: if c[0] == 'C': removed.append(k) up[down[k]] = up[k] down[up[k]] = down[k] k = up[k] if n &lt; down[k] else down[k] elif c[0] == 'Z': restore = removed.pop() down[up[restore]] = restore up[down[restore]] = restore else: action, num = c.split() if action == 'U': for _ in range(int(num)): k = up[k] else: for _ in range(int(num)): k = down[k] answer = ['O']*n for i in removed: answer[i-1] = 'X' return &quot;&quot;.join(answer) 설명 시험에서도, 시험 후 복기에서도 굉장히 애를 먹은 문제다. 우선 실제 시험 당시에는 linked-list의 구현을 포기하고 배열을 사용하여 제출했고, 나중에 프로그래머스에서 비슷한 풀이로 풀어본 결과 효율성 테케를 모두 틀렸다. 그 후 천천히 linked-list를 이용해 문제를 풀어보았는데, 첫 번째 풀이가 복잡하고 길어진 이유는 쓸데없이 노드의 고립을 고민해서다. 예를들어 위처럼 5개의 linked list에서 2번노드, 3번노드, 1번노드를 차례대로 삭제하면 아래와 같은 과정이 된다. 여기서 주목할 것은 2번 노드다. 2번노드는 자신이 링크(up, down)를 연결한 인접 노드 모두가 삭제 된 상황이다. 이때, 2번 노드를 다시 복구하면 아래와 같은 상황이 발생한다. 즉, 복구한 2번 노드는 완전히 고립되어 다른 살아있는 노드들과 연결될 수 없다. 나는 이 오류를 고려하여 문제를 풀었고, 풀이 1에서는 On OFF를 나타내는 변수를 포함한 Dictionary를 활용했다. 하지만 이런 오류는 해당 문제에서는 일어날 수가 없었다. 애초에 문제에서 제시한 복구 기능은 마지막에 제거한 node를 살리는 것으로, 반드시 하나 이상의 살아있는 노드와 다시 연결된다. 만약 마지막으로 삭제된 노드를 복구한다는 제한사항이 없었다면 해당 방식의 풀이가 올바른 답이 될 것이다. 그러나 이 문제에서는 고립 문제는 발생하지 않기 때문에 첫 번째 풀이는 다소 효율적이지 못한 코드가 되는 것이다. 이를 반영하여 풀이한 두번째 풀이에서는 복잡해지는 Dictionary를 사용하지 않고 up링크와 down링크 정보를 담은 두 배열을 사용해 문제를 풀었다. 이 때, 각각 머리 끝과 꼬리 끝을 가리키는 -1과 n+1 index를 포함한 n+2개의 배열을 초기화해서 사용했다. 많은 시간을 들이며 고생했지만, 덕분에 제대로 링크드 리스트 유형의 연습을 할 수 있었다. 추후 링크드 리스트 문제를 마주쳤을 때 이 경험을 살려 문제를 돌파할 수 있을 것 같다.","link":"/2021/07/15/ffc3bf1b912a/"},{"title":"[프로그래머스] 수식 최대화","text":"[카카오 인턴] 수식 최대화JavaScript 문제 설명IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.\\이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.\\해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.\\단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.\\만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다. 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다. &quot;100-200*300-500+20&quot; 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.\\대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.\\수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.\\반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다. 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요. [제한사항] expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다. 즉, &quot;402+-561*&quot;처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다. expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다. 즉, &quot;100-2145*458+12&quot;처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다. &quot;-56+100&quot;처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다. expression은 적어도 1개 이상의 연산자를 포함하고 있습니다. 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다. 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다. 입출력 예 expression result &quot;100-200*300-500+20&quot; 60420 &quot;50*6-3*2&quot; 300 입출력 예에 대한 설명입출력 예 #1\\* &gt; + &gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\\연산 순서는 아래와 같습니다.\\100-200*300-500+20\\= 100-(200*300)-500+20\\= 100-60000-(500+20)\\= (100-60000)-520\\= (-59900-520)\\= -60420\\따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다. 입출력 예 #2\\- &gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\\연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)\\50*6-3*2\\= 50*(6-3)*2\\= (50*3)*2\\= 150*2\\= 300\\따라서, 우승 시 받을 수 있는 상금은 300 입니다. 풀이javascript123456789101112131415161718192021222324252627282930function solution(expression) { let answer = 0 const exp_ = expression.split(/([\\+\\-\\*])/g) const splts_ = [...new Set(expression.split(/\\d*/).filter((v)=&gt;v))] const calc = (splts,splt,arr)=&gt; { for(let i =0; i&lt; arr.length;i++){ if(arr[i] === splt){ arr[i-1] = eval(arr[i-1]+arr[i]+arr[i+1]) arr.splice(i,2) i--; } } if(splts.length) splts.forEach((s,i)=&gt;{ const newArr = splts.slice(); newArr.splice(i,1) calc(newArr,s,arr.slice()) }) else if(answer &lt; Math.abs(arr[0])) answer = Math.abs(arr[0]) } splts_.forEach((s_, i_)=&gt;{ const newArr_ = splts_.slice() newArr_.splice(i_,1) calc(newArr_,s_,exp_.slice()) }) return answer} python12345678910111213141516import redef solution(expression): answer = 0 list_s = re.split('([-*+])', expression) orders = ['*+-','*-+','+*-','+-*','-+*','-*+'] for o in orders: cur_l = list_s[:] for v in list(o): while v in cur_l: i = cur_l.index(v) result = eval(str(cur_l[i-1]) + v + str(cur_l[i+1])) cur_l[i+1] = result del cur_l[i-1:i+1] if answer &lt; abs(cur_l[0]) : answer = abs(cur_l[0]) return answer 설명 bfs를 연습하기 좋은 기초 문제다. 우선 주어진 문자열은 정규식의 간단한 활용으로 쉽게 배열화 할 수 있다.이를 이용해 수식들의 순서를 바꿔가며 계산을 진행하면 되는 문제다. 주어진 수식이 + - 세개 밖에 없었기 때문에, 이들의 6개의 순서쌍`[‘+-‘,’-+’,’+-‘,’+-‘,’-+‘,’-*+’]`을 이용하면 된다. 이들 6개의 문자열과 그 문자열 속 각 수식을 나타내는 이중 포문은단지 18번(6x3)의 계산만 할 뿐이다. 따라서 이들은 O(1)과 같다. 그 아래에는 본격적으로 주어진 리스트를 반복하며 돌아가는데,인덱싱 작업이 포함되어 있으므로 사실상 O(N2)의 속도를 보인다.","link":"/2021/06/30/870c92230478/"},{"title":"[프로그래머스] 순위 검색","text":"순위 검색JavaScript 문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다. 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다. 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다. 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다. 인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.\\예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.\\코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가? 물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다. 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가? 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가? 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가? 즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다. 1[조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가? [문제]지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,\\각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] info 배열의 크기는 1 이상 50,000 이하입니다. info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 “개발언어 직군 경력 소울푸드 점수” 형식입니다. 개발언어는 cpp, java, python 중 하나입니다. 직군은 backend, frontend 중 하나입니다. 경력은 junior, senior 중 하나입니다. 소울푸드는 chicken, pizza 중 하나입니다. 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. query 배열의 크기는 1 이상 100,000 이하입니다. query의 각 문자열은 “[조건] X” 형식입니다. [조건]은 “개발언어 and 직군 and 경력 and 소울푸드” 형식의 문자열입니다. 언어는 cpp, java, python, - 중 하나입니다. 직군은 backend, frontend, - 중 하나입니다. 경력은 junior, senior, - 중 하나입니다. 소울푸드는 chicken, pizza, - 중 하나입니다. ‘-‘ 표시는 해당 조건을 고려하지 않겠다는 의미입니다. X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. 예를 들면, “cpp and - and senior and pizza 500”은 “cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?”를 의미합니다. [입출력 예] info query result [&quot;java backend junior pizza 150&quot;,&quot;python frontend senior chicken 210&quot;,&quot;python frontend senior chicken 150&quot;,&quot;cpp backend senior pizza 260&quot;,&quot;java backend junior chicken 80&quot;,&quot;python backend senior chicken 50&quot;] [&quot;java and backend and junior and pizza 100&quot;,&quot;python and frontend and senior and chicken 200&quot;,&quot;cpp and - and senior and pizza 250&quot;,&quot;- and backend and senior and - 150&quot;,&quot;- and - and - and chicken 100&quot;,&quot;- and - and - and - 150&quot;] [1,1,1,1,2,4] 입출력 예에 대한 설명지원자 정보를 표로 나타내면 다음과 같습니다. 언어 직군 경력 소울 푸드 점수 java backend junior pizza 150 python frontend senior chicken 210 python frontend senior chicken 150 cpp backend senior pizza 260 java backend junior chicken 80 python backend senior chicken 50 &quot;java and backend and junior and pizza 100&quot; : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다. &quot;python and frontend and senior and chicken 200&quot; : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다. &quot;cpp and - and senior and pizza 250&quot; : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다. &quot;- and backend and senior and - 150&quot; : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다. &quot;- and - and - and chicken 100&quot; : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다. &quot;- and - and - and - 150&quot; : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다. 풀이javascript 효율성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function solution(info, query) { var dividedObj = {}; var valueSet = []; var infoSet = info.map((i)=&gt;i.split(' ')).sort((a,b)=&gt;{ return b[4] *1 - a[4] *1 }); function getComb(makedList, n, targetList){ if(n === targetList.length) return makedList.map((m)=&gt;m.join('')); var curList = [...makedList]; makedList.forEach((l)=&gt;{ var cl = [...l]; cl.push(targetList[n]); curList.push(cl) }) return getComb(curList,n+1,targetList); } infoSet.forEach((info_)=&gt;{ var info_x = info_.pop(); // var info_join = info_.join('') var gc = getComb([[]],0,info_); gc.forEach((gc_)=&gt;{ if(!dividedObj[gc_]) dividedObj[gc_] = [info_x*1]; else dividedObj[gc_].push(info_x*1); }) }) function binarySearch(ls, target){ var start = 0; var end = ls.length -1; var mid; while(start &lt;= end) { mid = Math.floor((start + end) / 2); if(ls[mid] &gt;= target) start = mid + 1; else end = mid - 1; } return end; } var answer = query.map((q)=&gt;{ var conditions = q.split(' ').filter((w)=&gt;w!=='and' &amp; w!=='-'); var x = conditions.pop()*1; var filteredList = dividedObj[conditions.join('')] if(!filteredList) return 0 return binarySearch(filteredList,x) +1; }) return answer; } python (효율성 실패)1234567891011def solution(info, query): answer = [] def query_filter(info_, qs_): for q_ in qs_[:-1]: if q_ not in info_: return False return (int(info_.split(' ')[-1]) &gt;= int(qs_[-1]) ) for q in query: qs = [q_ for q_ in q.split(' ') if q_ != 'and' and q_ != '-'] answer.append(len(list(filter(lambda x: query_filter(x,qs), info)))) return answer python 효율성123456789101112131415161718192021222324252627282930313233from itertools import combinationsdef solution(info, query): answer = [] info_dict = {'all':[]} info = list(map(lambda x: [i for i in x.split(' ')] ,info)) info.sort(key = lambda x:-1*int(x[-1])) def binary_search(a, x): s = 0; e = len(a) -1; m = (s+e) // 2 while s &lt;= e: m = (s+e) // 2 if a[m] &gt;= x: s = m + 1 else: e = m - 1 return e+1 for info_ in info: i_value = info_.pop() for i in range(1,5): for s in list(combinations(info_, i)): key = ''.join(sorted(list(s))) if key in info_dict: info_dict[key].append(int(i_value)) else: info_dict[key] = [int(i_value)] info_dict['all'].append(int(i_value)) for q in query: qs = [s for s in q.split(' ') if s != 'and' and s != '-'] qv = int(qs.pop()) key = ''.join(sorted(qs)) if len(qs) else 'all' answer.append(binary_search(info_dict[key], qv) if key in info_dict else 0) return answer 설명 info 정보들과 query들을 비교해야하는 문제다. python 효율성 실패 코드는 단순 무식하게 이 둘을 비교하는 코드다.info는 최대 50,000의 값을, query는 최대 100,000의 값을 가지므로당연하게도 해당 코드는 효율성 검증을 실패한다. 다른 풀이(javascript, python)는 효율성 검증이 된 코드들인데,모두 dictionary를 이용해 info를 구조화 했다. (효율성 필수 사항) 주목할 점은 정렬의 활용이다. 구조화 전에 info를 점수를 역순으로 정렬했는데,이러면 dictionary에 담길 점수 list도 점수 크기의 역순으로 담긴다. key값은 단순 배열의 합을 이용했다.이 때 비트 연산을 활용한 풀이를 봤는데, 정말 괜찮은 방법이라 생각된다.시간이 나면 그 방법으로 다시 풀어봐야겠다. 어쨌든 info의 각 요소들을 결합한 키값은 이렇게 된다.1dict = { 'cppbackendjuniorpizza':[150,120,100,90], ... } 위에서 'cppbackendjuniorpizza':[150] 값에 해당하는 데이터는cpp, backend, junior, pizza, 150점을 가진 데이터다. 그런데 이 데이터는 모든 키값을 붙인 cppbackendjuniorpizza 뿐만 아니라,'cpp,junior', 'backend,pizza' 등에도 포함되어야 하는 값이다. 따라서 각 요소들의 조합을 구하는 코드를 활용했다.이 때 조합의 결과값은 순서가 보장되지 않으므로 별도로 정렬해야 했다.(이 과정에서 효율이 매우 떨어지는 것 같다. 비트연산 짱짱맨..) 모든 조합을 dictionary에 담고난 뒤에는 query값을 단순 검색하면 된다.이 때, query에 해당 key값으로 불러온 점수 리스트는 역순 정렬 되어있다. 따라서 같거나 작은 값을 찾았을때 index 값으로 결과를 얻을 수 있다.즉, [150,120,100,50,20]의 리스트에서 100 이상 값의 개수는100의 인덱스(2) + 1 로 간단히 구할 수 있다. 따라서 검색만 가장 효율적으로 하면 되고, 이 때 이진검색 방법을 활용했다. 여기서 보통과는 다르게 end 값을 return 하는데(보통은 m을 리턴),같거나 ‘작은’값을 찾아야 하기 때문이다.","link":"/2021/06/30/30abf4907ad9/"},{"title":"[프로그래머스] 스킬 트리","text":"스킬 트리Javascript, Python 문제 설명선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 제한 조건 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 “CBD”로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 skill skill_trees return &quot;CBD&quot; [&quot;BACDE&quot;, &quot;CBADF&quot;, &quot;AECB&quot;, &quot;BDA&quot;] 2 입출력 예 설명 “BACDE”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. “CBADF”: 가능한 스킬트리입니다. “AECB”: 가능한 스킬트리입니다. “BDA”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다. 스킬 트리: 유저가 스킬을 배울 순서 ↩ 풀이 javascript1234567891011121314151617181920212223function solution(skill, skill_trees) { var answer = 0; var skills = skill.split('') answer = skill_trees.filter((s)=&gt;{ var count = 0; var current_s = s.split('') for(let s_ of current_s){ var i = skills.indexOf(s_); if(i &gt; -1){ if(count === i) count++; else return false; } } return true; }).length return answer;} python12def solution(skill, skill_trees): return len(list(filter(lambda st:skill.find(''.join([s for s in list(st) if s in skill]))==0, skill_trees))) 설명 python 풀이 과정 순서는 다음과 같다. &gt; skill_tree 문자열에서 skill에 포함하는 문자만 찾아 추려낸다. 추려낸 문자들을 이어붙인다. 이어붙인 문자열을 skill이 포함하는지 검색한다. 이때 포함된 index가 0이면 옳은 스킬트리다. 위 과정을 filtering하여 옳은 스킬트리의 갯수만 return한다. 구체적으로 예를 들자면 skill_tree : 'ACBEFG'skill : 'CBD' 일때, ACBEDF에서 CBD에 속한 문자만 추려내면 'CB'가 된다.이걸 다시 skill에서 find 하면, 첫번째 인덱스인 0을 반환한다. 즉, 'ACBEDF' 는 옳은 스킬트리인 것이다.","link":"/2021/06/30/7a7e5aa45a49/"},{"title":"[프로그래머스] 올바른 괄호","text":"올바른 괄호 Python 문제 설명괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어 “()()” 또는 “(())()” 는 올바른 괄호입니다. “)()(“ 또는 “(()(“ 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다. 입출력 예 s answer “()()” true “(())()” true “)()(“ false “(()(“ false 입출력 예 설명입출력 예 #1,2,3,4\\문제의 예시와 같습니다. 풀이 python12345678def solution(s): count = 0 char_value = {'(':1,')':-1} for c in s: count += char_value[c] if count &lt; 0: return False return count == 0 설명 대기업을 비롯한 여러 코딩테스트에서 마주쳤던 괄호 유형의 기본 문제다. 매우 기본적인 문제라 스택을 굳이 사용할 필요가 없었다. 핵심은 여는괄호( ‘(‘ ) 에서는 +값을, 닫히는 괄호( ‘)’ )에서는 -값을 더해서 한 번이라도 count 값이 0보다 낮아지면 올바른 괄호가 아니라는 것이다.","link":"/2021/06/30/1c19e54c6177/"},{"title":"[프로그래머스] 가장 큰 수","text":"가장 큰 수JavaScript, Python 문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 입출력 예 numbers return [6, 10, 2] “6210” [3, 30, 34, 5, 9] “9534330” 풀이 javascript12345678function solution(numbers) { const sortFunc = (a,b) =&gt; { return ((b+'') + (a+''))*1 - ((a+'')+(b+''))*1 } var answer = numbers.sort(sortFunc).join(''); return answer*1 ? answer : &quot;0&quot;} 12345678910from functools import cmp_to_keydef solution(numbers): def sort_func(a,b): if int(a+b) &gt; int(b+a) : return -1 else : return 1 return str(int(''.join(sorted([str(i) for i in numbers],key=cmp_to_key(sort_func))))) 설명 문자열 그대로 합친숫자(ex: 6+10 = 610)를 기준으로 정렬하여 풀었다. 자바스크립트에서는 정렬 기준 비교 함수를 직접 지정할 수 있지만, 파이썬에서는 기본함수에서 이를 제공하지 않는다. 따라서 functools 패키지의 cpm_to_key함수를 써야한다.","link":"/2021/06/30/002aa360eaef/"},{"title":"[프로그래머스] 가장 큰 정사각형 찾기","text":"가장 큰 정사각형 찾기JavaScript, Python 문제 설명1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다. 입출력 예 board answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 설명입출력 예 #1\\위의 예시와 같습니다. 입출력 예 #2\\| 0 | 0 | 1 | 1 |\\| 1 | 1 | 1 | 1 |\\로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다. 풀이 javascript123456789101112131415161718function solution(board) { var answer = 0; answer = board.filter((b)=&gt;b.filter((v)=&gt;v===1).length).length &gt; 0 ? 1 : 0 for (let y = 1; y &lt; board.length; y++) { for (let x = 1; x &lt; board[0].length; x++) { if (board[y][x] === 1) { board[y][x] = (Math.min(board[y][x - 1], board[y - 1][x - 1], board[y - 1][x])) + 1; if (board[y][x] &gt; answer) { answer = board[y][x]; } } } } return answer * answer;} 123456789101112def solution(board): answer = 0 if sum([sum(b) for b in board]) == 0 else 1 for i in range(1,len(board)): for j in range(1,len(board[i])): if board[i][j]: board[i][j] = min(board[i][j-1],board[i-1][j-1],board[i-1][j]) + 1 if board[i][j] &gt; answer: answer = board[i][j] return answer ** 2 설명 배열의 정사각형 부분을 간략히 표현하기 위한 방법을 고민했다. 가장 단순하게 각 점마다 사각형을 확인해보는 함수는 O(N4)까지 효율성이 떨어졌기 때문에, 되도록 O(N2)을 이용하는 방법을 고민했다. 각 열 혹은 행의 합을 이용해서 풀이할 수 있는 방법이 있을까 생각해봤다(스도쿠). 그러나 각 라인 값의 합 만으로는 정사각형을 특정할 수 없었고 결국 배열을 다시 확인하는 작업이 수반되어야 했다. 그러던 중 탐색해 나아갈때마다 값을 누적하는 방식의 풀이를 접하게 되었고, 현재 탐색 점 기준 왼쪽 위로 2x2 사각형의 값을 누적하는 방식의 풀이법을 알게 되었다. 이 때, 3영역의 값 중 최소값을 불러오는데, 이는 사각형을 온전히 이루고 있는지 판단하기 위한 방법이다. 시작 1 1 1 1 1 1 1 1 1 1단계 (1,1)(1,1) -&gt; [ 상단 : 1 , 좌측 : 1 , 좌측 상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 1 1 1 1 2단계 (1,2)(1,2) -&gt; [ 상단 : 1 ,좌측 : 1 ,좌측상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 2 1 1 1 3단계 (2,1)(2,1) -&gt; [ 상단 : 1 ,좌측 : 1 ,좌측상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 2 1 2 1 4단계 (2,2)(2,2) -&gt; [ 상단 : 2 ,좌측 : 2 ,좌측상단 : 2 ] 이므로 -&gt; 3 1 1 1 1 2 2 1 2 3 이 과정에서 탐색 값 중 0의 값이 포함되어 있다면 현재 값은 오직 1을 갖는다. 따라서 해당 방법으로 (i,j)가 온전한 사각형인지, 만약 그렇다면 얼만큼의 크기를 갖는지 알 수 있다.","link":"/2021/06/30/f053a7b14ee2/"},{"title":"[프로그래머스] 거리두기 확인하기","text":"거리두기 확인하기Python3 문제 설명개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다. 코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼\\아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다. 대기실은 5개이며, 각 대기실은 5x5 크기입니다. 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요. 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다. 예를 들어, 위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다. 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다. 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다. 응시자가 앉아있는 자리(P)를 의미합니다. 빈 테이블(O)을 의미합니다. 파티션(X)을 의미합니다. 5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 places의 행 길이(대기실 개수) = 5 places의 각 행은 하나의 대기실 구조를 나타냅니다. places의 열 길이(대기실 세로 길이) = 5 places의 원소는 P,O,X로 이루어진 문자열입니다. places 원소의 길이(대기실 가로 길이) = 5 P는 응시자가 앉아있는 자리를 의미합니다. O는 빈 테이블을 의미합니다. X는 파티션을 의미합니다. 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다. return 값 형식 1차원 정수 배열에 5개의 원소를 담아서 return 합니다. places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다. 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다. 입출력 예 places result [[&quot;POOOP&quot;, &quot;OXXOX&quot;, &quot;OPXPX&quot;, &quot;OOXOX&quot;, &quot;POXXP&quot;], [&quot;POOPX&quot;, &quot;OXPXP&quot;, &quot;PXXXO&quot;, &quot;OXXXO&quot;, &quot;OOOPP&quot;], [&quot;PXOPX&quot;, &quot;OXOXP&quot;, &quot;OXPOX&quot;, &quot;OXXOP&quot;, &quot;PXPOX&quot;], [&quot;OOOXX&quot;, &quot;XOOOX&quot;, &quot;OOOXX&quot;, &quot;OXOOX&quot;, &quot;OOOOO&quot;], [&quot;PXPXP&quot;, &quot;XPXPX&quot;, &quot;PXPXP&quot;, &quot;XPXPX&quot;, &quot;PXPXP&quot;]] [1, 0, 1, 1, 1] 입출력 예 설명입출력 예 #1 첫 번째 대기실 No. 0 1 2 3 4 0 P O O O P 1 O X X O X 2 O P X P X 3 O O X O X 4 P O X X P 모든 응시자가 거리두기를 지키고 있습니다. 두 번째 대기실 No. 0 1 2 3 4 0 P O O P X 1 O X P X P 2 P X X X O 3 O X X X O 4 O O O P P (0, 0) 자리의 응시자와 (2, 0) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (1, 2) 자리의 응시자와 (0, 3) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (4, 3) 자리의 응시자와 (4, 4) 자리의 응시자가 거리두기를 지키고 있지 않습니다. 세 번째 대기실 No. 0 1 2 3 4 0 P X O P X 1 O X O X P 2 O X P O X 3 O X X O P 4 P X P O X 모든 응시자가 거리두기를 지키고 있습니다. 네 번째 대기실 No. 0 1 2 3 4 0 O O O X X 1 X O O O X 2 O O O X X 3 O X O O X 4 O O O O O 대기실에 응시자가 없으므로 거리두기를 지키고 있습니다. 다섯 번째 대기실 No. 0 1 2 3 4 0 P X P X P 1 X P X P X 2 P X P X P 3 X P X P X 4 P X P X P 모든 응시자가 거리두기를 지키고 있습니다. 두 번째 대기실을 제외한 모든 대기실에서 거리두기가 지켜지고 있으므로, 배열 [1, 0, 1, 1, 1]을 return 합니다. 제한시간 안내 정확성 테스트 : 10초 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 입니다. ↩ 풀이1234567891011121314151617181920212223242526272829303132333435363738def solution(places): answer = [] for place in places: # add person per = [] for row,t in enumerate(place): for col,p in enumerate(t): if p == 'P': per.append([row,col]) def calcBetweenLength(p1,p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) def calcIsRight(arr_p): if len(arr_p) &lt;= 1 : return True new_arr = arr_p[:] cur = new_arr.pop(0) for p in new_arr: c = calcBetweenLength(cur,p) if c == 1: return False elif c == 2: min_r = min(cur[0],p[0]) min_c = min(cur[1],p[1]) if cur[0] == p[0] and place[min_r][min_c + 1] == 'X': continue elif cur[1] == p[1] and place[min_r + 1][min_c] == 'X': continue if cur[0] != p[0] and cur[1] != p[1]: if place[min_r][min_c] == 'P' and place[min_r+1][min_c] == 'X' and \\ place[min_r][min_c+1] == 'X': continue elif place[min_r][min_c+1] == 'P' and place[min_r][min_c] == 'X' and \\ place[min_r+1][min_c+1] == 'X': continue return False return calcIsRight(new_arr) answer.append(1 if calcIsRight(per) else 0) return answer 설명 구현 능력을 묻는 카카오 인턴쉽 2번째 문제다. 지도가 주어지고, 이를 해석하며 풀어야하는 문제로 풀이 난이도 자체는 크게 어렵지 않으나 간단하게 풀리지 않는 경우가 많은 유형의 문제다. 따라서 문제의 요구사항에 집중하며 풀어야 하는데, 나는 이 문제를 bfs처럼 풀이했다. 우선 사람들의 위치만을 인식하여 per 배열에 담고, 이들 서로간의 거리를 계산하며 문제를 풀었다. 따라서 사람의 등장에 따라 효율성이 떨어질 수 있지만, 주어진 맵의 크기가 작아 크게 상관 없었다. 단순히 5x5 크기의 map을 돌며 풀 수 있는 풀이로 개선해봐야겠다. -&gt; 풀이 개선 추가123456789101112131415161718192021def solution(places): answer = [] dx = [0,1,1,0,2,1] dy = [1,0,1,2,0,-1] def sol(place): for r, row in enumerate(place): for c, p in enumerate(row): if p == 'P': for i in range(6): if -1 &lt; r+dx[i] &lt; 5 and -1 &lt; c+dy[i] &lt; 5 and place[r+dx[i]][c+dy[i]] == 'P': if i &lt; 2 : return 0 elif i == 2 and (place[r+1][c] != 'X' or place[r][c+1] != 'X'): return 0 elif i == 3 and place[r][c+1] != 'X': return 0 elif i == 4 and place[r+1][c] != 'X': return 0 elif i == 5 and (place[r][c-1] != 'X' or place[r+1][c] != 'X'): return 0 return 1 for p in places: answer.append(sol(p)) return answer","link":"/2021/07/14/0ce2fc799533/"},{"title":"[프로그래머스] 더 맵게","text":"더 맵게Python3 문제 설명매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. 12섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\\Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. 제한 사항 scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. 입출력 예 scoville K return [1, 2, 3, 9, 10, 12] 7 2 입출력 예 설명 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\\새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\\가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\\새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\\가진 음식의 스코빌 지수 = [13, 9, 10, 12] 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다. 풀이 12345678910import heapq as hdef solution(scoville, K): answer = 0 h.heapify(scoville) while scoville[0] &lt; K: if len(scoville) == 1: return -1 v = h.heappop(scoville) + h.heappop(scoville) * 2 h.heappush(scoville, v) answer += 1 return answer 설명 heap을 사용하면 매우 간단히 풀 수 있는 문제다. scoville 지수를 정렬한 뒤, 최소 값을 계산하여 이를 다시 갱신해야 한다. 이 때 heap 자료구조를 사용하면 빠르게 문제를 풀 수 있다.","link":"/2021/07/13/175d07f560c1/"},{"title":"[프로그래머스] 예상 대진표","text":"예상 대진표JavaScript, Python 문제 설명△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, … , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다. 이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다. 제한사항 N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.) A, B : N 이하인 자연수 (단, A ≠ B 입니다.) 입출력 예 N A B answer 8 4 7 3 입출력 예 설명입출력 예 #1\\첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다. 항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다. 두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다. 항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다. 세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다. 풀이 javascript12345678910function solution(n,a,b){ let answer = 0; while(a !== b){ a = Math.ceil(a/2) b = Math.ceil(b/2) answer++; } return answer} python12345678def solution(n,a,b): answer = 0 while a != b: answer += 1 a, b = ((a+1) // 2, (b+1) // 2) return answer 설명 math의 ceil함수로 올림을 사용하면 더 편리하지만, 패키지의 사용을 최소화 하려 노력하고 있기 때문에 a 와 b에 1을 더해서 내부 내림 연산 (//)을 사용했다. 비트를 이용한 풀이도 존재한다. 12def solution(n,a,b): return ((a-1)^(b-1)).bit_length() bit_length 함수는 정수를 2진법으로 표현할 때 필요한 비트 수를 반환한다. 즉, 두 정수 a-1,b-1이 xor 연산을 통해 서로의 최대 자리수 차이를 구하고 이 값의 표현에 필요한 비트 수를 통해 총 필요한 경기수를 알 수 있다. 가깝게 대진표가 잡힌다면 적은 경기 수를, 대진표가 서로 멀리 잡힌다면 비교적 많은 경기 수를 필요로 하게 된다. a = 1, b = 3 이라면(a-1)^(b-1) = 00 ^ 10 = 10 이고,이진법 10의 필요 비트 수는 2 이므로 2번의 경기를 통해 만날 수 있다. a = 1, b = 8 이라면(a-1)^(b-1) = 0000 ^ 1000 = 1000 이고,이진법 1000의 필요 비트 수는 4 이므로 총 4번의 경기를 통해 만날 수 있다.","link":"/2021/06/30/4eea72582091/"},{"title":"[프로그래머스] 영어 끝말잇기","text":"영어 끝말잇기JavaScript, Python 문제 설명1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다. tank → kick → know → wheel → land → dream → mother → robot → tank 위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다. 사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요. 제한 사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요. 입출력 예 n words result 3 [“tank”, “kick”, “know”, “wheel”, “land”, “dream”, “mother”, “robot”, “tank”] [3,3] 5 [“hello”, “observe”, “effect”, “take”, “either”, “recognize”, “encourage”, “ensure”, “establish”, “hang”, “gather”, “refer”, “reference”, “estimate”, “executive”] [0,0] 2 [“hello”, “one”, “even”, “never”, “now”, “world”, “draw”] [1,3] 입출력 예 설명입출력 예 #1\\3명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : tank, wheel, mother 2번 사람 : kick, land, robot 3번 사람 : know, dream, tank 와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다. 입출력 예 #2\\5명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, recognize, gather 2번 사람 : observe, encourage, refer 3번 사람 : effect, ensure, reference 4번 사람 : take, establish, estimate 5번 사람 : either, hang, executive 와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다. 입출력 예 #3\\2명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, even, now, draw 2번 사람 : one, never, world 와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 ‘r’로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다 풀이 javascript12345678910111213function solution(n, words) { let dict = {} dict[words[0]] = true const isRight = (a,b)=&gt;{return a[a.length-1] !== b[0]} for(let i = 1; i &lt; words.length; i++){ if(dict[words[i]] || isRight(words[i-1], words[i])){ return [(i % n)+1,Math.ceil((i+1) / n)] } else dict[words[i]] = true } return [0,0]} python12345678910import mathdef solution(n, words): dict_ = {} dict_[words[0]] = 0 for i in range(1,len(words)): if words[i-1][-1] != words[i][0] or words[i] in dict_: return [(i % n)+1, math.ceil((i+1)/n)] else: dict_[words[i]] = 0 return [0, 0] 설명 Dictionary를 사용하면 손쉽게 풀 수 있는 문제다. javascript에서는 a, b 를 비교하는 reduce 형식으로 풀었고, 파이썬은 이러한 기능이 있긴 하지만 인덱스로 처리하는 편이 더 편하고 깔끔했다. 하지만 이 때 이전 인덱스와 비교해야 하므로 첫 노드는 건너뛰어야 한다. 그래서 word의 첫 값을 미리 Dict에 넣어 두어야 한다.","link":"/2021/07/07/1ade1b5bae61/"},{"title":"[프로그래머스] 전화번호 목록","text":"전화번호 목록Python3 문제 설명전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.\\전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. 제한 사항 phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다. 입출력 예제 phone_book return [“119”, “97674223”, “1195524421”] false [“123”,”456”,”789”] true [“12”,”123”,”1235”,”567”,”88”] false 입출력 예 설명입출력 예 #1\\앞에서 설명한 예와 같습니다. 입출력 예 #2\\한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다. 입출력 예 #3\\첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다. 알림 2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다. 출처 풀이 python123456def solution(phone_book): phone_book.sort() for i in range(1,len(phone_book)): if phone_book[i].find(phone_book[i-1]) == 0: return False return True 설명 해시 카테고리의 문제이나, 언뜻 생각할 수 있는 풀이 방법은 다양하다. 그러나 문제의 제한사항에서 phone_book의 길이가 최대 100만이므로, $O(N^2)$ 이상은 효율성에서 실패할 것이다. 그러므로 최소한 $O(NlogN)$ 이하의 효율성을 보이는 풀이가 필요하다. hash를 이용해서도 문제를 풀 수 있다. 한 번의 반복문으로 모든 번호를 hash에 넣고, 다시 한 번 배열을 돌며 각 번호의 부분집합이 dict에 포함되어있는지 비교하면 된다. 전화번호의 길이가 최대 20이므로, 총 계산은 $O(21N)$이 되어 아슬아슬하게 풀이에 통과된다. 그러나 가장 간단한 풀이는, 위 코드처럼 번호를 ‘문자’를 기준으로 정렬했을 때다. 이때 접두사가 포함된 문자는 반드시 접두사 문자 바로 뒤에 정렬되기 때문에 간단히 O(N) 비용으로 문제를 풀 수 있다.","link":"/2021/07/18/add9bd8880a2/"},{"title":"[프로그래머스] 짝지어 제거하기","text":"짝지어 제거하기JavaScript 문제 설명짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다. 예를 들어, 문자열 S = baabaa 라면 b aa baa → bb aa → aa → 의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다. 제한사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 입출력 예 s result baabaa 1 cdcd 0 입출력 예 설명입출력 예 #1\\위의 예시와 같습니다.\\입출력 예 #2\\문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다. ※ 공지 - 2020년 6월 8일 테스트케이스가 추가되었습니다. 풀이 javascript1234567891011function solution(s){ let stack = [] for(let i = 0 ; i &lt; s.length; i++){ if(stack.length &gt; 0 &amp;&amp; stack[stack.length-1] === s[i]) stack.pop() else stack.push(s[i]) } return stack.length === 0 ? 1 : 0} 설명 stack 자료구조를 연습하기 좋은 기본 문제다. 문자의 앞에서부터 stack의 마지막 문자(Last In)와 비교하는 행위를 반복한다. 같은 문자라면 pop을 시켜 두 문자를 넘기고, 만약 다른 문자라면 stack에 push한다. 마지막에 stack에 문자가 남으면 실패, 안남으면 성공이다.","link":"/2021/06/30/df45f05f55e0/"},{"title":"[프로그래머스] 큰 수 만들기","text":"큰 수 만들기JavaScript 문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 number k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 출처 풀이javascript12345678910111213141516171819202122232425function solution(number, k) { var nNumSize = number.length - k; var arrRet = Array.from(Array(nNumSize),()=&gt;null); var nPos = 0; var idx = 0; while(nNumSize &gt; 0){ var chMax = 0; for(let i = nPos; i &lt;= number.length - nNumSize; ++i){ if(number[i] &gt; chMax){ chMax = number[i]; nPos = i; if(chMax === &quot;9&quot;) break; } } ++nPos; --nNumSize; arrRet[idx++] = chMax; } return arrRet.join('');} python123456789def solution(number, k): stack = [] n = len(number) for i in range(n): while stack and k &gt; 0 and stack[-1] &lt; number[i]: stack.pop() k -=1 stack.append(number[i]) return ''.join(stack[:n-k]) 설명 탐욕법이 사용 가능하며, 어느정도 구현 능력을 요구하는 문제다. 언뜻 간단히 k * n의 풀이 시간이 필요한 것처럼 보이는데, 여기서 문자열을 다루는 함수를 사용시 O(N)이 추가되어 O(N^2)가 되버리고, 효율성 측면에서 풀이에 실패한다. 스택 자료구조를 이용해 탐욕법으로 풀이를 한다면 O(N)의 풀이가 가능하다(python 풀이). 0부터 number의 길이까지 반복문을 돌며 현재 스택의 마지막 값보다 값이 크면 스택에서 pop()을 반복적으로 수행한다. 이를 통해 스택에는 큰수부터 작은수대로 나열된다. 수의 크기를 결정짓는 부분은 앞쪽이므로 앞 숫자들을 최대화 하는 알고리즘이다. 스택이 아닌 인덱싱을 통해서도 O(NlogN) 풀이가 가능하다(javascript 풀이). 스택을 사용하지 않을 뿐, 값 비교와 인덱싱을 통해 결과를 저장하는 메커니즘은 동일하다.","link":"/2021/06/30/66f0b093388e/"},{"title":"[프로그래머스] 행렬 테두리 회전하기","text":"행렬 테두리 회전하기Python3 문제 설명rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다. x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다. 다음은 6 x 6 크기 행렬의 예시입니다. 이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요. 행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 rows는 2 이상 100 이하인 자연수입니다. columns는 2 이상 100 이하인 자연수입니다. 처음에 행렬에는 가로 방향으로 숫자가 1부터 하나씩 증가하면서 적혀있습니다. 즉, 아무 회전도 하지 않았을 때, i 행 j 열에 있는 숫자는 ((i-1) x columns + j)입니다. queries의 행의 개수(회전의 개수)는 1 이상 10,000 이하입니다. queries의 각 행은 4개의 정수 [x1, y1, x2, y2]입니다. x1 행 y1 열부터 x2 행 y2 열까지 영역의 테두리를 시계방향으로 회전한다는 뜻입니다. 1 ≤ x1 &lt; x2 ≤ rows, 1 ≤ y1 &lt; y2 ≤ columns입니다. 모든 회전은 순서대로 이루어집니다. 예를 들어, 두 번째 회전에 대한 답은 첫 번째 회전을 실행한 다음, 그 상태에서 두 번째 회전을 실행했을 때 이동한 숫자 중 최솟값을 구하면 됩니다. 입출력 예시 rows columns queries result 6 6 [[2,2,5,4],[3,3,6,6],[5,1,6,3]] [8, 10, 25] 3 3 [[1,1,2,2],[1,2,2,3],[2,1,3,2],[2,2,3,3]] [1, 1, 5, 3] 100 97 [[1,1,100,97]] [1] 입출력 예 설명입출력 예 #1 회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다. 입출력 예 #2 회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다. 입출력 예 #3 이 예시에서는 행렬의 테두리에 위치한 모든 칸들이 움직입니다. 따라서, 행렬의 테두리에 있는 수 중 가장 작은 숫자인 1이 바로 답이 됩니다. 풀이 python1234567891011121314151617181920212223242526def solution(rows, columns, queries): square = [i for i in range(1,rows*columns+1)] answer = [] for [r1,c1,r2,c2] in queries: r1-=1;c1-=1;r2-=1;c2-=1; min_ = 10000 temp = None for i in range(c1+1,c2+1): if temp: temp, square[columns*r1 + i] = (square[columns*r1 + i], temp) else: temp, square[columns*r1 + i] = (square[columns*r1 + i], square[columns*r1 + i - 1]) if min_ &gt; temp: min_ = temp for i in range(r1+1,r2+1): temp, square[columns*i + c2] = (square[columns*i + c2], temp) if min_ &gt; temp: min_ = temp for i in range(c2-1,c1-1,-1): temp, square[columns*r2 + i] = (square[columns*r2 + i], temp) if min_ &gt; temp: min_ = temp for i in range(r2-1,r1-1,-1): temp, square[columns*i + c1] = (square[columns*i + c1], temp) if min_ &gt; temp: min_ = temp answer.append(min_) return answer 설명 ‘구현’ 능력이 필요한 문제다. 답에서 회전을 위해 4번의 for문을 사용한다. 각 회전때마다 현재(temp)값과 배열값을 비교하여 교환한다. 이를 통해 이전 값을 한 칸씩 앞으로 이동시킬 수 있다.","link":"/2021/06/30/80a8008d0aab/"},{"title":"[프로그래머스] 소수 찾기","text":"소수 찾기JavaScript, Python 문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers는 길이 1 이상 7 이하인 문자열입니다. numbers는 0~9까지 숫자만으로 이루어져 있습니다. “013”은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다. 입출력 예 numbers return “17” 3 “011” 2 입출력 예 설명예제 #1\\[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다. 예제 #2\\[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다. 11과 011은 같은 숫자로 취급합니다. 출처 풀이 javascript123456789101112131415161718192021222324252627282930function solution(numbers) { const isPrimary = (n) =&gt; n&gt;2 ? ![...Array(Math.ceil(Math.sqrt(n))+1).keys()].slice(2).map(i =&gt; !(n%i)).includes(true) : n===2 const permutator = (inputArr) =&gt; { let result = []; const permute = (arr, m = []) =&gt; { if(m.length) result.push(m) if (arr.length === 0) { result.push(m) } else { for (let i = 0; i &lt; arr.length; i++) { let curr = arr.slice(); let next = curr.splice(i, 1); permute(curr.slice(), m.concat(next)) } } } permute(inputArr) const resultMap = result.map((arr)=&gt;arr.join('')*1); return [...new Set(resultMap)] } return permutator(numbers.split('')).filter(isPrimary).length } python12345678910111213141516from itertools import permutationsdef solution(numbers): sets = set() def isPrime(n): if n == 0 or n == 1: return False if n == 2: return True for k in range(2,int(n ** (1/2))+2): if n % k == 0: return False return True for i in range(1,len(numbers)+1): for s in list(set([int(''.join(p)) for p in permutations(list(numbers),i)] )): sets.add(s) return len(list(filter(isPrime, list(sets)))) 설명 순열에 해당하는 bfs 함수 구현이 특징인 문제다.내장함수에서 순열 기능을 제공하지 않는 언어에서는 난이도가 더 높아진다. javascript로는 이를 재귀함수로 구현했다.그러나 사실상 for문의 중첩(bfs)으로 이뤄져 있어서, 매우 무겁게 작동한다. 소수를 구하는 isPrime 함수와 순열 함수 구현이 끝나면, 뒤는 간단하다.순열 목록에서 중복값을 제거하고 모두 isPrime 에 대입해서 결과를 얻는다.","link":"/2021/06/30/ff9aad7ae3f0/"},{"title":"[프로그래머스] 조이스틱","text":"조이스틱Python 문제 설명조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\\ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 12345&gt;▲ - 다음 알파벳&gt;▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)&gt;◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)&gt;▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 “JAZ”를 만들 수 있습니다. 12345&gt;- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.&gt;- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.&gt;- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.&gt;따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return “JEROEN” 56 “JAN” 23 출처 풀이 python12345678910111213141516171819def solution(name): answer = 0 n = len(name) num_char = [i for i in range(14)] + [j for j in range(12, 0, -1)] change_num_char = lambda char: num_char[ord(char) - ord('A')] for c in name: answer += change_num_char(c) move = n - 1 for i in range(n): next_i = i + 1 while (next_i &lt; n) and (name[next_i] == 'A'): next_i += 1 distance = min(i, n - next_i) move = min(move, i + n - next_i + distance) answer += move return answer 설명 탐욕법을 이용한 풀이 과정은 다음과 같다. 문자열의 바꿔야할 거리를 미리 계산한다. 주어진 문자열의 반복문을 돌며 매 문자 기준에서 정방향과 역방향의 최소값을 계산한다. 정방향으로 이동하는 경우는 n-1로 고정되어있다. 만약 어떤 노드에서 연속되는 A의 길이를 만나 역방향으로의 이동이 더 거리가 짧다면, 해당 역방향 거리 이동값이 move에 갱신된다. 해당 풀이는 다른 선택들에 영향을 끼치지 않고 반복되므로 탐욕법 풀이방법이다.","link":"/2021/06/30/1a78c3799476/"}],"tags":[{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"탐욕법","slug":"탐욕법","link":"/tags/%ED%83%90%EC%9A%95%EB%B2%95/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"카카오","slug":"카카오","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4/"},{"name":"카카오 인턴","slug":"카카오-인턴","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4/"},{"name":"lv2","slug":"lv2","link":"/tags/lv2/"},{"name":"카멜마운트","slug":"카멜마운트","link":"/tags/%EC%B9%B4%EB%A9%9C%EB%A7%88%EC%9A%B4%ED%8A%B8/"},{"name":"모니터암","slug":"모니터암","link":"/tags/%EB%AA%A8%EB%8B%88%ED%84%B0%EC%95%94/"},{"name":"후기","slug":"후기","link":"/tags/%ED%9B%84%EA%B8%B0/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"UMA-2","slug":"UMA-2","link":"/tags/UMA-2/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"gitalk","slug":"gitalk","link":"/tags/gitalk/"},{"name":"comment","slug":"comment","link":"/tags/comment/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"디버깅","slug":"디버깅","link":"/tags/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"Drive","slug":"Drive","link":"/tags/Drive/"},{"name":"Code-36","slug":"Code-36","link":"/tags/Code-36/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"김민태의 프론트엔드 아카데미","slug":"김민태의-프론트엔드-아카데미","link":"/tags/%EA%B9%80%EB%AF%BC%ED%83%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8/"},{"name":"lv1","slug":"lv1","link":"/tags/lv1/"},{"name":"Date","slug":"Date","link":"/tags/Date/"},{"name":"N진법","slug":"N진법","link":"/tags/N%EC%A7%84%EB%B2%95/"},{"name":"문자열","slug":"문자열","link":"/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"lv3","slug":"lv3","link":"/tags/lv3/"},{"name":"lv4","slug":"lv4","link":"/tags/lv4/"},{"name":"최단거리","slug":"최단거리","link":"/tags/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"괄호","slug":"괄호","link":"/tags/%EA%B4%84%ED%98%B8/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"수학","slug":"수학","link":"/tags/%EC%88%98%ED%95%99/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"순열 조합","slug":"순열-조합","link":"/tags/%EC%88%9C%EC%97%B4-%EC%A1%B0%ED%95%A9/"},{"name":"linked list","slug":"linked-list","link":"/tags/linked-list/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"bit","slug":"bit","link":"/tags/bit/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"stack","slug":"stack","link":"/tags/stack/"}],"categories":[{"name":"TIL","slug":"TIL","link":"/categories/TIL/"},{"name":"알고리즘","slug":"TIL/알고리즘","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"프로그래머스","slug":"TIL/알고리즘/프로그래머스","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"일상","slug":"일상","link":"/categories/%EC%9D%BC%EC%83%81/"},{"name":"디버깅","slug":"디버깅","link":"/categories/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"lv2","slug":"TIL/알고리즘/프로그래머스/lv2","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/"},{"name":"디버깅","slug":"TIL/디버깅","link":"/categories/TIL/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"typescript","slug":"TIL/typescript","link":"/categories/TIL/typescript/"},{"name":"lv1","slug":"TIL/알고리즘/프로그래머스/lv1","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/"},{"name":"후기","slug":"일상/후기","link":"/categories/%EC%9D%BC%EC%83%81/%ED%9B%84%EA%B8%B0/"},{"name":"기타 오류","slug":"디버깅/기타-오류","link":"/categories/%EB%94%94%EB%B2%84%EA%B9%85/%EA%B8%B0%ED%83%80-%EC%98%A4%EB%A5%98/"},{"name":"lv3","slug":"TIL/알고리즘/프로그래머스/lv3","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/"},{"name":"기타 오류","slug":"TIL/디버깅/기타-오류","link":"/categories/TIL/%EB%94%94%EB%B2%84%EA%B9%85/%EA%B8%B0%ED%83%80-%EC%98%A4%EB%A5%98/"},{"name":"lv4","slug":"TIL/알고리즘/프로그래머스/lv4","link":"/categories/TIL/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv4/"}]}