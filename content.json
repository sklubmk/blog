{"pages":[],"posts":[{"title":"[CSS] rem과 em의 차이","text":"💡 tl;dr CSS의 em과 rem 단위의 정의 em과 rem의 차이점 및 활용 em과 rem은 무엇인가? em과 rem 모두 길이가 유연한 가변 단위로 크기 지정시 어디에나 사용 가능하다. 디자인에 설정된 폰트 크기에 따라 브라우저에 의해 픽셀값으로 변환된다. px값은 브라우저에서 절댓값으로 인식한다 em과 rem의 차이점 차이점을 알아보기 전에 em과 rem이 실제 어떻게 적용되는지 알아야 한다. 어떻게 rem 단위가 픽셀(Pixel)값으로 변환되나 rem 단위로 변환된 픽셀 크기는 페이지 최상위(root) 요소(html 요소)의 폰트 크기가 기준이 된다. 이 최상위 요소의 폰트 크기에 rem 단위로 지정한 숫자를 곱한 값이 마지막 변환된 값이 된다. em 단위가 픽셀값으로 변환되는 공식 em 단위의 픽셀값은 스타일을 지정한 요소의 폰트 크기를 곱한 값이 된다. [em 요소의 중요 사항] em 단위가 상위 요소의 폰트 크기와 직접 연관되어 있다고 잘못 알려져 있다. W3 명세서의 의하면 실제 사용된 요소의 폰트 크기와 직접 연관되어 있다. 상위 요소의 폰트 크기가 em 값에 영향을 줄 수는 있지만, 이는 오로지 스타일 상속 때문이다. em 단위에 미치는 스타일 상속의 영향 모든 요소는 상위 요소로부터 폰트 크기를 상속 받기 때문에 em 단위 계산이 복잡할 수 있다. 보통 em 단위가 사용된 요소는 어떤 상위 요소로부터 폰트 크기를 상속 받았는지 알기 힘들다. 이런 복잡함을 피하려면 오로지 폰트 크기로 px 혹은 vw와 같이 상속에 영향을 받지 않는 단위를 일일이 지정해야 한다. em 상속의 예 [HTML] 12345&lt;div class=&quot;upper&quot;&gt; &lt;div class=&quot;lower&quot;&gt; &lt;!-- ?? padding size ?? --&gt; &lt;/div&gt;&lt;/div&gt; [STYLUS] 1234.upper font-size: 1.25em.lower padding: 1.5em 최상위 요소(html)의 font 값(default) : 16px upper class div의 font-size 계산 : 16px x 1.25 = 20px lower class div의 padding 계산 : 16px x 1.25 x 1.5 = 30px [lower div에 font-size(em) 추가] [STYLUS] 12345.upper font-size: 1.25em.lower font-size: 1.2em padding: 1.5em lower class div의 padding 계산 : 16px x 1.25 x 1.5 x 1.2 = 36px 상위 요소가 더 많아질수록 계산은 복잡해진다. [lower div에 font-size(px) 추가] [STYLUS] 12345.upper font-size: 1.25em.lower font-size: 14px padding: 1.5em lower class div의 padding 계산 : 1.5 x 14px = 21px px단위를 명시하면 상위 요소 상속을 걱정하지 않아도 된다. 브라우저 설정이 HTML 요소의 폰트 크기에 미치는 영향 기본적으로 브라우저의 폰트 크기는 보통 16px로 설정되어 있다. 사용자에 의해 최소 9px부터 72px까지 변경될 수 있다. [중요 사항] html요소의 폰트 크기는 고정값을 지정하지 않았다면 브라우저에 설정된 값을 상속받는다. html요소에 지정된 폰트 크기가 직접 rem값을 결정짓기도 하지만, 브라우저 설정값에서 전해졌을 수도 있다. 브라우저에 지정된 폰트 크기 설정값은 디자인에 사용된 모든 rem 단위의 값에 영향을 주며, 상속의 영향을 받는 모든 em 단위도 마찬가지다. [브라우저 설정이 em 단위로 설정된 HTML 폰트 크기에 미치는 영향] html요소에 em기반의 폰트 크기를 지정했다면, 변환된 픽셀값은 브라우저에 지정된 폰트 크기의 배수가 된다. 만약 html 요소의 font-size 값이 1.25em로 지정되었다면, 최상위 요소의 폰트 크기는 브라우저에 설정된 폰트 크기의 1.25배가 된다. 이때 브라우저의 폰트 크기가 16px로 설정되어 있다면, 최상위 요소의 폰트 크기는 20px이 된다. 계산 : (1.25 x 16 = 20) em과 rem 사이의 차이점 요약 rem단위의 픽셀값 변환은 html요소의 폰트 크기에 따라 결정된다. 또 이 폰트 크기는 상속에 구애를 받지 않는 절대 단위를 지정해서 직접 덮어씌우지 않았다면, 브라우저에 설정된 폰트 크기를 그대로 상속받게 된다. em 단위의 픽셀값 변환은 사용된 요소의 폰트 크기에 따라 결정된다. 이 폰트 크기 또한 상속에 구애를 받지 않는 절대 단위를 가지고 명시적으로 덮어씌우지 않았다면, 상위 요소로부터 상속의 영향을 받는다. 왜 rem 단위를 써야 하는가 요소의 상속 특성에 상관없이 일관된 크기를 돌려준다. 사용자가 설정한 폰트 크기에 따라 사이트에 배치된 모든 구성 요소가 적절하게 반응하는 길을 제공한다. 브라우저의 기본 폰트 크기 설정에따라 가변 텍스트 요소를 활용하여 사이트 레이아웃을 구성할 수 있다. rem기반 레이아웃에서 html요소의 font-size로 고정된 px단위를 지정하는 것은 피해야 한다. 이는 사용자가 브라우저에 설정해 놓은 폰트 크기를 완전히 무시하게 만드는 일이다. html 요소의 폰트 크기를 바꾸고 싶다면 em이나 rem으로 지정해야 브라우저 폰트 비율이 유지된다. 왜 em 단위를 써야 하는가 html 요소 말고도 다른 요소의 폰트 크기에 따라 변하는 특성이 있다. 디자인 요소가 지닌 특별한 상황에 따라 변동성이 요구될 때 사용하면 좋다. 그러나 em 단위의 변동 상황을 늘 관리하기 힘드므로 꼭 필요할 때만 사용해야 한다. 실제 활용 em 단위를 써야할 때 최상위 요소를 제외한 특정 요소의 font-size를 기준으로 그 크기가 바뀌어야 하는 곳. 어느 한 요소의 크기를 정할 때 해당 요소가 기본 폰트 크기로 지정되어 있지 않았을 때. em 사용시 상속에 따른 애매한 상황을 피하고 크기가 대칭적으로 변할 수 있도록, 지정한 요소의 폰트 크기는 rem 단위를 사용해야 한다. 웬만하면 폰트 크기로 em 단위의 사용은 피하자.보통 rem 단위를 쓰면 디자인을 관리하기에 더 편하다. rem 단위를 써야할 때 em 사용 예시를 제외하고, 브라우저에 설정된 폰트 크기에 따라 그 크기가 변해야 하는 모든 곳. 일반 높이, 너비, 패딩, 마진, 테두리 너비, 대부분의 폰트 크기, 그림자 등등 기본적으로 레이아웃의 모든 부분이 해당. 한 마디로, 크기가 변해야 하는 곳이라면 rem 단위를 쓰는게 좋다. em과 rem 모두 쓰지 말아야 하는 곳:[다중 칼럼 레이아웃의 너비] 레이아웃의 다중 칼럼은 보통 %기반의 단위를 써서 예상치 못한 화면 크기에도 유동적으로 반응할 수 있도록 해야 한다다. 칼럼이 하나일 경우에도 일반적으로 max-width에 rem 값을 지정해 놓아도 원만히 작동한다. 예시 1234.container { width: 100%; max-width: 75rem;} 이렇게 하면 칼럼의 크기는 유동적으로 변하지만, 동시에 그 안에 있는 글이 읽기 불편할 정도로 너무 넓어지는 것도 막을 수 있다. [요소의 크기가 절대 변하면 안 되는 상황일 때] 간혹 크기가 변하는 것을 막기 위해 고정된 값을 지정해야 하는 상황. 해당 요소의 크기가 변할 경우 레이아웃이 망가져 버릴 때. 하지만 이런 경우는 별로 없으므로, px 단위를 꺼내 들기 전에 정말로 필요한 것인지 한 번 더 검토해 봐야한다. 총정리 디자인에 쓰인 rem과 em 단위는 폰트 크기를 기준으로 브라우저에 의해 픽셀값으로 변환된다. em 단위는 지정된 요소의 폰트 크기를 기준으로 한다. rem 단위는 html 요소의 폰트 크기를 기준으로 한다. em 단위는 모든 상위 부모 요소로부터의 폰트 크기를 상속받으면서 영향을 받을 수 있다. rem 단위는 브라우저에 설정된 폰트 크기를 상속받는 특성이 있다. em 단위는 최상위 요소에 지정된 폰트 크기 말고, 다른 특정 요소의 폰트 크기에 따라 그 크기가 변해야 하는 곳에 사용. rem 단위는 em 단위를 쓸 필요가 없고, 또 브라우저의 폰트 크기 설정에 따라 그 크기가 변해야 하는 곳에 사용. 폰트 크기 지정을 비롯해서 꼭 em 단위를 써야 하는 곳이 아니라면 rem 단위를 사용. 다중 칼럼 레이아웃의 너비에는 em 이나 rem 말고 %를 써야한다. 만약에 크기가 변할 경우 해당 요소의 레이아웃이 깨지는 걸 막을 수 없다면 em과 rem 모두 쓰면 안된다. 참고해당 글은 “종합 안내: Rem 그리고 Em, 언제 써야 할까”를 다시 요약한 글입니다.","link":"/2021/07/07/f55f1052709b/"},{"title":"[자바스크립트] 함수 결합","text":"💡 tl;dr 함수 결합(Function Composition)의 정의 예시 및 활용 함수 결합이란 두 개 이상의 함수를 결합하여 새 함수를 생성하는 프로세스 함수를 결합하는 것은 데이터가 흐르기 위해 파이프를 까는 것과 같음 예를 들어, fㆍg 는 자바스크립트에서 f(g(x))와 같고, 이는 아래처럼 안에서 밖으로 순서대로 계산된다. x &nbsp; g &nbsp; f &nbsp; 함수 결합의 활용 아래처럼 chain으로 구성된 간단한 코드가 있다. 12345const toSlug = input =&gt; encodeURIComponent( input.split(' ') .map(str =&gt; str.toLowerCase()) .join('-')); 이를 함수 결합 형태로 다음과 같이 바꿀 수 있다. 1234567891011const toSlug = input =&gt; encodeURIComponent( join('-')( map(toLowerCase)( split(' ')( input ) ) ));console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' 첫 함수보다 가독성이 떨어져 보이지만, 결합의 방향성은 확연히 보인다. .reduceRight() Javascript에는 이를 개선할 수 있는 Array 메서드 .reduce()가 있다. 그러나 .reduce()는 값의 전달 방향이 (왼쪽에서 오른쪽)으로, 예제 toSlug의 형태와는 정 반대의 방향성을 보인다. 이때 사용할 수 있는 함수가 .reduceRight()다. .reduce()와 마찬가지로 reducer 함수와 초기값 x를 사용하고, 배열 함수를 (오른쪽에서 왼쪽)으로 반복하며 누적된 값(v)에 차례로 적용한다. 1const compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x); 이를 적용하면 중첩 없이 위 함수 결합을 다시 작성할 수 있다. 1234567const toSlug = compose( encodeURIComponent, join('-'), map(toLowerCase), split(' '));console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' .reduce() 마찬가지로 .reduce()를 사용하면 (왼쪽에서 오른쪽)으로 순서대로 적용되는 함수의 흐름을 구현할 수 있다. 이를 pipe라고 표현한다. 12345678const pipe = (...fns) =&gt; x =&gt; fns.reduce((v, f) =&gt; f(v), x);const fn1 = s =&gt; s.toLowerCase();const fn2 = s =&gt; s.split('').reverse().join('');const fn3 = s =&gt; s + '!'const newFunc = pipe(fn1, fn2, fn3);const result = newFunc('Time'); // emit! 사용 방법 또한 앞선 compose 함수와 똑같다. 단지 방향성이 바뀌었을 뿐이다. 이를 적용하여 toSlug를 다음과 같이 수정할 수 있다. 1234567const toSlug = pipe( split(' '), map(toLowerCase), join('-'), encodeURIComponent);console.log(toSlug('JS Cheerleader')); // 'js-cheerleader' 함수의 진행 방향이 정확히 반대가 되었다. trace 데이터가 흐르는 파이프를 구현해놨다면, 이를 검증할 수 있는 trace를 사용할 수 있다. trace란 파이프 사이사이에서 데이터의 흐름이 올바른지 확인할 수 있는 전략으로, 일반적으로 다음과 같이 구현한다. 1234const trace = curry((label, x) =&gt; { console.log(`== ${ label }: ${ x }`); return x;}); 사용 방법은 다음과 같다. 12345678910111213const toSlug = pipe( trace('input'), split(' '), map(toLowerCase), trace('after map'), join('-'), encodeURIComponent);console.log(toSlug('JS Cheerleader'));// '== input: JS Cheerleader'// '== after map: js,cheerleader'// 'js-cheerleader' tap tap이란 파이프를 통해 흐르는 데이터에 몇 가지 작업을 수행할 수 있도록하는 기법으로, trace()는 일반적인 tap()의 한 형태일 뿐이다. 다음과 같이 tap()을 작성할 수 있다. 1234const tap = curry((fn, x) =&gt; { fn(x); return x;}); 이제 tap을 이용해 trace를 구현할 수 있다. 123const trace = label =&gt; { return tap(x =&gt; console.log(`== ${ label }: ${ x }`));}; 이러한 예제들을 통해 함수형 프로그래밍이 무엇인지, 어떻게 함수 결합을 활용하여 더 적은 boilerplate로 더 읽기 쉬운 프로그램을 작성하는지 이해할 수 있다. 참고 해당 글은 Master the JavaScript Interview: What is Function Composition?을 번역 및 수정한 글입니다.","link":"/2021/08/02/c61ae76ac2af/"},{"title":"[디버깅] gitalk Redirect UriError in Hexo","text":"💡 tl;dr in config.yml file _permalink option, change ‘:title’ to other option See here : permalinks [example] before : permalink: ‘:year/:month/:day/:title‘ after : permalink: ‘:year/:month/:day/:hash‘ Hexo 블로그에서 Gitalk Redirect_url 오류 해결법 증상Hexo blog comments 기능 중 하나인 Gitalk의 초기화가 되지 않는 현상 원인Redirect_url의 encoding 문제.한글이나 특수 문자가 섞여 있을 경우 오류가 나는것으로 예상 솔루션 ‘_config.yml’ 파일의 permalink 값에서 title을 hash로 변경한다. url에서 title값을 hash값으로 변경해주는 값으로써, url에서 인코딩 문제를 일으킨 한글이나 특수문자가 사라진다. 더 이상 url을 통해 글을 구분할 수 없다는 단점이 있다. 옵션 값 참조 : permalinks","link":"/2021/06/13/6604a2518dc6/"},{"title":"[디버깅] 외장하드 오류코드-36 해결법 (Fix Drive Error Code-36 in Mac)","text":"💡 tl;dr [❓ Problem ❓] 맥북과 윈도우를 오가며 공용으로 사용하던 NTFS 포맷의 외장하드에서 오류 발생 (mac) 파일 이동이 불가능한 현상 (Error Code - 36) [❕ Solution ❕] ❌ dot_clean 명령어 사용했으나 실패, 이후 설정 폴더들 사라지는 추가 문제 발생 ❌ 파일 복구 시스템(disk drill, easyUS, etc .. ) 사용 -&gt; 온전히 복구 실패 ✅ windows OS cmd 에서 chkdsk로 해결 문제 발생 Mac과 Windows 를 동시에 사용하는 나는, 두 데스크탑에서 데이터를 공유하기 위해 USB 허브에 외장 드라이브를 물려 사용해왔다. 처음에 맥에서 외장하드를 연결했을때, 윈도우에서 사용하던 드라이브의 사용이 불가능 했다. 그 이유는 드라이브의 파일 시스템 때문이었다. 기존 사용하던 FAT32 파일 시스템이 맥에서는 사용이 안됐기 때문에, 어쩔 수 없이 NTFS로 포멧하여 사용해야 했다. ❗️ Error Code 36 The Finder can’t complete the operation because some data in “FileName” can’t be read or written. (Error code -36) 그런데 어느 날 Mac에서 작성한 작업 파일이 드라이브에 복사가 되지 않았다.문제는 error code 36이었다. 오류 코드 36은 맥 OS에서 자주 발생하는 나름 악명높은(?) 오류였다. 간단히 설명하면 NTFS 파일 시스템의 드라이브를 맥에서 이용할 때, 드라이브가 꼬이는 문제였다.백업 전용 드라이브라 파일을 반드시 저장해야 하는데, 파일이 이동되지 않으니 참으로 난감한 상황이었다. 이때 그냥 윈도우로 옮겨 저장했어야 했는데… 🤔 당시엔 단순히 가벼운 오류라 생각해서 맥에서 이를 해결해보려 했다. 시행착오 처음 구글링을 통해 시행한 방법은 dot_clean 이었다.특정 macOS 파일을 HFS+/APFS 형식이 지정되지 않은 디스크(예: 파일 공유)에 복사하면 메타데이터가 파일에서 추출되어 dot(‘._’)로 시작하는 보이지 않는 파일에 넣는다고 한다. 이런 숨겨진 시스템 파일을 전송하려는 시도에서 Error Code-36이 자주 발생한다고 한다.이 dot 파일들을 쉽게 정리하는 명령어가 바로 dot_clean 이다.이는 단순 파일 삭제가 아니라 원본과 병합하는 과정을 거치기 때문에 안전(?)하다고 한다. 사용 방법은 간단하다. 1dot_clean /Volumes/MY_VOLUME_PATH 파일 이동이 안되는 드라이브의 경로를 입력해주면 된다.그런데 나는 이때 딱히 변화를 감지하지 못했다. 그래서 볼륨의 루트 경로 한 번, 문제되는 폴더 경로 한 번.총 2번의 dot_clean을 시행했다.사실 각각 시행해도 달라지는건 없었다. 문제는 연결을 잠시 해제(안전하게)하고 난 뒤였다. 폴더 내부 파일의 절반이 날아가버린 것이다. 이어지는 뻘짓 처음엔 너무 당황스러웠다. 마치 약을 먹었는데 그게 더 독이 되어버린 경우였다. 충분히 의심되는 여러 증상들(새 폴더를 생성하면 순식간에 Finder에서 사라지는 등)이 있었지만, 내 머릿속에는 따로 백업도 안된 채 날아간 중요 파일들에대한 걱정 뿐이였다. 나는 결국 데이터 복구 프로그램을 찾기 시작했다. 일단 시중의 Mac용 Drive 복구 프로그램중 제일 유명해보이는 Disk drill과 easyUS, 기타 이름모를 복구 프로그램들을 닥치는대로 받아가며 복구가 가능한지 시도해봤다. 그 중 가장 유의미하게 복구가 가능한 것으로 보여지는 것은 Disk drill이었다.그러나 그 마저도 잃어버린 50% 파일 중 20%정도 남짓에 불과했다.그 20% 안에는 중요 계약 서류들이 있어서 이것을 돈주고 복구해야 하는지 내적고민을 엄청나게 했다. 약 10만원 가량의 비용이었기 때문에 정말 앉아서 돈을 잃는 경우라고 생각했고, 조금은 이성을 되찾기로 했다. 이어지는 고민과 명상 도중 드는 생각은 Mac은 왜이렇게 불안정할까 였다.윈도우에선 이런일이 없었는디… 라는 생각이 들었고,이 흐름은 마침내 Windows의 chkdsk 기능으로 도달했다. 🔥아 맞다 그런게 있었지!!!!! 🔥 해결 Windows의 CHKDSK 기능은 정말 막강하다. CHKDSK는 다양한 메모리 관련 문제를 예방하고 해결하기 위한 윈도우의 자체적인 기능이다.드라이브 포멧을 하던 중 이상이 생겼을 때도, 이 CHKDSK 기능을 활용하여 고쳤던 기억이 났다. 사용법 또한 간단하다. CMD 창을 켠 후 12chkdsk DRIVE_PATH /f /r# DRIVE_PATH 는 자신의 볼륨 주소 (D:, F: 등) 를 입력하면 된다. /f는 디스크에 있는 파일 시스템 오류를 자동으로 수정한다. (빠르다) /r은 불량 섹터를 검사하고 발견되면 복구를 시도한다.작업시간이 매우 느리므로 주의 ❗ ️(수 시간 소요, 도중 취소 불가) 이 작업을 하자 거짓말처럼 드라이브가 깨끗히 복구되었고,심지어 맥에서 생성한 빈 폴더마저 나타났다. 이 문제 때문에 몇 시간을 골머리 썩히며 고생했지만,정말 다행인 점은 복구 프로그램을 결제하지 않았다는 사실이다. 요즘 맥을 메인으로 사용하다보니 이러한 메모리 관련 문제가 자주 발생하는데,그때 마다 정말 윈도우가 선녀였다는 생각이 들곤 한다.","link":"/2021/06/30/64057afee960/"},{"title":"[타입스크립트] 타입스크립트 시작하기","text":"💡 tl;dr typescript 소개 typescript 세팅 타입스크립트가 필요한 이유 약한 타입 언어 자바스크립트 자바스크립트는 타입 시스템이 없는 동적 프로그래밍 언어다. 자바스크립트 변수는 문자열, 숫자, 불린 등 여러 타입의 값을 가질 수 있다. 이를 약한 타입 언어라고 표현한다. 때문에 비교적 유연하게 개발할 수 있는 환경을 제공한다. 그러나 런타임 환경에서 쉽게 에러가 발생할 수 있다. 강한 타입 언어 타입스크립트 타입스크립트는 이러한 자바스크립트에 강한 타입 시스템을 적용한 것이다. 대부분의 에러를 컴파일 환경에서 코드를 입력하는 동안 체크할 수 있다. 높은 가독성과 코드 품질 등을 제공할 수 있다. 치명적인 오류를 더욱 쉽게 잡아낼 수 있다. JS의 모든 기능을 사용할 수 있을 뿐만 아니라, 추가 장점 기능들을 모두 사용할 수 있는 슈퍼셋이다. 자바스크립트를 대체한다가 아닌 슈퍼셋의 입장으로 공생의 전략을 취하는 언어다. TypeScript 예시 코드 123456789101112// custom type을 생성하여 명시적 선언 가능type Centimeter = number;type RainbowColor = 'red'|'orange'|'yellow'|'green'|'blue'|'navy'|'purple';// 변수 뒤에 :type을 명시 let age:number = 10;let weight:number = 80;let height:Centimeter = 176; let color:RainbowColor = 'orange';// it will be errorcolor = 'black'; JS 프로젝트를 TS 프로젝트로 바꾸기 [parcel.js 기준] 변경할 파일의 파일명 확장자 변경 변경된 파일명 참조값 확인 tsconfig.json 파일 생성 폴더 root에 tsconfig.json 파일을 생성 tsconfig.json 옵션 1234567891011{ &quot;compilerOptions&quot;: { &quot;strict&quot;: true, &quot;target&quot;: &quot;ES5&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;alwaysStrict&quot;: true, &quot;noImplicitAny&quot;: true, &quot;sourceMap&quot;: true, &quot;downlevelIteration&quot;: true }} strict : 코드 작성시 TS 규칙을 강하게 적용할지 여부 target : TS 파일을 컴파일하여 생성된 JS 파일이 사용할 문법체계 버전 module : 모듈 시스템 버전 선택 alwaysStrict : 코드를 ECMAScript Strict 모드로 분석하고 각 소스파일들에 적용 noImplicitAny : Any 타입 사용 여부 (true 선택시 명확히 타입 기술 필요) sourceMap : TS 결과를 출력해놓은 dist 폴더에 소스맵 파일 저장 여부 소스맵 파일 : 변환된 JS파일에서 문제점을 찾기 어려울 수 있으므로 작성한 TS 코드를 그대로 저장해 놓은 데이터 파일 downlevelIteration : 다운레벨링(이전 버전의 자바스크립트로 변환) 방법 결정 활성화시 importHelpers 를 통해 tslib 를 사용하여 인라인 자바스크립트의 양을 줄일 수 있음 비활성화시 모든 object의 루프가 기존 루프(for/ of for)로 다운레벨화 TSConfig 상세 문서","link":"/2021/07/22/48228f4ed3dd/"},{"title":"[운영체제] 운영체제(Operating System)란 무엇인가","text":"💡 tl;dr 운영체제란 무엇인가 컴퓨터의 정의 프로그램의 정의 운영체제의 목적 운영체제 분류 운영 체제(Operating System)의 정의 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층. 컴퓨터란? 정보를 처리 하는 것 정보란 무엇인가 전기적 신호로 표현할 수 있는 데이터의 집합 정보량 I(x) = -log_2{P(x)} 정보의 단위 1이 뜻하는 것 : P(x) = \\frac{1}{2} (true or false) 4지선다형 문제의 정보량은? / 2 == -log_2{\\frac{1}{4}} 정보의 최소단위 : bit 정보의 처리 : 정보의 상태 변환 0에서 1로, 1에서 0으로 부울 대수 (Boolean Algebra): NOT, AND, OR 논리 게이트 : NOT, AND, OR, XOR, NAND, NOR 논리 회로 : IC, LSI, VLSI, ULSI, SoC, ….. 무어의 법칙 : 반도체 집적회로에 경제적으로 쌓을 수 있는 트랜지스터 수가 18개월마다 두 배로 늘어난다 황의 법칙 : 반도체 메모리 용량이 1년마다 2배씩 증가한다 정보의 저장과 전송 : 플립-플롭, 데이터 버스 정보를 처리하다 덧셈 : 반가산기와 전가산기로 표현 가능 (가산기) 뺄셈 : 2의 보수 표현법으로 표현 가능 곱셈과 나눗셈 : 덧셈과 뺄셈의 반복 실수 연산 : 부동 소수점 표현법 함수 : GOTO -&gt; if문, for문의 조합 삼각함수, 미분, 적분, 사진촬영, 동영상 재생, … 컴퓨터는 만능인가? 범용성 : universality NOT, AND, OR 게이트만으로 모든 계산을 할 수 있다. NAND 게이트만으로 모든 계산을 할 수 있다. 범용 컴퓨터 : general-purpose computer s/w를 지원하는 h/w → 컴퓨터 계산가능성 : computability Turing-computable : 튜링 머신으로 계산가능한 것. 정지 문제 (Halting Problem): 튜링 머신으로 풀 수 없는 문제. 컴퓨터를 만든 사람 컴퓨터의 할아버지 앨런 튜링(Alan Turing) Turing Machine Head, Tape, Turing Machines, Universal Turing Machine CPU, RAM, Application Programs, Operating System 컴퓨터의 아버지 폰 노이만(John von Neumann) ISA: Instruction Set Architecture 메모리에 프로그램을 저장하는 컴퓨터 폰 노이만 아키텍처 프로그램이란? 명령어들의 집합 컴퓨터의 하드웨어에 작업을 수행하도록 지시 컴파일러 (프로그래밍 언어 -&gt; 어셈블리 언어) 운영체제도 프로그램인가? 프로그램의 일종 컴퓨터에서 항상 실행되는 프로그램 응용 프로그램에 시스템 서비스 제공 프로세스, 리소스, 사용자 인터페이스 등을 관리 기기의 응용 프로그램들을 관리(운영)해주는 프로그램 협의의 운영체제(커널) 운영체제의 핵심 부분으로 메모리에 상주하는 부분 보안 : 컴퓨터 하드웨어와 프로세스의 보안을 책임 자원 관리 : 한정된 자원을 효율적으로 관리 스케줄링 : 프로세스에 처리기를 할당하는 것 추상화 : 커널은 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 몇 가지 하드웨어 추상화들로 구현 하드웨어 추상화 : 같은 종류의 장비에 대한 공통 명령어의 집합. 프로그래머의 개발을 돕는다. 광의의 운영체제 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념 운영 체제의 목적 컴퓨터 시스템 내의 자원을 여러 사용자 간에 효율적으로 할당, 관리하여 보호 주어진 자원을 최대한의 성능을 내도록 형평성 있게 관리 및 분배 프로그램의 오류나 잘못된 자원 사용을 감시 입출력 장치 등의 자원에 대한 연산과 제어 관리 컴퓨터 시스템을 편리하게 사용할 수 있도록 환경을 제공 하는것 동시 사용자/ 프로그램들이 각각 독자적 컴퓨터에서 수행되는것 같은 환상을 제공 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행 운영 체제의 분류 동시성 작업 여부 단일 작업 한 번에 하나의 작업만 처리 (MS-DOS 프롬프트 등) 다중 작업 동시에 두 개 이상 작업 처리 (UNIX, MS Windows 등) 사용자의 수 단일 사용자 (single user)ex) MS-DOS, MS Windows 다중 사용자 (multi user)ex) UNIX, NT server 처리 방식 일괄 처리(batch processing) 작업 요청의 일정량 모아서 한 꺼번에 처리 작업이 완전 종료될 때까지 기다려야 함 시분할(time sharing) 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용 일괄 처리 시스템에 비해 짧은 응답시간을 가짐 interactive한 방식 실시간(Realtime OS) 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야하는 실시간시스템을 위한 OS 조그마한 임베디드 시스템, 자동차 엔진 제어 장치, 우주선, 미사일 제어, 반도체 장비, 산업 로봇 등 실시간 시스템의 개념 확장 Hard realtime system (경성 실시간 시스템) Soft realtime system (연성 실시간 시스템) 용어정리 Multitasking : 다수의 작업(혹은 프로세스)이 CPU와 같은 공용자원을 나누어 사용하는 것 Multiprogramming : 여러 프로그램이 메모리에 올라가 있는 것 Time sharing : 시간을 분할하여 CPU의 자원을 나누어 쓰는 것 Multiprocessing : 컴퓨터 시스템 한 대에 둘 이상의 CPU를 이용하여 병렬로 처리하는 것 운영 체제의 예 유닉스(UNIX) 초기엔 서버를 위한 OS 코드 대부분을 C언어로 작성 높은 이식성 최소한의 커널 구조 복잡한 시스템에 맞게 확장 용이 소스 코드 공개 프로그램 개발에 용이 다양한 버전 (Linux, Solaris 등) DOS(Disk Operating System) MS사에서 개발 단일 사용자용 운영체제 메모리 관리 능력의 한계(주 기억장치 : 640KB) MS Windows MS사의 다중작업용 GUI 운영체제 네트워크 환경 강화 DOS와의 호환 적용 불안정성 풍부한 지원 소프트웨어 운영체제의 구조 CPU 스케줄링 메모리 관리 파일 관리 입출력 관리 참고 운영체제 공룡책 강의(주니온) - 인프런 Introduction to Operating Systems - 반효경 커널 - 위키백과","link":"/2021/07/31/da11ddef331f/"},{"title":"[운영체제] 시스템 구조 및 프로그램 실행","text":"💡 tl;dr 컴퓨터 시스템 구조 입출력(I/O)의 수행 저장장치 계층 구조 컴퓨터 시스템 구조 [ CPU ] - [ memory ] - [ I/O device ] 부트스트랩 (bootstrap) 컴퓨터 전원을 켰을때 처음 실행되는 프로그램 부트스트랩 실행 후 운영 체제를 로드함 CPU의 역할 메모리에서 명령어(instruction)를 불러와 실행 실행 후 interrupt line을 체크하여 인터럽트가 발생했는지 확인 OS에게 CPU 권한을 할당 timer에 시간을 정해서 권한을 할당 인터럽트 (Interrupts) CPU가 프로그램을 실행 중일 때 I/O등의 예외상황이 발생하여 처리가 필요할 경우 CPU에게 알려 처리할 수 있도록 하는 것 CPU와 I/O device가 서로 통신하는 방법 중 하나 하드웨어는 언제든지 인터럽트를 트리거 할 수 있음 일반적으로 시스템 버스를 통해 CPU로 신호를 전송 인터럽트 당한 시점의 레지스터와 program counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘김 넓은 의미 하드웨어 인터럽트 : 하드웨어가 발생시킨 인터럽트 Trap (소프트웨어 인터럽트) Exception : 프로그램이 오류를 범한 경우 System call : 프로그램이 커널 함수를 호출하는 경우 OS의 역할 인터럽트 관리 I/O device의 인터럽트가 발생하면 CPU로부터 권한을 받아 어떤 프로그램에서 인터럽트가 사용되었는지 확인 후 메모리 할당 그 후 기존 구동하던 프로그램에 CPU 권한을 할당 프로그램 실행을 위한 환경 제공 사용자 인터페이스 프로그램 실행 입출력 동작 파일 시스템 조작 커뮤니케이션 오류 감지 자원 할당 로깅 보호 및 보안 프로세스(thread) 다중처리, 동기화, 교착 상태, 메모리, 가상 메모리, CPU 스케줄링 등등 모드 비트 (mode bit) 운영체제에는 사용자모드와 커널모드가 있는데, 모드 비트는 운영체제의 현재 모드를 표현하는 값이다. 1 - 사용자 모드 : 사용자 프로그램 수행 제한된 명령어만 CPU에서 실행할 수 있음 사용자 프로그램의 잘못된 수행으로 피해를 막기 위한 보호 및 보안 장치 0 - 모니터 모드 : OS 코드 수행 (커널 모드) 메모리 뿐만 아니라 I/O device 접근 등 모든 일을 할 수 있음 타이머 (timer) 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시키는 장치 값이 0이 되면 타이머 인터럽트 발생 CPU를 특정 프로그램이 독점하는 것으로부터 보호 시분할(time sharing)을 구현하기 위해 널리 이용됨 타이머는 현재 시간을 계산하기 위해서도 사용 장치 제어기 (Device Controller) bus를 통해 CPU와 직접적인 통신을 하는 장치 해당 I/O 장치유형을 관리하는 일종의 작은 CPU 제어 정보를 위해 control register, status register를 가짐 local buffer를 가짐 (일종의 data register) device driver(소프트웨어)는 운영체제가 장치들과 호환되게 해주는 하나의 코드 이를 디바이스 컨트롤러가 인식하는 것 I/O는 실제 device와 local buffer 사이에서 일어남 디바이스 컨트롤러는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 전달 DMA controller 직접 메모리 접근 (Direct Memory Access) CPU처럼 직접 메모리에 접근할 수 있는 컨트롤러 메모리 교통정리 역할 I/O의 local buffer복사작업을 수행하여 CPU의 interrupt 작업을 최소화 시킴 SMP (Symmetric multiprocessing) CPU를 여러개 다는 구조 (각각의 레지스터와 캐시가 존재) 가장 일반적인 멀티 프로세서 시스템 각 피어 CPU 프로세서가 모든 작업을 수행하는 경우 ex) 슈퍼컴퓨터 멀티프로그래밍 (Multiprogramming) 여러 프로그램을 메모리에 모두 올리고 동시에 실행 시키는 설계 CPU 사용률을 높이기 위한 목적 멀티 태스킹 (멀티 프로세싱) CPU 입장에선 각 프로그램의 구동이 찰나의 사용에 불과하므로 여러 프로그램을 시간을 쪼개 사용하여 동시에 작동하게 하는 것 CPU scheduling 여러 프로세스가 동시에 실행될 준비가 된 경우 세스템이 순서를 관리하는 것 CPU 효율을 가장 좋게 만드는 것이 목표 가상화 (Virtualization) 단일 컴퓨터의 하드웨어를 여러 다른 실행 환경으로 추상화 하는 기술 VMM : 가상 머신 매니저 (Virtual Machine Manager) VMware, XEN, WSL 등 사용자와 OS의 상호작용 인터페이스를 이용한 상호작용 CLI (Command Line Interface) 보통 쉘로 알려짐 sh, bash, csh, tcsh, zsh 등 GUI (Graphic User Interface) Windows, MacOS, Linux 등 Touch-Screen Interface Android, iOS 등 System calls API (Application Programming Interface) 커널 함수 호출 운영체제 프로그램의 함수 커널 영역의 code 부분에 속함 standard C library 입출력(I/O)의 수행 모든 입출력 명령은 특권 명령 OS 코드의 상당 부분이 I/O 관리 전용 DMA (Direct Memory Access) 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용 CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송 바이트 단위가 아닌 block 단위로 인터럽트를 발생시킴 ex) 유투브 시청 사용자 프로그램이 I/O를 하는 방법 시스템콜 (system call) 사용자 프로그램은 운영체제에게 I/O 요청 trap을 사용하여 인터럽트 벡터의 특정 위치로 이동 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동 올바른 I/O 요청인지 확인 후 I/O 수행 I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김 I/O를 하기위해 필요한 인터럽트 종류는? (hard or soft) 둘 다 필요 소프트웨어 인터럽트로 요청 끝났을 때는 하드웨어 인터럽트로 controller가 알려줌 시스템 콜 (System Call) 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것 운영 체제의 커널이 제공하는 서비스에 대해 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 프로그래밍 언어에서 지원하지 않는 기능에 대하여 운영 체제의 루틴을 호출하여 이를 이용하는 것 시스템 콜(system call or syscall)의 3가지 기능 사용자 모드에 있는 응용 프로그램이 커널의 기능을 사용할 수 있도록 한다. 시스템 호출을 하면 사용자 모드에서 커널 모드로 바뀐다. 커널에서 시스템 호출을 처리하면 커널 모드에서 사용자 모드로 돌아가 작업을 계속한다. 시스템 콜의 유형 프로세스 제어 (Process Control) 파일 조작 (File Manipulation) 장치 관리 (Device Management) 정보 유지 (Information maintenance) 통신 (Communication) CPU 프로그램 카운터라는 레지스터가 가르키는 메모리에서 인스트럭션을 하나 읽어와 실행 인터럽트가 들어온게 있는지 확인 뒤 있으면 하던 작업을 멈추고 CPU 제어권을 운영체제에게 넘김 OS는 인터럽트 라인별로 있는 인터럽트 벡터의 주소로 찾아가 인터럽트 처리 루틴을 실행함 인터럽트 벡터 해당 인터럽트의 처리 루틴 주소를 가지고 있음 인터럽트 번호, 주소 쌍을 포함 인터럽트 처리 루틴 = Interrupt Service Routine, 인터럽트 핸들러 해당 인터럽트를 처리하는 커널 함수 disk controller가 발생시킨 인터럽트에 대해서 CPU에서 실행시켜야할 커널 함수가 정의되어 있는 것 동기식 입출력 (synchronous I/O) I/O 요청 후 입출력 작업이 오나료된 후에야 제어가 사용자 프로그램에 넘어감 구현 방법 1 I/O가 끝날 때까지 CPU를 낭비시킴 매시점 하나의 I/O만 일어날 수 있음 구현 방법 2 I/O가 완료될 때까지 해당 프로그램에서 CPU를 빼앗음 I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움 다른 프로그램에게 CPU를 줌 비동기식 입출력 (asynchronous I/O) I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감 동기식, 비동기식 입출력 모두 I/O의 완료는 인터럽트로 알려줌 저장장치 계층 구조 (Memory Hierarchy) 서로 다른 특징을 가진 여러 종류의 저장 장치를 함께 사용하여 최적의 효율을 내는 것 싸고 성능 좋은 컴퓨터를 구현하는 설계 위로 올라갈수록 입출력 속력(대역폭)과 비용 증가 아래로 내려갈수록 용량 증가 주 기억장치 컴퓨터에서 수치·명령·자료 등을 기억하는 컴퓨터 하드웨어 장치 CPU에서 직접 접근이 가능 상수를 쓰는 것 이외의 연산은 CPU에서 바로 수행할 수 없음 메모리 값을 레지스터로 로드, 연산, 결과 적용의 단계 필요 휘발성 메모리 저장된 정보를 관리하기 위해 전력이 요구되는 컴퓨터 메모리 전력이 없으면 손실됨 Registers 컴퓨터에서 제일 빠른 메모리 CPU 계산 과정에서 작동 Cache Memory 레지스터 다음으로 빠른 메모리 레지스터와 메인 메모리 간 속도 차이를 완충하기 위해 캐시 메모리 사용 메인 메모리보다 용량이 작으므로 당장 사용할 메모리만 올려서 사용 캐싱과 재사용 목적 투명성 (Transparent) 캐시는 보통 프로그래머가 직접 제어할 수 없으며 CPU에 의해 자동으로 통제됨 캐시가 있든 없든 프로그래머와 외부 사용자에게 보이는 결과는 동일함 이러한 특성을 사용자에게 투명(transparent)하다고 한다. 캐시의 특성을 이해하고 프로그래밍하면 훨씬 효율 좋은 코드를 생성할 수 있다. 메인 메모리 RAM (Random Access Memory)이라 불림. 어느 위치에든 똑같은 속도로 접근하여 읽고 쓸 수 있다는 의미 CPU나 메인보드와 분리되어 있는 메모리 중 최상위 메모리 프로그램을 직접 구동하는 데 사용되는 주 기억 장치의 최하위 메모리 CPU와 캐시에 비하면 훨씬 느리지만, HDD나 SSD보다 차원이 다르게 빠름 보조 기억장치 대용량의 자료를 영구적으로 보관하기 위해서 사용하는 저속, 저가, 대용량의 기억장치 속도적 측면에서 레지스터가 머릿속에서 떠올리는 정보라면 보조기억장치는 지구를 한 바퀴 돌아 찾아오는 정보로 비유됨 CPU에서 직접 접근이 불가능한 메모리 접근하려면 디바이스 드라이버와 시스템 콜을 통해 주기억장치로 로드(Load) 필요 비휘발성 메모리 전원이 공급되지 않아도 저장된 정보를 계속 유지하는 메모리 스토리지 (SSD, HDD) 보조 기억장치 중에서 성능적으로 최상위에 위치 (SSD &gt; HDD) 보통 SSD는 100GB ~ 1TB 정도, HDD는 1TB ~ 6TB 정도의 용량으로 구성 일반적으로 ATA라는 중간 계층을 따로 두어 통신 NVMe SSD는 CPU와 직접 통신 이동식 저장장치 USB 메모리, ODD 등 기업에선 backup용으로 자기테이프도 사용 때로는 키보드, 마우스 등의 입력장치나 클라우드 스토리지 등을 포함하기도 함 참고 시스템 호출 - 위키백과 인터럽트 - 위키백과 메모리 계층 구조 - 나무위키 기억장치 - 나무위키 주기억장치 - 위키백과 운영체제 공룡책 강의(주니온) - 인프런 Introduction to Operating Systems - 반효경","link":"/2021/08/07/b0dd3c8bc4ba/"},{"title":"[일상] 카멜마운트 UMA-2 모니터암 + 선정리 후기","text":"💡 tl;dr 나는 현재 Dell U2718Q 제품과 U2414H 제품을 사용중이다. 덧붙여 맥+데탑+PS4의 조합을 위해 HDMI, USB 선택기를 사용한다. 그러다보니 선들이 매우 혼잡스러웠고, 카멜 마운트 UMA-2 모니터암 2개로 혼내줬다. 이 포스팅은 쿠팡 파트너스 활동의 일환으로, 이에 따른 일정액의 수수료를 제공받습니다. 선정리가 필요해 나는 듀얼모니터로 4k 모니터인 dell u2718q와 fhd모니터인 u2414h를 사용중이다. 이 모니터들로 데스크탑, 맥북(현재는 맥 미니로 대체), 플스를 사용중이고 이를 위해 HDMI 선택기와 USB 선택기를 각각 사용하고 있다. 그렇기 때문에 책상 뒷편은 복잡한 선들로 뒤덮였다. 이런 것들은 실제로 컴퓨터 작업을 할때 꽤나 신경이 쓰이고, 알게 모르게 나의 정신 에너지를 갉아먹고 있다는 생각이 들었다. 그래서 나는 모니터암을 사기로 결심했다. 모니터암 후보는 굉장히 많았다. 나는 보통 물건을 고를 때 다음과 같은 것들을 참고한다. 유명 리뷰 유튜버가 ‘광고’ 없이 찍은 리뷰를 참고한다. 구글링으로 각종 커뮤니티 관련 게시물을 참고한다. 쿠팡(혹은 네이버쇼핑) 리뷰를 확인한다. 지인에게 자문을 구한다. 그런 기준들에서 공통적으로 카멜 마운트 브랜드가 거론되었고, 내게 적합하다고 판단했다. 그 중에서도 UMA-2 제품을 사기로 마음먹었는데, 알루미늄 소재라는 점과 10kg까지 버티는 중량 때문이었다. 내가 사용하는 U2718Q 4K 모니터 무게가 9.3kg이나 나가기 때문이다. 아래는 순서대로 UMA-2, UMA-2H(10~20kg 고중량)다.나는 두 가지 제품을 고민하던 끝에 UMA-2를 선택했다. 설치 Before &amp; After 설치 전 이랬던 선들이... 이렇게 정리됐다 모니터암의 위력은 대단했다! 빨간 선은 보조 모니터의 썬더볼트3 to hdmi 케이블인데, 3m 이상 제품을 구할수가 없어서 조금 아쉬웠지만 어찌됐든 굉장히 만족할 정도로 정리가 됐다. 왜 다들 모니터암 모니터암 하는지 알 수 있었고, 무엇보다 알루미늄 소재인 UMA-2의 고급스러움이 굉장히 만족스럽다. 모니터암 입문을 고민하고 있다면, 정말 강력히 추천한다. 리뷰 끝.","link":"/2021/06/26/3fd9ccd635f7/"},{"title":"[알고리즘] 서로소 집합 자료 구조 (Disjoint Set)","text":"💡 tl;dr 서로소 집합 자료구조(Disjoint set) 서로소 집합 연결 리스트 (Disjoint-set linked lists) 서로소 집합 숲 (Disjoint-set forest) 최적화 서로소 집합 자료 구조 (Disjoint Set) 서로소 집합 자료 구조란 서로소 부분 집합으로 나눠진 원소들에 대한 정보를 다루는 자료구조다. 여기서 서로소 집합은 공통 원소가 없는 두 집합을 뜻한다. 즉, 서로소 집합 자료구조는 상호 배타적인 부분 집합들로 이루어진 원소들을 다루는 자료구조다. 서로소 집합(disjoint-set) 자료 구조 합집합-찾기(union-find) 자료 구조 병합-찾기 집합(merge-find set) 위 3가지 자료 구조는 모두 서로소 부분 집합을 다룬다. 사용 함수 파인드(Find): 어떤 원소가 주어졌을 때 이 원소가 속한 집합을 반환한다. 일반적으로 같은 집합인지 판단하기 위해 집합을 대표하는 원소를 반환한다. 유니온(Union): 두 개의 집합을 하나의 집합으로 합친다. 메이크셋(MakeSet): 특정 한 원소만을 가지는 집합을 만든다. 이 세 가지 연산을 활용하여 많은 파티션(partitioning) 문제들을 해결 할 수 있다. 서로소 집합 연결 리스트 (Disjoint-set linked lists) 서로소 집합 데이터 구조는 간단히 집합을 표현하기 위해 연결 리스트(linked list)를 사용한다. 각 리스트의 헤드(head) 부분에는 해당 집합의 대표 원소를 저장한다. MakeSet은 한 원소만을 가지는 리스트를 생성한다. Union은 두 리스트를 붙이는 연산을 수행한다. 이때 한 리스트의 헤드 부분이 다른 리스트의 꼬리를 가리켜 상수 시간(constant-time) 연산을 수행한다. Find 수행시 특정 원소로부터 리스트의 헤드까지 반대 방향으로 탐색해야 하므로 O(n)이 소요된다. 이 단점은 각 연결 리스트 노드에 헤드를 가리키는 포인터를 포함시켜 해결 할 수 있다. 이 때문에 상수 시간으로 대표 원소를 바로 참조할 수 있다. 그러나 이 경우 Union 연산시 head를 갱신해야하므로 O(n)이 요구된다. 가중치-유니온 휴리스틱 (weighted-union heuristic) 서로소 집합 연결 리스트(Disjoint-set linked lists)의 성능 향상 방법. 만약 각 리스트의 길이를 추적(길이 기준 sorting 등)할 수 있다면, 항상 짧은 리스트를 긴 리스트에 덧붙이며 요구 시간(required time) 성능을 향상시킬 수 있다. n개의 원소들의 m개의 연이은 MakeSet, Union, Find를 수행할 경우 O(m + nlogn) 시간을 요구한다. 점근적으로(asymptotically) 더 빠른 연산을 위해서 다른 자료 구조(Tree 등)가 필요하다. 위 그림에서 전체 노드의 갯수는 n(n=8)이고 연결 리스트 L은 1개의 원소를 담은 배열이다. 배열 L이 자신보다 길이가 같거나 큰 배열과 Union을 수행한다면 매 수행마다 길이가 2배가 되야 한다. 이때 발생하는 비용은 정확히 log_{2}{n}이다. 따라서 특정 리스트(L)안의 특정 원소(node 8)는 최악의 경우 log_{2}{n}번의 갱신이 필요하다. 그러므로 n개의 원소를 가지는 한 리스트는 최악의 경우 O(nlog{n})의 시간이 걸린다. 이 구조에서 각 노드는 원소가 속한 리스트의 이름(head)을 포함하므로 Find 연산은 O(1)의 시간이 걸린다. 서로소 집합 숲 (Disjoint-set forest) 서로소 연결 리스트에 트리(Tree)를 접목한 자료구조 각 노드들은 부모 노드를 참조 각 집합의 대표는 해당 트리의 루트(root) 노드 Find는 루트 노드에 도달할 때까지 부모 노드를 따라 참조 Union은 한 루트 노드를 다룬 루트 노드에 연결하여 병합 최악의 경우 매우 불균형한 트리를 생성하여 연결 리스트와 동일 함수 (Python) 12345678910111213141516# makeSetparent = [0] * (N+1) # 부모 테이블 초기화# 부모 테이블 상에서 자기 자신을 부모로 설정for i in range(1, N+1): parent[i] = i def find(a): # a 정점의 루트 노드 탐색 if parent[a] == a: # a가 루트 노드이면, a 반환 return a return find(parent[a]) # 루트가 아니면 a의 부모 노드로 재탐색 def union(a, b): # a와 b 집합을 병합 a = find(a) # a의 루트 노드 탐색 b = find(b) # b의 루트 노드 탐색 parent[a] = parent[b] 최악의 경우 연결 리스트와 동일한 효율성을 갖는다. 아래 두 가지 방법을 통해 성능을 개선할 수 있다. 유니온 바이 랭크(Union by rank) 항상 작은 트리를 큰 트리 루트에 붙이는 방법 두 트리의 깊이가 같을 경우에만 깊이가 증가 만약 경로 압축을 활용하면 깊이가 같을 경우 알고리즘 동작이 멈추므로 깊이 대신 rank란 용어 사용 한 개의 원소를 가지는 트리의 랭크 = 0 같은 랭크 r을 가지는 두 트리가 합쳐질 경우 r+1의 트리가 만들어짐 이때 Union 또는 Find 연산은 O(logn)을 가진다. [향상된 MakeSet] 123# makeSetparent = [0] * (N+1) # 부모 테이블 초기화rank = [0] * (N+1) # 정점의 rank를 저장 [향상된 Union] 1234567891011def union(a, b): # a와 b 집합을 병합 a = find(a) # a의 루트 노드 탐색 b = find(b) # b의 루트 노드 탐색 if a == b: # 루트 노드가 동일하면, 동일한 집합 return if rank[a] &gt; rank[b]: # rank가 낮은 집합을 rank가 높은 집합으로 병합 parent[b] = a # 병합 else: parent[a] = b # 집합 병합 if rank[a] == rank[b]: # 두 랭크가 동일하면 rank[b] += 1 # 랭크 +1 경로 압축 (path compression) 파인드 연산을 수행 할 때마다 트리의 구조를 평평하게 만드는 방법 방문한 각 노드들이 직접 루트 노드를 가리키도록 갱신하는 것 모든 노드가 같은 대표 노드를 공유 최종 생성된 트리는 보다 평평해짐 해당 원소뿐만 아니라 직/간접적으로 참조하는 연산들의 속도를 빠르게 해줌 Find 연산이 시간 복잡도를 좌우하며 O(N-1)을 따른다. [향상된 Find] 123456def find(a): # a 정점의 루트 노드 탐색 if parent[a] == a: # a가 루트 노드이면, a 반환 return a p = find(parent[a]) # 루트 노드 탐색 parent[a] = p # a의 루트 노드 갱신 return parent[a] 최적화 [최적화 코드 - python] 12345678910111213141516171819202122232425262728N = int(input()) # 노드 수 입력 받기M = int(input()) # 정점 수 입력 받기parent = [0] * (N+1) # 부모 테이블 초기화rank = [0] * (N+1) # 정점의 rank를 저장# 부모 테이블 상에서 자기 자신을 부모로 설정for i in range(1, N+1): parent[i] = i # union find algorithmdef find(a): # a 정점의 루트 노드 탐색 if parent[a] == a: # a가 루트 노드이면, a 반환 return a p = find(parent[a]) # 루트 노드 탐색 parent[a] = p # a의 루트 노드 갱신 return parent[a]def union(a, b): # a와 b 집합을 병합 a = find(a) # a의 루트 노드 탐색 b = find(b) # b의 루트 노드 탐색 if a == b: # 루트 노드가 동일하면, 동일한 집합 return if rank[a] &gt; rank[b]: # rank가 낮은 집합을 rank가 높은 집합으로 병합 parent[b] = a # 병합 else: parent[a] = b # 집합 병합 if rank[a] == rank[b]: # 두 랭크가 동일하면 rank[b] += 1 # 랭크 +1 참고 서로소 집합 자료 구조 - 위키백과 [알고리즘] Union-Find 알고리즘 Union-Find 알고리즘 서로소 집합 / 유니온 파인드 Understanding Disjoint Set Structures - CODEFORCES","link":"/2021/07/28/d0fc2da48b98/"},{"title":"[알고리즘] 시간복잡도와 점근적 표기법","text":"💡 tl;dr 시간복잡도 점근적 표기법 복잡도 비교 시간복잡도 실행시간의 분석 : 실행시간은 실행환경에 따라 달라짐 하드웨어, 운영체제, 언어, 컴파일러 등 실행 시간을 측정하는 대신 연산의 실행 횟수를 카운트 연산의 실행 횟수는 입력 데이터의 크기에 관한 함수로 표현 데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐 최악의 경우 시간복잡도 (worst-case analysis) 평균 시간복잡도 (average-case analysis) 점근적 표기법 점근적 표기법을 사용 데이터의 개수 n→∞일때 수행시간이 증가하는 growth rate로 시간복잡도를 표현하는 기법 Θ-표기, Ο-표기 등을 사용 유일한 분석법도 아니고 가장 좋은 분석법도 아님 다만(상대적으로) 가장 간단하며 알고리즘의 실행환경에 비의존적임 그래서 가장 광범위하게 사용됨 알고리즘에 포함된 연산들의 실행 횟수를 표기하는 하나의 기법 최고차항의 차수만으로 표시 따라서 가장 자주 실행되는 연산 혹은 문장의 실행횟수를 고려하는 것으로 충분 점근표기법: Ο-표기 점근표기법: Ω-표기 점근표기법:Θ-표기 f(n) ∈ O(g(n))을 f(n) = O(g(n))으로 쓰는 경우가 많음 차수가 k≥0인 모든 다항식은 O(nᵏ)이다. 차수가 p인 다항식과 q인 다항식의 합 복잡도 비교 알고리즘은 실행 시간이 다항식 인 경우 효율적 참고 영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠) - 인프런","link":"/2021/08/12/ddfce68ef73c/"},{"title":"[알고리즘] 정렬 알고리즘","text":"💡 tl;dr 버블 정렬 (Bubble Sort) 선택 정렬 (Selection Sort) 삽입 정렬 (Insertion Sort) 그외 정렬 알고리즘들 버블정렬 (Bubble Sort) 동작원리 배열의 0번부터 N-1번까지 탐색을 하면서 인접한 칸과 비교하여 swap 하는 방식 Bubble 정렬을 오름차순으로 1회 실시하고 나서의 결과 j번째 값과 j+1번째 값을 비교해서 만약 j번째의 값이 더 크다면 swap 해주는 식으로 동작 위의 과정을 첫번째는 0 ~ N-1번까지, 두 번째는 0 ~ N-2번까지, 세 번째는 0 ~ N-3번까지 … 식으로 진행되는데 이유는 위의 과정을 보면 알겠지만, 1회 실시하고 나게 되면 최댓값이 가장 마지막으로 가게 된다는 것을 알 수 있다. 즉, 2번째 과정에서는 이미 최댓값 위치에 저장되어있는 가장 마지막 값을 건드릴 필요가 없다. 시간복잡도 처음에는 N-1번탐색, 두 번째는 N-2번 탐색, … 이런식으로 진행되므로총 N-1 + N-2 + N-3 + N-4 + ... + 1 번 진행 = \\cfrac{N(N-1)}2 식의 유도 1, 2, 3, 4, 5 가 존재할 때, 1회 탐색할때 총 1부터 5까지 4번 탐색을 하게된다. 2회 탐색할 때에는 1부터 4까지 3번탐색, 3회는 2번, 4회는 1번 … 총 4 + 3 + 2 + 1 = 10회 탐색을 하게된다. 이 10을 식을 이용해서 도출해 내면 (5 x 4) / 2로 표현할 수 있게 된다. 따라서 위의 식 만큼의 탐색을 하게 된다. 따라서 \\cfrac12N^2 - \\cfrac12N 이라는 시간복잡도를 갖게 되고, O(N^2) 으로 표기할 수 있다. worst case 역방향으로 정렬이 되어 있는 경우 O(N^2) best case 이미 정렬이 되어 있는 경우 O(N^2) 즉, Bubble정렬의 경우 최악이든 최선이든 똑같이 O(N^2)만큼의 시간복잡도를 갖게 된다. 선택 정렬 (Selection Sort) 동작 원리 가장 먼저 제일 앞에 값을 ‘최소값을 가진 Index’ 라고 가정을 하고 탐색 시작. 탐색 진행 중, 만약 ‘최소값을 가진 Index’보다 더 작은 값을 가진 값이 나오면, ‘최소값을 가진 Index’를 더 작은 값을가진 Index번호로 변경. 이 과정을 N-1번까지 진행. 이후에, 제일 앞 Index 번호와, 최소값을 가진 Index번호가 다르다면 swap 해주면 되는 방식 위 그림은 1회전 시켰을 때의 결과값이다. 그렇다면 2회전 시킬 때 시작점을 어디로 잡으면될까? 1번으로 시작하면 된다. 왜냐하면 0번에는 이미 최소값이 자기 자리를 찾아서 정렬되어 있기 때문에 더 이상 관리할 필요가 없기 때문이다. 12345678910111213141516171819// 선택정렬 함수void Selection_Sort(){ // 0부터 끝까지 전체탐색 for(int i = 0 ; i &lt; MAX; i++){ // 가장 작은 값이 저장된 Index를 탐색을 시작하는 Index로 가정하고 탐색시작. int Min_Index = i; // i + 1번부터 끝까지 탐색을 하는데 for(int j = i + 1; i j &lt; MAX; j++){ // 만약 더 작은 값이 나오면 Min_Index값 변경 if(Arr[j] &lt; Arr[Min_Index]) Min_Index = j; } // 만약 변화가 있었다면 swap. if(i != Min_Index) swap(Arr[i], Arr[Min_Index]); }} 시간 복잡도 선택정렬의 경우, 가장 처음에 총 N-1번의 탐색을 하게 된다. 2회전 때는 정렬된 가장 첫번째 값(최소값)을 빼고 N-2번 탐색을 하게된다. 즉, 끝까지 탐색을 하게되면 결과적으로 N-1 + N-2 + N-3 + ... + 1 번 탐색. 이를 수식으로 나타내면 \\cfrac12N^2 - \\cfrac12N 번 탐색을 하게되고, O(N^2)이 된다. worst case 역방향으로 정렬되어 있는 경우 N-1 + N-2 + N-3 + ... + 1번 탐색 O(N^2) best case 이미 정렬이 되어 있는 경우 O(N^2) 삽입 정렬 (Insertion Sort) 동작 원리 삽입정렬은 앞으로 가면서 탐색을 진행한다. N만큼의 크기의 배열을 선언하고 0부터 N-1 번까지의 배열을 사용할때, Index 1번부터 탐색을 진행한다. 왜냐하면 앞으로 가면서 탐색을 하는 방식이기 때문에 0번 Index는 의미가 없기 때문 앞부분에 대해서만 정렬하는 과정 시작 Index를 기점으로 앞으로 쭉 탐색을 진행하는데, 2가지 조건이 있다. Index가 0보다 크거나 같을때 0보다 작은 Index는 존재하지 않기 때문에 아무리 탐색을 많이 하더라도 0보다 크거나 같을 때 까지만 탐색이 가능하다. 비교하는 값이 더 클때 앞의 값이 더 크다면 특정한 과정을 진행한 후 탐색을 계속하지만, 값이 더 작으면 앞쪽 배열은 이미 정렬이 완료된 상태 그대로 탐색을 종료한다. 특별한 과정 현재 값을 Temp 에 저장하고, 비교 값(Temp보다 작은 값)을 현재 index에 복사. 만약 비교값이 같거나 크다면 해당 비교 index에 Temp값 삽입 비교값의 index가 0보다 작아지기 전까지 위 과정 반복 1234567891011121314151617181920void Insertion_Sort(){ // 1번 Index부터 마지막 Index까지 탐색. 0번 Index는 탐색 X for(int Cur_Index = 1; Cur_Index &lt; MAX; Cur_Index++){ // 현재의 값을 Temp라는 임시 저장 변수에 저장. int Temp = Arr[Cur_Index]; // Index를 관리하는 변수. 현재 Index - 1번부터 탐색 시작. int Before_Index = Cur_Index -1; // Index번호가 0보다 크거나 같고, 이전 값이 더 큰 경우만 while( Before_Index &gt;= 0 &amp;&amp; Arr[Before_Index] &gt; Temp { // 값을 그대로 복사해서 넣어주고 Arr[Before_Index + 1] = Arr[Befored_Index]; // 탐색 계속해서 진행 Before_Index = Before_Index - 1; } // 탐색이 종료되면, 올바른 배열을 만들어 주기 위해서 값 삽입. Arr[Before_Index + 1] = Temp; }} 시간 복잡도 삽입정렬은 최악의 경우와 최선의 경우 시간의 차이가 많이 정렬법이다. worst case 역정렬 되어있는 경우 \\cfrac{N(N-1)}2 번 시행 O(N^2) best case 이미 정렬이 되어있는 경우 모든 현재값이 비교값보다 같거나 크므로 1번씩 x N 번 시행 O(N^2) 다른 정렬 알고리즘 퀵소트(quick sort) 알고리즘 최악의 경우 O(N^2), 하지만 평균 시간복잡도는 O(Nlog_2{N}) 합병정렬(merge sort)최악의 경우 O(Nlog_2{N}) 힙 정렬(heap sort)최악의 경우 O(Nlog_2{N}) 참고 영리한 프로그래밍을 위한 알고리즘 강좌 (권오흠) - 인프런","link":"/2021/08/13/54aee196b995/"},{"title":"[프로그래머스] (LV3) n으로 표현","text":"N으로 표현Python3 문제 설명아래와 같이 5와 사칙연산만으로 12를 표현할 수 있습니다. 12 = 5 + 5 + (5 / 5) + (5 / 5)\\12 = 55 / 5 + 5 / 5\\12 = (55 + 5) / 5 5를 사용한 횟수는 각각 6,5,4 입니다. 그리고 이중 가장 작은 경우는 4입니다.\\이처럼 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현 할 수 있는 방법 중 N 사용횟수의 최솟값을 return 하도록 solution 함수를 작성하세요. 제한사항 N은 1 이상 9 이하입니다. number는 1 이상 32,000 이하입니다. 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다. 최솟값이 8보다 크면 -1을 return 합니다. 입출력 예 N number return 5 12 4 2 11 3 입출력 예 설명예제 #1\\문제에 나온 예와 같습니다. 예제 #2\\11 = 22 / 2와 같이 2를 3번만 사용하여 표현할 수 있습니다. 출처 ※ 공지 - 2020년 9월 3일 테스트케이스가 추가되었습니다. 풀이 python123456789101112131415161718192021222324answer = -1def solution(N, number): def sol(count, result): global answer temp = N if count &gt; 8 : return if result == number : if answer &gt; count or answer == -1: answer = count return for i in range(8-count): sol(count+i+1, result + temp) sol(count+i+1, result - temp) sol(count+i+1, result * temp) sol(count+i+1, int(result / temp)) temp = (temp * 10) + N sol(0,0) return answer 설명 난이도 3의 DP(Dynamic Programming, 동적 계획법) 문제다.처음 접했을때 약 4번이나 풀이 방법을 바꿔가며 풀어봤지만 모두 실패했다. 처음엔 BFS 처럼 사칙연산 기호들을 이어붙이는 식으로 풀이를 해보려 했다가 낭패를 봤다. 두 번째에는 딕셔너리를 활용해 연산값을 계속 저장하며 문제를 풀어보려 시도했다. 결과는 역시나 실패. 테스트 케이스 몇 개가 끝까지 해결이 안되었다. 여기서 괄호의 개념을 도입해야 한다는 판단이 들었는데, 이마저 BFS 형식으로 구현하면 시간초과가 날 것이 분명했다. 또한 풀이때 연산 방향에 신경썼는데 지금 생각해보면 전혀 필요 없는 부분이라 그땐 왜 그랬는지 모르겠다. 집중력이 저하된 것 같다. 세 번째 방법은 위에서 쓴 딕셔너리 내의 두 값을 자발적으로 비교하는 방식으로 진행했다. 역시나 풀리지 않는 테스트 케이스들과 시간 초과로 실패했다. 이론상 N값을 이용해 4번의 사칙연산 결과만 저장해 놓으면, 나머지 값들의 비교로 최대 8의 결과값을 구할 수 있다. 그러나 4번째의 딕셔너리 연산이 시간초과를 불러왔다. 네 번째 방법은 위 세 번째 방법과 네 번째 방법을 합쳐서 활용했는데, 풀면서도 절대로 이런식의 풀이가 성공할리 없다는 확신이 들었다. 풀이가 구질구질(?)해지면 거진 실패를 했기 때문에, 그 감정이 스멀스멀 올라오기 시작했을때 손을 놓고 다른 방법을 강구했다. 결국 해법은 비슷한 유형의 문제 풀이를 보고 찾을 수 있었다. 사실 구현 자체만 보면 모든 부분을 탐색하기 때문에 BFS 풀이의 느낌이 강하다. 핵심은 temp 변수에 있다. 두 값을 단순히 붙이는 방법을 자리수 이동으로 해결하고, 이를 연산의 한 방법으로 사용한 것이 굉장히 창의적이여서 이해하기 힘든 부분이었다. 풀이 과정이 간단하니 코드 또한 훨씬 줄고 깔끔해졌다. 두고두고 다시 봐야할 풀이 같다.","link":"/2021/07/04/efedbb0a3ffd/"},{"title":"[프로그래머스] (LV3) 정수 삼각형","text":"정수 삼각형Python3 문제 설명 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요. 제한사항 삼각형의 높이는 1 이상 500 이하입니다. 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다. 입출력 예 triangle result [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] 30 출처 풀이 python12345678def solution(triangle): t = triangle for i in range(1, len(t)): for j in range(len(t[i])): if 0 &lt; j &lt; len(t[i])-1:t[i][j]+= max(t[i-1][j-1], t[i-1][j]) elif j == 0: t[i][j] += t[i-1][j] else : t[i][j] += t[i-1][j-1] return max(t[-1]) 설명 DP 유형의 기본 예제. 배열의 반복문을 돌며 윗 층에서 내려올 수 있는 두 방향 왼쪽과 오른쪽 중 큰 값을 더하며 내려간다. 이를통해 현재 기준 최대의 값을 할당할 수 있고, 계산이 끝난 뒤 마지막 배열에서 최대값을 찾으면 된다.","link":"/2021/07/06/05ad696d31a2/"},{"title":"[프로그래머스] (LV3) 등굣길","text":"등굣길Python3 문제 설명계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. 오른쪽과 아래쪽으로만 움직여 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요. 제한사항 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다. 입출력 예 m n puddles return 4 3 [[2, 2]] 4 입출력 예 설명 풀이 python123456789101112131415def solution(m, n, puddles): inf = 1000000007 dist = [[0]*(m+1) for _ in range(n+1)] dist[0][1] = 1 for p in puddles: dist[p[1]][p[0]] = inf for row in range(1,n+1): for col in range(1,m+1): if dist[row][col] == inf: dist[row][col] = 0 else: dist[row][col] = (dist[row-1][col] + dist[row][col-1]) % inf return dist[n][m] 설명 DP로 풀어야 효율성 케이스를 통과할 수 있는 문제다. divide and conquer를 이용한 재귀함수로 아주 간단히 풀 수 있지만, 효율성에서 통과되지 못했다. 메모리를 활용한 DP 풀이로 다시 풀었을때도 몇가지 케이스를 계속 틀렸는데, 전체 맵을 1로 셋팅하고 i==0 이거나 j==0 인 경우를 무시하고 지나가서 였다. 그러다보니 i==0 이거나 j==0 에서 생긴 웅덩이 다음 길에서 1로 값이 세팅되어 있는 문제점이 있었다. 이를 해결하기 위해 다시 0부터 모든 인덱스를 탐색하며 풀이했다. 간단하게 DP의 핵심 개념을 연습하기 좋은 문제다. 풀이 수정 (2021.08.24) 0 ~ n 까지의 인덱스 할당(총 n+1개) (1,1) 노드부터 DP식으로 계산 (윗 노드 + 왼쪽 노드) 웅덩이를 따로 마킹(inf)하고 추후 이를 0으로 할당 이를통해 복잡한 조건문 없이 풀이 가능","link":"/2021/07/07/5a7de90493fd/"},{"title":"[프로그래머스] (LV3) 디스크 컨트롤러","text":"Python3 문제 설명 하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다. 예를들어 1234- 0ms 시점에 3ms가 소요되는 A작업 요청- 1ms 시점에 9ms가 소요되는 B작업 요청- 2ms 시점에 6ms가 소요되는 C작업 요청 와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.\\ 한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.\\ 1234- A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)- B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)- C: 2ms부터 대기하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms) 이 때 각 작업의 요청부터 종료까지 걸린 시간의 평균은 10ms(= (3 + 11 + 16) / 3)가 됩니다. 하지만 A → C → B 순서대로 처리하면\\ 1234- A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)- C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)- B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms) 이렇게 A → C → B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸린 시간의 평균은 9ms(= (3 + 7 + 17) / 3)가 됩니다. 각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다) 제한 사항 jobs의 길이는 1 이상 500 이하입니다. jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다. 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다. 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다. 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다. 입출력 예 jobs return [[0, 3], [1, 9], [2, 6]] 9 입출력 예 설명문제에 주어진 예와 같습니다. 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다. 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다. 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다. 풀이 python12345678910111213141516171819202122import heapq as hdef solution(jobs): n = len(jobs) jobs.sort(key=lambda x:x[0]); answer = 0 time = 0 while jobs: hq = [] i = 0 while i &lt; len(jobs) and jobs[i][0] &lt;= time: h.heappush(hq,(jobs[i][1],time-jobs[i][0]+jobs[i][1], i)) i+=1; if len(hq) == 0: time = jobs[0][0] else: next_job = h.heappop(hq) time += next_job[0] answer += next_job[1] jobs.pop(next_job[2]) return answer//n 설명 현재 시점 기준으로 요청된 작업들 중 가장 수행시간이 짧은 작업을 매번 선택하면 되고, 이는 그리디 처럼 작동한다. heap queue를 활용하는 문제인데, 처음에 어떤 값을 넣어야 할지 혼동스러웠다. 결과 값으로 저장해야하는 값(처음 요청된 시간 ~ 요청 종료까지 시간)을 기준으로 heap queue에 담았는데, 이러다보니 작업시간이 짧지만 대기한 시간이 긴 작업들의 우선권이 뒤로 밀려버렸다. 이내 수행시간을 기준으로 heap queue에 담아 문제를 푸니 정상적으로 풀이 되었다.","link":"/2021/08/22/3f56f3c9af6f/"},{"title":"[프로그래머스] (LV3) 순위","text":"Python3 문제 설명 n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다. 선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 선수의 수는 1명 이상 100명 이하입니다. 경기 결과는 1개 이상 4,500개 이하입니다. results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다. 모든 경기 결과에는 모순이 없습니다. 입출력 예 n results return 5 [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] 2 입출력 예 설명2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.\\5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다. 출처 풀이 python1234567891011121314151617181920def solution(n, results): answer = 0 wins = [[0]*(n+1) for _ in range(n+1)] for r in results: winner, loser = r wins[winner][loser] = 1 wins[loser][winner] = -1 for start in range(n+1): for visit in range(n+1): for end in range(n+1): if wins[start][end] == 0 and wins[start][visit] == wins[visit][end]: wins[start][end] = wins[start][visit] wins[end][start] = -1*wins[start][visit] for i in range(n+1): if wins[i].count(0) == 2: answer+=1; return answer 설명 1. A가 B를 이겼다 2. B가 C를 이겼다 3. 따라서 A는 C를 이긴다 풀이를 위해선 3번의 간접적인 순위를 직접적인 순위관계로 변화시켜야한다. 각 시작, 방문, 목적지 노드를 뜻하는 세 번의 반복문을 수행한다. 시작 -&gt; 목적지 노드의 순위관계가 정해져 있지 않고, 시작 -&gt; 방문 노드의 순위 관계가 정해져있고, 방문 -&gt; 목적지 노드의 순위관계가 2번의 관계와 동일하다면, 이를 1번에 할당한다. 위 과정을 거치면 확실히 순위관계를 나타낼 수 있는 항목의 값들은 모두 값이 체워진다. 따라서 이러한 노드의 개수를 반환하면 된다.","link":"/2021/08/21/583bf6e35728/"},{"title":"[프로그래머스] (LV3) 입국심사","text":"Python3 문제 설명 n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다. 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다. 입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다. 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다. 심사관은 1명 이상 100,000명 이하입니다. 입출력 예 n times return 6 [7, 10] 28 입출력 예 설명가장 첫 두 사람은 바로 심사를 받으러 갑니다. 7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다. 10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다. 14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다. 20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다. 출처 ※ 공지 - 2019년 9월 4일 문제에 새로운 테스트 케이스를 추가하였습니다. 도움을 주신 weaver9651 님께 감사드립니다. 풀이 python123456789101112131415def solution(n, times): answer = float('inf') left, right = 1, n*max(times) while left &lt;= right: mid = (left + right) // 2 cur_times= sum(mid//t for t in times) if cur_times &gt;= n: answer = min(answer, mid) right = mid - 1 elif cur_times &lt; n: left = mid + 1 return answer 설명 결과 값은 반드시 times에 포함된 한 값의 공배수가 되므로, times내의 값들을 탐색하며 정답을 찾으면 된다. left는 문제 조건의 최소값인 1을, right는 주어진 times의 최대값 x n을 할당한다. 정답은 반드시 이 두 범위 안에 존재하므로, 이분탐색을 활용하여 정답을 구한다.","link":"/2021/08/20/79376bb85650/"},{"title":"[프로그래머스] (LV) 추석 트래픽","text":"Python3 문제 설명 이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다. 입력 형식 solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다. 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다. 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다. 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 “2016년 9월 15일 오전 3시 10분 33.010초”부터 “2016년 9월 15일 오전 3시 10분 33.020초”까지 “0.011초” 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함) 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다. lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다. 출력 형식 solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다. 입출력 예제예제1 입력: [\\“2016-09-15 01:00:04.001 2.0s”,\\“2016-09-15 01:00:07.000 2s”\\] 출력: 1 예제2 입력: [\\“2016-09-15 01:00:04.002 2.0s”,\\“2016-09-15 01:00:07.000 2s”\\] 출력: 2 설명: 처리시간은 시작시간과 끝시간을 포함하므로\\첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며,\\두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다.\\따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다. 예제3 입력: [\\“2016-09-15 20:59:57.421 0.351s”,\\“2016-09-15 20:59:58.233 1.181s”,\\“2016-09-15 20:59:58.299 0.8s”,\\“2016-09-15 20:59:58.688 1.041s”,\\“2016-09-15 20:59:59.591 1.412s”,\\“2016-09-15 21:00:00.464 1.466s”,\\“2016-09-15 21:00:00.741 1.581s”,\\“2016-09-15 21:00:00.748 2.31s”,\\“2016-09-15 21:00:00.966 0.381s”,\\“2016-09-15 21:00:02.066 2.62s”\\] 출력: 7 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.\\ 해설 보러가기 풀이 python12345678910111213141516171819202122import datetime as dtdef solution(lines): answer = 0 for i in range(len(lines)): l = lines[i] splits = l.split(&quot; &quot;) end = dt.datetime.strptime(&quot; &quot;.join(splits[:2]), &quot;%Y-%m-%d %H:%M:%S.%f&quot;) start = end - dt.timedelta(seconds=float(splits[2][:-1])-0.001) lines[i] = (start, end) for idx in range(len(lines)): count = 0 endTime = lines[idx][1] for i in range(idx,len(lines)): if endTime + dt.timedelta(seconds=0.999) &lt; lines[i][0]: continue; elif endTime &gt; lines[i][1]: continue; else: count+=1; answer = max(answer, count) return answer","link":"/2021/08/31/bf79b39f4914/"},{"title":"[프로그래머스] (LV3) 퍼즐 조각 채우기","text":"퍼즐 조각 채우기Python3 문제 설명 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다. 조각은 한 번에 하나씩 채워 넣습니다. 조각을 회전시킬 수 있습니다. 조각을 뒤집을 수는 없습니다. 게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다. 다음은 퍼즐 조각을 채우는 예시입니다. 위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다. 이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다. 3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다. 5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다. 다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다. 최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다. 현재 게임 보드의 상태 game_board, 테이블 위에 놓인 퍼즐 조각의 상태 table이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 3 ≤ game_board의 행 길이 ≤ 50 game_board의 각 열 길이 = game_board의 행 길이 즉, 게임 보드는 정사각 격자 모양입니다. game_board의 모든 원소는 0 또는 1입니다. 0은 빈칸, 1은 이미 채워진 칸을 나타냅니다. 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다. table의 행 길이 = game_board의 행 길이 table의 각 열 길이 = table의 행 길이 즉, 테이블은 game_board와 같은 크기의 정사각 격자 모양입니다. table의 모든 원소는 0 또는 1입니다. 0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다. 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다. game_board에는 반드시 하나 이상의 빈칸이 있습니다. table에는 반드시 하나 이상의 블록이 놓여 있습니다. 입출력 예 game_board table result [[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]] [[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]] 14 [[0,0,0],[1,1,0],[1,1,1]] [[1,1,1],[1,0,0],[0,0,0]] 0 입출력 예 설명입출력 예 #1 입력은 다음과 같은 형태이며, 문제의 예시와 같습니다. 입출력 예 #2 블록의 회전은 가능하지만, 뒤집을 수는 없습니다. 풀이 python1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def solution(game_board, table): directions = [(1,0),(-1,0),(0,1),(0,-1)] answer = 0 N = len(table) # 퍼즐 저장 함수 def checkingPuzzle(pos,blocks,checkValue,board): x,y = pos if board[y][x] == checkValue: blocks.append((x,y)) board[y][x] = 0 if checkValue == 1 else 1 for d in directions: if -1 &lt; x+d[0] &lt; N and -1 &lt; y+d[1] &lt; N: checkingPuzzle((x+d[0],y+d[1]),blocks,checkValue,board) # 퍼즐 좌표 변환 함수 def syncBlocks(blocks): if len(blocks) == 1: return [(0,0)] blocks = sorted(blocks) sync_x, sync_y = blocks[0] return [ (b[0]-sync_x,b[1]-sync_y) for b in blocks] # 퍼즐 회전 함수 def rotatingPuzzle(blocks): result = [blocks,[],[],[]] for b in blocks: x,y = b result[1].append((N-y,x)) result[2].append((N-x,N-y)) result[3].append((y,N-x)) return result # 퍼즐 및 게임보드 빈 공간 저장 puzzles = [] blanks = [] for i in range(N*N): if table[i//N][i%N] == 1: # 테이블 위 퍼즐 저장 puzzles.append([]) checkingPuzzle( (i%N,i//N), puzzles[-1], 1, table) if game_board[i//N][i%N] == 0: # 게임보드 빈 공간 저장 blanks.append([]) checkingPuzzle( (i%N,i//N), blanks[-1], 0, game_board) # 퍼즐 회전체 추가 및 좌표 변환 for p_i, p in enumerate(puzzles): puzzles[p_i] = [] for r_i, r in enumerate(rotatingPuzzle(p)): puzzles[p_i].append(syncBlocks(r)) # 게임 보드 빈 공간 좌표 변환 for b_i,b in enumerate(blanks): blanks[b_i] = syncBlocks(b) # 두 값 비교 for p_i,p in enumerate( (puzzles) ): for rotate in p: if rotate in blanks: answer += len(rotate) blanks.remove(rotate) break; return answer","link":"/2021/08/18/8c559b93b60c/"},{"title":"[프로그래머스] (LV3) 표 편집","text":"표 편집Python3 문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다 위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다. &quot;U X&quot;: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다. &quot;D X&quot;: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다. &quot;C&quot; : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다. &quot;Z&quot; : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다. 예를 들어 위 표에서 &quot;D 2&quot;를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, &quot;C&quot;를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 “네오”가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다). 다음으로 &quot;U 3&quot;을 수행한 다음 &quot;C&quot;를 수행한 후의 표 상태는 아래 그림과 같습니다. 다음으로 &quot;D 4&quot;를 수행한 다음 &quot;C&quot;를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다. 다음으로 &quot;U 2&quot;를 수행하면 현재 선택된 행은 2행이 됩니다. 위 상태에서 &quot;Z&quot;를 수행할 경우 가장 최근에 제거된 &quot;라이언&quot;이 적힌 행이 원래대로 복구됩니다. 다시한번 &quot;Z&quot;를 수행하면 그 다음으로 최근에 제거된 &quot;콘&quot;이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요.\\ 이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 &quot;O&quot;, 삭제된 행은 &quot;X&quot;로 표시하면 다음과 같습니다. 처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요. 제한사항 5 ≤ n ≤ 1,000,000 0 ≤ k &lt; n 1 ≤ cmd의 원소 개수 ≤ 200,000 cmd의 각 원소는 &quot;U X&quot;, &quot;D X&quot;, &quot;C&quot;, &quot;Z&quot; 중 하나입니다. X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다. X가 나타내는 자연수에 ‘,’ 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다. cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다. 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다. 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 &quot;이름&quot; 열을 사용하였으나, &quot;이름&quot;열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. &quot;이름&quot;열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요. 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다. 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) “Z”가 명령어로 주어지는 경우는 없습니다. 정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요. 정확성 테스트 케이스 제한 사항 5 ≤ n ≤ 1,000 1 ≤ cmd의 원소 개수 ≤ 1,000 효율성 테스트 케이스 제한 사항 주어진 조건 외 추가 제한사항 없습니다. 입출력 예 n k cmd result 8 2 [&quot;D 2&quot;,&quot;C&quot;,&quot;U 3&quot;,&quot;C&quot;,&quot;D 4&quot;,&quot;C&quot;,&quot;U 2&quot;,&quot;Z&quot;,&quot;Z&quot;] &quot;OOOOXOOO&quot; 8 2 [&quot;D 2&quot;,&quot;C&quot;,&quot;U 3&quot;,&quot;C&quot;,&quot;D 4&quot;,&quot;C&quot;,&quot;U 2&quot;,&quot;Z&quot;,&quot;Z&quot;,&quot;U 1&quot;,&quot;C&quot;] &quot;OOXOXOOO&quot; 입출력 예 설명입출력 예 #1 문제의 예시와 같습니다. 입출력 예 #2 다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다. 10번째 명령어 &quot;U 1&quot;을 수행하면 &quot;어피치&quot;가 적힌 2행이 선택되며, 마지막 명령어 &quot;C&quot;를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 &quot;제이지&quot;가 적힌 행을 선택합니다. 따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다. 제한시간 안내 정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수 풀이 python 풀이 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def solution(n, k, cmd): nodes = {} for i in range(n): nodes[i] = {'U':i-1, 'D':i+1, 'O':True} removed = [] def up(cur, x): while x &gt; 0 and nodes[cur]['U'] &gt; -1: cur = nodes[cur]['U'] x -= 1 return cur def down(cur, x): while x &gt; 0 and nodes[cur]['D'] &lt; n: cur = nodes[cur]['D'] x -= 1 return cur def remove(x): if nodes[x]['U'] &gt; -1: nodes[nodes[x]['U']]['D'] = nodes[x]['D'] if nodes[x]['D'] &lt; n: nodes[nodes[x]['D']]['U'] = nodes[x]['U'] cur = nodes[x]['D'] else: cur = nodes[x]['U'] removed.append(x) nodes[x]['O'] = False return cur def upLink(x, cur): if cur &lt; 0 or nodes[cur]['U'] &lt; 0 : return elif nodes[nodes[cur]['U']]['O'] == True: nodes[nodes[cur]['U']]['D'] = x else: upLink(x, nodes[cur]['U']) def downLink(x, cur): if cur &gt;= n or nodes[cur]['D'] &gt;= n: return elif nodes[nodes[cur]['D']]['O'] == True: nodes[nodes[cur]['D']]['U'] = x else: downLink(x, nodes[cur]['D']) def insert(x): upLink(x,x) downLink(x,x) nodes[x]['O'] = True for c in cmd: cs = c.split(' ') if cs[0] == 'U': k = up(k, int(cs[1])) elif cs[0] == 'D': k = down(k, int(cs[1])) elif cs[0] == 'C': k = remove(k) else: insert(removed.pop()) answer = '' for i in range(n): answer += 'O' if nodes[i]['O'] else 'X' return answer python 풀이 21234567891011121314151617181920212223242526272829def solution(n, k, cmd): removed = [] up = [i - 1 for i in range(n + 2)] down = [i + 1 for i in range(n + 2)] k += 1 for c in cmd: if c[0] == 'C': removed.append(k) up[down[k]] = up[k] down[up[k]] = down[k] k = up[k] if n &lt; down[k] else down[k] elif c[0] == 'Z': restore = removed.pop() down[up[restore]] = restore up[down[restore]] = restore else: action, num = c.split() if action == 'U': for _ in range(int(num)): k = up[k] else: for _ in range(int(num)): k = down[k] answer = ['O']*n for i in removed: answer[i-1] = 'X' return &quot;&quot;.join(answer) 설명 시험에서도, 시험 후 복기에서도 굉장히 애를 먹은 문제다. 우선 실제 시험 당시에는 linked-list의 구현을 포기하고 배열을 사용하여 제출했고, 나중에 프로그래머스에서 비슷한 풀이로 풀어본 결과 효율성 테케를 모두 틀렸다. 그 후 천천히 linked-list를 이용해 문제를 풀어보았는데, 첫 번째 풀이가 복잡하고 길어진 이유는 쓸데없이 노드의 고립을 고민해서다. 예를들어 위처럼 5개의 linked list에서 2번노드, 3번노드, 1번노드를 차례대로 삭제하면 아래와 같은 과정이 된다. 여기서 주목할 것은 2번 노드다. 2번노드는 자신이 링크(up, down)를 연결한 인접 노드 모두가 삭제 된 상황이다. 이때, 2번 노드를 다시 복구하면 아래와 같은 상황이 발생한다. 즉, 복구한 2번 노드는 완전히 고립되어 다른 살아있는 노드들과 연결될 수 없다. 나는 이 오류를 고려하여 문제를 풀었고, 풀이 1에서는 On OFF를 나타내는 변수를 포함한 Dictionary를 활용했다. 하지만 이런 오류는 해당 문제에서는 일어날 수가 없었다. 애초에 문제에서 제시한 복구 기능은 마지막에 제거한 node를 살리는 것으로, 반드시 하나 이상의 살아있는 노드와 다시 연결된다. 만약 마지막으로 삭제된 노드를 복구한다는 제한사항이 없었다면 해당 방식의 풀이가 올바른 답이 될 것이다. 그러나 이 문제에서는 고립 문제는 발생하지 않기 때문에 첫 번째 풀이는 다소 효율적이지 못한 코드가 되는 것이다. 이를 반영하여 풀이한 두번째 풀이에서는 복잡해지는 Dictionary를 사용하지 않고 up링크와 down링크 정보를 담은 두 배열을 사용해 문제를 풀었다. 이 때, 각각 머리 끝과 꼬리 끝을 가리키는 -1과 n+1 index를 포함한 n+2개의 배열을 초기화해서 사용했다. 많은 시간을 들이며 고생했지만, 덕분에 제대로 링크드 리스트 유형의 연습을 할 수 있었다. 추후 링크드 리스트 문제를 마주쳤을 때 이 경험을 살려 문제를 돌파할 수 있을 것 같다.","link":"/2021/07/15/8f1c603962dc/"},{"title":"[프로그래머스] (LV2) 124 나라의 숫자","text":"124 나라의 숫자JavaScript, Python 문제 설명124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다. 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다. 예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다. 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요. 제한사항 n은 500,000,000이하의 자연수 입니다. 입출력 예 n result 1 1 2 2 3 4 4 11 풀이 javascript1234567891011121314151617181920212223function solution(n) { var answer = ''; function three(num,count){ if(num === 0) return 0 else{ var cal = Math.floor(num /3); var rest = num % 3; if( rest === 0 ){ cal--; rest = 4; } return three(cal,count+1) + rest * Math.pow(10,count) } } answer = three(n,0) return answer+'';} python12345678910111213141516def solution(n): answer = 0 count = 0 while n &gt; 0: n, r = divmod(n, 3) if r == 0: n -= 1; r = 4; answer += (r * (10 ** count)) count += 1; return str(answer) 설명 진법 변환을 요구하는 문제다. 언뜻 보면 단순히 4진법에서 (3 -&gt; 4)만 변한듯 오해할 수 있으나 124나라 표기법에는 0이 없다는 점을 잊어선 안된다. 10진법 3진법 124나라 1 1 1 2 2 2 3 10 4 4 11 11 5 12 12 6 20 14 7 21 21 8 22 22 9 100 24 10 101 41 3진법과 124나라의 진법을 자세히 살펴보면 핵심은 4에 있다는 것을 알 수 있다. 124나라의 4는 자리 변환이 일어나는 3진법의 10의 성질을 갖고 있다. 따라서 3을 나누어 몫과 나머지를 반복하는 3진법 계산식에서 나머지가 0일때 4의 특성을 입혔다. (몫 -1, 나머지 &lt;- 4) 이 방법을 통해 문제를 해결할 수 있었고, 다른 사람들의 풀이도 이와 비슷한 양상을 보였다.","link":"/2021/06/30/4eb67bcb6e9d/"},{"title":"[프로그래머스] (LV2) H-Index","text":"H-IndexJavaScript, Python 문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. ※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다. https://en.wikipedia.org/wiki/H-index “위키백과” ↩ 풀이 javascript123456789101112function solution(citations) { var answer = 0; var sorted = citations.sort((a,b)=&gt;b-a) for(let i = 0; i &lt; sorted.length; i++){ if(answer &gt; sorted[i]) return answer; else answer = (sorted[i] &lt;= (i+1) ? sorted[i] : i+1) } return answer} python12345678def solution(citations): h = 0 for i, c in enumerate(sorted(citations,reverse=True)): if h &gt; c: return h else: h = (c if c &lt;= (i+1) else i+1) return h 설명 정렬(sort)하지 않고서는 O(N2)이상의 풀이 방법이 없었다. 배열을 내림정렬을 한 뒤, 앞에서 부터 index와 값을 비교하여 최대값을 갱신시켜주면 된다. 여기서 index는 자연스럽게 현재 값보다 같거나 큰 값들의 개수가 된다(정확히는 i+1이). 내가 염려했던 부분은 [5,5,5,5,0]와 같은 배열이었는데, 이 배열의 h값은 4가 나와야 한다. 즉, 배열에 포함되어 있지 않은 값으로도 h가 갱신되어야 한다. 따라서 index와 값을 비교하여 더 낮은 값으로 갱신을 진행했다. 정렬 한 뒤에는 O(N)풀이 인데, 평균적으로는 훨씬 적을 것으로 예상된다.","link":"/2021/06/30/1f72074cd119/"},{"title":"[프로그래머스] (LV2) n진수 게임","text":"N진수 게임JavaScript 문제 설명튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다. 숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다. 10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다. 이렇게 게임을 진행할 경우,\\0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, ...\\순으로 숫자를 말하면 된다. 한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는\\0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, ...\\순으로 숫자를 말하면 된다. 이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라. 입력 형식진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다. 2 ≦ n ≦ 16 0 ＜ t ≦ 1000 2 ≦ m ≦ 100 1 ≦ p ≦ m 출력 형식튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다. 입출력 예제 n t m p result 2 4 2 1 “0111” 16 16 2 1 “02468ACE11111111” 16 16 2 2 “13579BDF01234567” 해설 보러가기 풀이 javascript123456789101112131415161718192021222324252627282930313233function solution(n, t, m, p) { const number_char = {'10':'A','11':'B','12':'C','13':'D','14':'E','15':'F'} const setChange = (v, N) =&gt; { if(v === 0) return 0; let buffer = '' while(v &gt; 0){ let d = Math.floor(v/N); let r = v % N; v = d; buffer += (r &lt; 10 ? r : number_char[r+'']) } return buffer.split('').reverse().join(''); } let answer = ''; let i = 0 let calc_number = 0 let totalWords = '' while(answer.length &lt; t){ while(totalWords.length &lt; m*i+p ){ totalWords += setChange(calc_number,n) calc_number++; } answer += totalWords[m*i+p-1] i++; } return answer;} 설명 가장 최근 본 코딩 테스트에서, 진법의 구현 문제가 나왔다.언어에서 제공하는 함수들이 아니라 직접 N진법을 구현해야 했다. 그런데 오늘 우연히 고른 이 문제가 진법 구현을 다루고 있어 놀랐다.이 문제 또한 N진법의 구현이 기본으로 시작된다. javascript는 toString(N)으로, python은 bin과 hex 함수로 진법을 쉽게 구현할 수 있다.하지만 이런 문제를 통해 구현 능력을 연습해야 하기 때문에 다시 한 번 나는 N진법을 직접 구현해서 사용했다. 이렇게 변환한 진법 값을 통해 전체 리스트에서 ‘튜브’가 뽑을 순서의 값을 반환하면 되는데,순서는 규칙적으로 m(플레이 인원)번마다 돌아온다. 여기에 시작순서 p를 더해서, m*i + p의 값이 전체 리스트에서 튜브가 뽑아야할 값이 된다. 그렇다면 전체 리스트는 어디까지 구해놔야 할까? 나는 튜브가 뽑아야할 순서의 길이보다 작으면 새로 값을 붙여나가는 식으로 구현했고,이 편이 메모리 낭비가 없는 방법이다.","link":"/2021/07/07/fb634df71dff/"},{"title":"[프로그래머스] (LV2) 괄호 변환","text":"괄호 변환Javascript, Python 문제 설명카카오에 신입 개발자로 입사한 “콘”은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.\\수정해야 할 소스 파일이 너무 많아서 고민하던 “콘”은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의‘(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.\\그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.\\예를 들어, &quot;(()))(&quot;와 같은 문자열은 “균형잡힌 괄호 문자열” 이지만 “올바른 괄호 문자열”은 아닙니다.\\반면에 &quot;(())()&quot;와 같은 문자열은 “균형잡힌 괄호 문자열” 이면서 동시에 “올바른 괄호 문자열” 입니다. ‘(‘ 와 ‘)’ 로만 이루어진 문자열 w가 “균형잡힌 괄호 문자열” 이라면 다음과 같은 과정을 통해 “올바른 괄호 문자열”로 변환할 수 있습니다. 12345678910111. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.2. 문자열 w를 두 &quot;균형잡힌 괄호 문자열&quot; u, v로 분리합니다. 단, u는 &quot;균형잡힌 괄호 문자열&quot;로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.3. 문자열 u가 &quot;올바른 괄호 문자열&quot; 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.4. 문자열 u가 &quot;올바른 괄호 문자열&quot;이 아니라면 아래 과정을 수행합니다. 4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 4-3. ')'를 다시 붙입니다. 4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 4-5. 생성된 문자열을 반환합니다. “균형잡힌 괄호 문자열” p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 “올바른 괄호 문자열”로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요. 매개변수 설명 p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다. 만약 p가 이미 “올바른 괄호 문자열”이라면 그대로 return 하면 됩니다. 입출력 예 p result &quot;(()())()&quot; &quot;(()())()&quot; &quot;)(&quot; &quot;()&quot; &quot;()))((()&quot; &quot;()(())()&quot; 입출력 예에 대한 설명입출력 예 #1\\이미 “올바른 괄호 문자열” 입니다. 입출력 예 #2 두 문자열 u, v로 분리합니다. u = &quot;)(&quot; v = &quot;&quot; u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 &quot;&quot;이 됩니다. 따라서 생성되는 문자열은 &quot;(&quot; + &quot;&quot; + &quot;)&quot; + &quot;&quot;이며, 최종적으로 &quot;()&quot;로 변환됩니다. 입출력 예 #3 두 문자열 u, v로 분리합니다. u = &quot;()&quot; v = &quot;))((()&quot; 문자열 u가 “올바른 괄호 문자열”이므로 그대로 두고, v에 대해 재귀적으로 수행합니다. 다시 두 문자열 u, v로 분리합니다. u = &quot;))((&quot; v = &quot;()&quot; u가 “올바른 괄호 문자열”이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 &quot;()&quot;이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 &quot;()&quot;이 됩니다. 따라서 생성되는 문자열은 &quot;(&quot; + &quot;()&quot; + &quot;)&quot; + &quot;()&quot;이며, 최종적으로 &quot;(())()&quot;를 반환합니다. 처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면 &quot;()&quot; + &quot;(())()&quot; = &quot;()(())()&quot;가 됩니다. 혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 (클릭) 풀이 python 1차 풀이123456789101112131415161718192021222324def solution(p): count_s = {'(':1,')':-1} def changeU(u): return ''.join([ ')' if s == '(' else '(' for s in u[1:-1]]) def splitUV(s): count = 0 isRight = True for i,c in enumerate(s): count += count_s[c] if count &lt; 0: isRight = False elif count == 0: return (isRight, count == 0,s[:i+1],s[i+1:]) def sol(s): if s == '': return '' r,b,u,v = splitUV(s) if r: return u + sol(v) else: return '(' + sol(v) + ')' + changeU(u) return sol(p) python 1차풀이 간략화123456789101112def solution(p): if p =='': return p r = True; count = 0 for i,v in enumerate(p): if v == '(': count += 1 else: count -= 1 if count &lt; 0 : r = False if count == 0: if r: return p[:i+1] + solution(p[i+1:]) else: return '('+solution(p[i+1:])+')'+ ''.join([')' if s == '(' else '(' for s in p[1:i]]) 설명 올바른 괄호 문제의 심화 버전. 실제 대기업 코딩 테스트에서도 흡사한 유형의 문제가 출제되었다. 풀이는 올바른 괄호 문제에서와 같이 count 변수를 이용해 올바른 괄호와 균형잡힌 괄호 여부를 판단했고, 문제의 요구사항대로 재귀함수를 이용해 어려움없이 결과값을 도출했다.","link":"/2021/06/30/a12417826dd1/"},{"title":"[프로그래머스] (LV2) 구명 보트","text":"구명보트JavaScript, Python 문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 풀이 javascript123456789101112131415161718192021function solution(people, limit) { let answer = 0; let s = 0, e = people.length-1; people = people.sort((a,b)=&gt;a-b) while(s &lt; e){ if(people[s] &gt; limit/2) return answer + e - s + 1 if(people[s] + people[e] &lt;= limit){ answer++; s++; e--; } else{ answer++; e--; } } return s === e ? answer + 1 : answer;} python12345678910111213def solution(people, limit): answer = 0 s = 0 e = len(people)-1 people.sort() while people[s] &lt;= limit/2 and s &lt; e: if people[s] + people[e] &gt; limit: e -= 1 else: e -= 1 s += 1 answer += 1 return answer + e - s + 1 설명 구명보트에는 최대 2명까지 탑승할 수 있다는 것이 가장 큰 힌트였다.그렇지 않으면 적은 무게의 사람들이 3명 이상 탈 수 있는데, 이 경우 문제가 매우 복잡해진다. 최대 2명이 탈 수 있다면, 몸무게가 큰 사람들과 작은 사람들을 함께 태우면 된다.따라서 배열을 무게순으로 정렬하고, 인덱스 시작과 끝에 header와 tail에 해당하는 변수를 설정한다. 그 뒤 현재 선택된 무거운 사람(변수 e)과 현재 선택된 가벼운 사람(변수 s)을 비교한다. 이 때, s와 e에 해당하는 두 사람의 무게를 비교하여 두 사람 무게의 합이 limit 무게를 안넘으면 둘을 모두 탑승시킨다. 그 뒤 s를 한칸 뒤로, e를 한칸 앞으로 땡긴다. 두 사람 무게의 합이 limit 무게를 넘으면 큰 사람만 탑승시킨다. 그 뒤 e를 한칸 앞으로 땡긴다. 만약 현재 탑승하지 않은 가장 가벼운 사람(s)의 무게가 limit/2 초과하면 남은 모든 사람을 각자 혼자 태운다. 이 과정을 반복시키면 함께 탈 수 있는 2명 보트의 개수를 최적화 할 수 있다.","link":"/2021/06/30/3d7fa5bc0e26/"},{"title":"[프로그래머스] (LV2) 기능개발","text":"기능개발JavaScript, Python 문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명입출력 예 #1\\첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.\\두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.\\세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 입출력 예 #2\\모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. ※ 공지 - 2020년 7월 14일 테스트케이스가 추가되었습니다. 풀이 javascript1234567891011121314151617181920function solution(progresses, speeds) { var answer = []; var c = 0; while(progresses.length){ if(progresses[0] &lt; 100) progresses = progresses.map((a,index)=&gt;a+speeds[index]) else{ var count = 0; while(progresses.length &amp;&amp; progresses[0] &gt;= 100){ count++; progresses.shift(); speeds.shift(); } answer.push(count); } } return answer;} python123456789101112131415161718def solution(progresses, speeds): answer = [] count = 0 while len(progresses): if progresses[0] &gt;= 100: progresses.pop(0) speeds.pop(0) count += 1 continue; elif count &gt; 0: answer.append(count) count = 0 for i, v in enumerate(progresses): progresses[i] += speeds[i] answer.append(count) return answer 설명 자료구조 큐를 활용한 문제다. python의 list와 javascript array에서 각각 일반적인 FIFO의 큐를 구현할 수 있다. python javascript 삽입 append(v) push(v) 삭제 pop(0) shift() 해당 문제에선 Queue의 삭제 기능만을 사용하여 쉽게 구현할 수 있었다.","link":"/2021/06/30/d276f8a57701/"},{"title":"[프로그래머스] (LV2) 다리를 지나는 트럭","text":"다리를 지나는 트럭JavaScript, Python 문제 설명트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.\\※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다. 예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 출처 ※ 공지 - 2020년 4월 06일 테스트케이스가 추가되었습니다. 풀이 javascript12345678910111213141516171819202122232425function solution(bridge_length, weight, truck_weights) { var answer = 0; var on_bridge_weight = 0; var on_bridge = []; while(truck_weights.length || on_bridge.length){ on_bridge.forEach((truck)=&gt;{ truck[0]--; }) if(on_bridge.length &amp;&amp; on_bridge[0][0] === 0){ on_bridge_weight -= on_bridge.shift()[1]; } if(on_bridge_weight + truck_weights[0] &lt;= weight){ var cur_truck = truck_weights.shift() on_bridge.push([bridge_length,cur_truck]); on_bridge_weight += cur_truck; } answer++; } return answer;} python1234567891011121314151617181920212223def solution(bridge_length, weight, truck_weights): b = [] answer = 0 while len(truck_weights) or len(b): answer += 1 returns = -1 for i in range(len(b)): if b[i][1] == 1: returns = i else: b[i][1] -= 1 for i in range(returns+1): b.pop(0) count = sum(map(lambda a:a[0],b)) if len(truck_weights) and count + truck_weights[0] &lt;= weight: t = truck_weights.pop(0) b.append([t,bridge_length]) count += t return answer python 간략화123456789101112131415def solution(bridge_length, weight, truck_weights): q = [0] * bridge_length q_sum = 0 answer = 0 while q: answer += 1 q_sum -= q.pop(0) if truck_weights: if q_sum + truck_weights[0] &lt;= weight: t_pop = truck_weights.pop(0) q.append(t_pop) q_sum += t_pop else: q.append(0) return answer 설명 큐와 스택의 심화 문제다.다리(bridge)의 상태를 큐로 표현하여 풀었다. 문제에서 주어진 트럭의 무게 배열을 중심으로 while문을 이용한 풀이는 O(N3)를 보였다.그러나 인터넷에는 bridge를 중심으로 풀이한 O(N2) 풀이가 있다. python의 pop(0)은 O(N)을 가지는 것을 감안해도 매우 효율적인 방법이다.당연히 풀이 코드 또한 훨씬 간결하다. (인터넷의 풀이에는 sum을 while문 안에서 사용하여 효율성이 조금 떨어졌는데,sum 변수를 활용하여 이를 개선시켰다.) 앞으로도 문제에서 주어진 변수에만 집중하는 버릇을 경계해야겠다.","link":"/2021/06/30/a2f68566ada1/"},{"title":"[프로그래머스] (LV2) 멀쩡한 사각형","text":"멀쩡한 사각형JavaScript, Python 문제 설명가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.\\가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요. 제한사항 W, H : 1억 이하의 자연수 입출력 예 W H result 8 12 80 입출력 예 설명입출력 예 #1\\가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다. 풀이 javascript1234567891011function solution(w, h) { if (w === h) return w * h - w; if (w === 1 || h === 1) return 0; let answer = 0; for(let i = 1; i &lt; w; i++) answer += Math.floor( h * i / w ) return answer * 2;} python 최소공배수 풀이123from math import gcddef solution(w,h): return w * h - (w+h) + gcd(w, h) 설명 알고리즘 보단 창의력을 요하는 수학 문제에 가깝다.문제의 인덱스마다 감소하는 진한 사각형의 개수를 구하는 식으로 풀었다. 그런데 최대공약수를 이용한 풀이도 존재했다. w와 h 입장에서 선이 지나가서 못쓸만한 사각형들을 모두 빼고,중복으로 제거된 칸의 개수(최대공약수) 만큼 더하면 된다.","link":"/2021/06/30/8819eaf14ced/"},{"title":"[프로그래머스] (LV2) 메뉴 리뉴얼","text":"메뉴 리뉴얼JavaScript, Python 문제 설명레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.\\기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 “스카피”는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.\\단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다. 예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,\\(각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.) 손님 번호 주문한 단품메뉴 조합 1번 손님 A, B, C, F, G 2번 손님 A, C 3번 손님 C, D, E 4번 손님 A, C, D, E 5번 손님 B, C, F, G 6번 손님 A, C, D, E, H 가장 많이 함께 주문된 단품메뉴 조합에 따라 “스카피”가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다. 코스 종류 메뉴 구성 설명 요리 2개 코스 A, C 1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다. 요리 3개 코스 C, D, E 3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다. 요리 4개 코스 B, C, F, G 1번, 5번 손님으로부터 총 2번 주문됐습니다. 요리 4개 코스 A, C, D, E 4번, 6번 손님으로부터 총 2번 주문됐습니다. [문제]각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, “스카피”가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, “스카피”가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] orders 배열의 크기는 2 이상 20 이하입니다. orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다. 각 문자열은 알파벳 대문자로만 이루어져 있습니다. 각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다. course 배열의 크기는 1 이상 10 이하입니다. course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다. course 배열에는 같은 값이 중복해서 들어있지 않습니다. 정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요. 배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다. 만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다. orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다. [입출력 예] orders course result [&quot;ABCFG&quot;, &quot;AC&quot;, &quot;CDE&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;ACDEH&quot;] [2,3,4] [&quot;AC&quot;, &quot;ACDE&quot;, &quot;BCFG&quot;, &quot;CDE&quot;] [&quot;ABCDE&quot;, &quot;AB&quot;, &quot;CD&quot;, &quot;ADE&quot;, &quot;XYZ&quot;, &quot;XYZ&quot;, &quot;ACD&quot;] [2,3,5] [&quot;ACD&quot;, &quot;AD&quot;, &quot;ADE&quot;, &quot;CD&quot;, &quot;XYZ&quot;] [&quot;XYZ&quot;, &quot;XWY&quot;, &quot;WXA&quot;] [2,3,4] [&quot;WX&quot;, &quot;XY&quot;] 입출력 예에 대한 설명 입출력 예 #1\\문제의 예시와 같습니다. 입출력 예 #2\\AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.\\요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다. 입출력 예 #3\\WX가 두 번, XY가 두 번 주문됐습니다.\\3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.\\또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다. 풀이 javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function solution(orders, course) { var answer = []; var list = []; var counter = {}; function combination(source, target, n, r, count) { if(r === 0) list.push(target.sort().join('')); else if(n === 0 || n &lt; r) return; else { target.push(source[count]); combination(source, Object.assign([], target), n - 1, r - 1, count + 1); target.pop(); combination(source, Object.assign([], target), n - 1, r, count + 1); } } course.forEach((c)=&gt;{ orders.forEach((o)=&gt;{ var order = o.split('') combination(order, [], o.length, c, 0) }) counter[c] = 2; }) var freqTable = list.reduce((acc, menu) =&gt; { acc[menu] = (acc[menu] || 0) + 1 return acc },{}); var filteredData = {}; Object.entries(freqTable).forEach( ([key, value]) =&gt; { if(value &gt; counter[key.length]){ counter[key.length] = value; filteredData[key.length] = [key]; } else if(value === counter[key.length]){ if(!filteredData[key.length]) filteredData[key.length] = [key]; else filteredData[key.length].push(key); } } ) return Object.values(filteredData).reduce((a,b)=&gt;a.concat(b),[]).sort();} python12345678910111213141516171819202122from itertools import combinationsdef solution(orders, course): answer = [] for i in course: d = {} for o in orders: if len(o) &lt; i: continue for c in list(combinations(list(o), i)): k = ''.join(sorted(c)) if k in d: d[k] += 1; else: d[k] = 1 if len(d.values()): m = max(d.values()) if m &lt; 2 : continue; for maxValues in [mk for mk in d if d[mk] == m]: answer.append(maxValues) return sorted(answer) 설명 javascript를 너무나 힘들게 만드는 순열 조합 문제다. javascript에는 타 언어와는 달리 순열 조합 함수가 내장되어 있지 않기 때문에 이를 직접 구현해야 한다. javascript에서 재귀함수로 구현한 n 개중 r 개를 뽑는 조합 함수12345678910111213const list = []function combination(source, target, n, r, count) { if(r === 0) list.push(target.sort().join('')); else if(n === 0 || n &lt; r) return; else { target.push(source[count]); combination(source, Object.assign([], target), n - 1, r - 1, count + 1); target.pop(); combination(source, Object.assign([], target), n - 1, r, count + 1); } } python 풀이 설명그러나 파이썬은 이야기가 다르다. python 에서는 itertools 패키지에 순열, 조합 등의 기능들이 들어있어 이를 쉽게 사용할 수 있다.그러다 보니 두 언어의 코드량 차이도 엄청나다. 사실 풀이는 크게 다르지 않다. 주어진 orders의 조합을 구해서 dictionary에 쌓은 뒤,course 길이마다 요구하는 최대값들을 추려 결과 배열에 추가하는 코드다. 실제로 카카오 2021 채용 코딩테스트에서 풀었던 문제인데, javascript만 알던 나는난생 처음 짜보는 combination 함수에 많은 시간을 소진했다. 이런 차별점 때문에 뒤늦게 python 공부를 시작하긴 했지만 다소 아쉬움이 남는 부분이다.","link":"/2021/06/30/c3c4c8687ef5/"},{"title":"[프로그래머스] (LV2) 문자열 압축","text":"문자열 압축JavaScript, Python 문제 설명데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.\\간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요. 제한사항 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다. 입출력 예 s result &quot;aabbaccc&quot; 7 &quot;ababcdcdababcdcd&quot; 9 &quot;abcabcdede&quot; 8 &quot;abcabcabcabcdededededede&quot; 14 &quot;xababcdcdababcdcd&quot; 17 입출력 예에 대한 설명입출력 예 #1 문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #2 문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #3 문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다. 입출력 예 #4 문자열을 2개 단위로 자르면 “abcabcabcabc6de” 가 됩니다.\\문자열을 3개 단위로 자르면 “4abcdededededede” 가 됩니다.\\문자열을 4개 단위로 자르면 “abcabcabcabc3dede” 가 됩니다.\\문자열을 6개 단위로 자를 경우 “2abcabc2dedede”가 되며, 이때의 길이가 14로 가장 짧습니다. 입출력 예 #5 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.\\따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로 자르는 것은 불가능 합니다.\\이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다. 혼자 풀기가 막막하다면, 풀이 강의를 들어보세요 (클릭) 풀이 javascript123456789101112131415161718192021222324252627282930function solution(s) { let answer = s.length; let word = '' let curWord = '' for(let i = 1; i&lt;= s.length/2; i++){ word = '' curWord = '' const splits = s.split('') let wordCount = 1; while(splits.length &gt; 0){ if(word.length &gt;= answer) break; let split_word = splits.splice(0,i).join('') if(split_word === curWord) wordCount++; else{ if(curWord) word += (wordCount &gt; 1? wordCount : '') + curWord wordCount = 1; curWord = split_word } } word += (wordCount &gt; 1? wordCount : '') + curWord if(word.length &lt; answer) answer = word.length } return answer} python123456789101112131415161718192021222324def solution(s): answer = len(s) for i in range(1,int(len(s)/2)+1): c = '' word = '' str_ = s b = 0 while str_: if len(word) &gt; answer: break; if c == str_[0:i]: b+=1 else: word += ( str(b) + c if b &gt; 1 else c) c = str_[0:i] b = 1 str_ = str_[i:] if len(str_) &lt; i: word += ((str(b) if b &gt;1 else '') + c + str_) if answer &gt; len(word): answer = len(word) return answer 설명 brute force를 이용한 무지성 무차별 대입 문제다. 1개부터 최소 s의길이/2 까지는 반복문을 돌려야 하며,그 때마다 문자열을 탐색하고, 반복적으로 slice 해야한다. 보통의 경우 slice 함수는 O(N)을 따르므로이 풀이의 복잡도는 O(N3)이 된다.","link":"/2021/06/30/159231ce38e1/"},{"title":"[프로그래머스] (LV2) 삼각 달팽이","text":"삼각 달팽이JavaScript, Python 문제 설명정수 n이 매개변수로 주어집니다. 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 1,000 이하입니다. 입출력 예 n result 4 [1,2,9,3,10,8,4,5,6,7] 5 [1,2,12,3,13,11,4,14,15,10,5,6,7,8,9] 6 [1,2,15,3,16,14,4,17,21,13,5,18,19,20,12,6,7,8,9,10,11] 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 문제 예시와 같습니다. 풀이 javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function solution(n) { if (n === 1) return [1]; var state = 0; // 아래 왼쪽 방향 시작 var count = n; var value = 1; var currentFloor = 1; var currentIndex = 0; var answer = Array.from(Array(n*(n+1)/2),()=&gt;0); while(count &gt; 0){ for(let i = 0; i &lt; count; i++){ answer[currentIndex] = value++; if(state === 0){ // 아래 왼쪽 방향 if(i !== count-1) currentIndex += currentFloor++; else{ currentIndex++; state = 1; } } else if (state === 1){ // 오른쪽 방향 if(i !== count-1) currentIndex++; else{ currentIndex -= currentFloor--; state = 2; } } else { // 왼쪽 위 방향 if(i !== count-1) currentIndex -= currentFloor--; else{ currentIndex += currentFloor++; state = 0; } } } count--; } return answer;} python1234567891011121314151617def solution(n): floor = 1; index = 0; flags = 1; size = int(n * (n+1) / 2) answer = [0] * size for i in range(size): answer[index] = i+1 index_count = {'1':floor,'0':1,'-1':-floor} next_index = index + index_count[str(flags)] if not (0 &lt;= next_index &lt; size) or answer[next_index] != 0: flags = (flags-1 if flags != -1 else 1) index = index + index_count[str(flags)] floor += flags return answer 설명 처음 접했을 때는, 반복되는 패턴의 삼각형을 기준으로 분할정복을 사용하려 했다.하지만 각기 처리된 삼각형들의 매끄러운 병합 과정이 떠오르지 않았다. 그래서 n(n+1)/2 개의 숫자를 체우는 반복문을 만들어 한 번에 해결했는데,매 번 현재의 층(floor)와 방향을 초기화하며 배열에 값을 할당한다. javascript풀이에서는 count 변수를 이용해 첫 직선이 n칸을 할당하고,그 다음 직선부터 1칸씩 감소한 4, 3, 2, 1칸을 할당하는 규칙성을 이용했다. 상태 개념을 이용할 것이라 count 활용은 굳이 필요 없는 방법이지만최대한 분할정복 방법으로 풀어보려던 시도라고 보면 된다. 이와 다르게 Python 풀이는 깔끔하게 현재의 상태(층수, 방향)만 이용한다.두 방법 모두 O(N2)의 시간복잡도를 나타낸다. 그 와중에 python의 a &lt; X &lt; b 연산 허용은 정말 적응이 안된다.","link":"/2021/06/30/6cc69e8b0ad8/"},{"title":"[프로그래머스] (LV2) 소수 찾기","text":"소수 찾기JavaScript, Python 문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers는 길이 1 이상 7 이하인 문자열입니다. numbers는 0~9까지 숫자만으로 이루어져 있습니다. “013”은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다. 입출력 예 numbers return “17” 3 “011” 2 입출력 예 설명예제 #1\\[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다. 예제 #2\\[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다. 11과 011은 같은 숫자로 취급합니다. 출처 풀이 javascript123456789101112131415161718192021222324252627282930function solution(numbers) { const isPrimary = (n) =&gt; n&gt;2 ? ![...Array(Math.ceil(Math.sqrt(n))+1).keys()].slice(2).map(i =&gt; !(n%i)).includes(true) : n===2 const permutator = (inputArr) =&gt; { let result = []; const permute = (arr, m = []) =&gt; { if(m.length) result.push(m) if (arr.length === 0) { result.push(m) } else { for (let i = 0; i &lt; arr.length; i++) { let curr = arr.slice(); let next = curr.splice(i, 1); permute(curr.slice(), m.concat(next)) } } } permute(inputArr) const resultMap = result.map((arr)=&gt;arr.join('')*1); return [...new Set(resultMap)] } return permutator(numbers.split('')).filter(isPrimary).length } python12345678910111213141516from itertools import permutationsdef solution(numbers): sets = set() def isPrime(n): if n == 0 or n == 1: return False if n == 2: return True for k in range(2,int(n ** (1/2))+2): if n % k == 0: return False return True for i in range(1,len(numbers)+1): for s in list(set([int(''.join(p)) for p in permutations(list(numbers),i)] )): sets.add(s) return len(list(filter(isPrime, list(sets)))) 설명 순열에 해당하는 bfs 함수 구현이 특징인 문제다.내장함수에서 순열 기능을 제공하지 않는 언어에서는 난이도가 더 높아진다. javascript로는 이를 재귀함수로 구현했다.그러나 사실상 for문의 중첩(bfs)으로 이뤄져 있어서, 매우 무겁게 작동한다. 소수를 구하는 isPrime 함수와 순열 함수 구현이 끝나면, 뒤는 간단하다.순열 목록에서 중복값을 제거하고 모두 isPrime 에 대입해서 결과를 얻는다.","link":"/2021/06/30/dcc75b1cb9ed/"},{"title":"[프로그래머스] (LV2) 수식 최대화","text":"[카카오 인턴] 수식 최대화JavaScript 문제 설명IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.\\이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.\\해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.\\단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.\\만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다. 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다. &quot;100-200*300-500+20&quot; 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.\\대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.\\수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.\\반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다. 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요. [제한사항] expression은 길이가 3 이상 100 이하인 문자열입니다. expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다. 즉, &quot;402+-561*&quot;처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다. expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다. 즉, &quot;100-2145*458+12&quot;처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다. &quot;-56+100&quot;처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다. expression은 적어도 1개 이상의 연산자를 포함하고 있습니다. 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다. 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다. 입출력 예 expression result &quot;100-200*300-500+20&quot; 60420 &quot;50*6-3*2&quot; 300 입출력 예에 대한 설명입출력 예 #1\\* &gt; + &gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\\연산 순서는 아래와 같습니다.\\100-200*300-500+20\\= 100-(200*300)-500+20\\= 100-60000-(500+20)\\= (100-60000)-520\\= (-59900-520)\\= -60420\\따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다. 입출력 예 #2\\- &gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.\\연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)\\50*6-3*2\\= 50*(6-3)*2\\= (50*3)*2\\= 150*2\\= 300\\따라서, 우승 시 받을 수 있는 상금은 300 입니다. 풀이 javascript123456789101112131415161718192021222324252627282930function solution(expression) { let answer = 0 const exp_ = expression.split(/([\\+\\-\\*])/g) const splts_ = [...new Set(expression.split(/\\d*/).filter((v)=&gt;v))] const calc = (splts,splt,arr)=&gt; { for(let i =0; i&lt; arr.length;i++){ if(arr[i] === splt){ arr[i-1] = eval(arr[i-1]+arr[i]+arr[i+1]) arr.splice(i,2) i--; } } if(splts.length) splts.forEach((s,i)=&gt;{ const newArr = splts.slice(); newArr.splice(i,1) calc(newArr,s,arr.slice()) }) else if(answer &lt; Math.abs(arr[0])) answer = Math.abs(arr[0]) } splts_.forEach((s_, i_)=&gt;{ const newArr_ = splts_.slice() newArr_.splice(i_,1) calc(newArr_,s_,exp_.slice()) }) return answer} python12345678910111213141516import redef solution(expression): answer = 0 list_s = re.split('([-*+])', expression) orders = ['*+-','*-+','+*-','+-*','-+*','-*+'] for o in orders: cur_l = list_s[:] for v in list(o): while v in cur_l: i = cur_l.index(v) result = eval(str(cur_l[i-1]) + v + str(cur_l[i+1])) cur_l[i+1] = result del cur_l[i-1:i+1] if answer &lt; abs(cur_l[0]) : answer = abs(cur_l[0]) return answer 설명 bfs를 연습하기 좋은 기초 문제다. 우선 주어진 문자열은 정규식의 간단한 활용으로 쉽게 배열화 할 수 있다.이를 이용해 수식들의 순서를 바꿔가며 계산을 진행하면 되는 문제다. 주어진 수식이 * + - 세개 밖에 없었기 때문에, 이들의 6개의 순서쌍['*+-','*-+','+*-','+-*','-+*','-*+']을 이용하면 된다. 이들 6개의 문자열과 그 문자열 속 각 수식을 나타내는 이중 포문은단지 18번(6x3)의 계산만 할 뿐이다. 따라서 이들은 O(1)과 같다. 그 아래에는 본격적으로 주어진 리스트를 반복하며 돌아가는데,인덱싱 작업이 포함되어 있으므로 사실상 O(N2)의 속도를 보인다.","link":"/2021/06/30/8db1d8a11adc/"},{"title":"[프로그래머스] (LV2) 순위 검색","text":"순위 검색JavaScript 문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.] 카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다. 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다. 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다. 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다. 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다. 인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.\\예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.\\코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가? 물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다. 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가? backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가? 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가? 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가? 즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다. 1[조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가? [문제]지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,\\각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요. [제한사항] info 배열의 크기는 1 이상 50,000 이하입니다. info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 “개발언어 직군 경력 소울푸드 점수” 형식입니다. 개발언어는 cpp, java, python 중 하나입니다. 직군은 backend, frontend 중 하나입니다. 경력은 junior, senior 중 하나입니다. 소울푸드는 chicken, pizza 중 하나입니다. 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. query 배열의 크기는 1 이상 100,000 이하입니다. query의 각 문자열은 “[조건] X” 형식입니다. [조건]은 “개발언어 and 직군 and 경력 and 소울푸드” 형식의 문자열입니다. 언어는 cpp, java, python, - 중 하나입니다. 직군은 backend, frontend, - 중 하나입니다. 경력은 junior, senior, - 중 하나입니다. 소울푸드는 chicken, pizza, - 중 하나입니다. ‘-‘ 표시는 해당 조건을 고려하지 않겠다는 의미입니다. X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다. 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다. 예를 들면, “cpp and - and senior and pizza 500”은 “cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?”를 의미합니다. [입출력 예] info query result [&quot;java backend junior pizza 150&quot;,&quot;python frontend senior chicken 210&quot;,&quot;python frontend senior chicken 150&quot;,&quot;cpp backend senior pizza 260&quot;,&quot;java backend junior chicken 80&quot;,&quot;python backend senior chicken 50&quot;] [&quot;java and backend and junior and pizza 100&quot;,&quot;python and frontend and senior and chicken 200&quot;,&quot;cpp and - and senior and pizza 250&quot;,&quot;- and backend and senior and - 150&quot;,&quot;- and - and - and chicken 100&quot;,&quot;- and - and - and - 150&quot;] [1,1,1,1,2,4] 입출력 예에 대한 설명지원자 정보를 표로 나타내면 다음과 같습니다. 언어 직군 경력 소울 푸드 점수 java backend junior pizza 150 python frontend senior chicken 210 python frontend senior chicken 150 cpp backend senior pizza 260 java backend junior chicken 80 python backend senior chicken 50 &quot;java and backend and junior and pizza 100&quot; : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다. &quot;python and frontend and senior and chicken 200&quot; : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다. &quot;cpp and - and senior and pizza 250&quot; : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다. &quot;- and backend and senior and - 150&quot; : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다. &quot;- and - and - and chicken 100&quot; : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다. &quot;- and - and - and - 150&quot; : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다. 풀이 javascript 효율성1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function solution(info, query) { var dividedObj = {}; var valueSet = []; var infoSet = info.map((i)=&gt;i.split(' ')).sort((a,b)=&gt;{ return b[4] *1 - a[4] *1 }); function getComb(makedList, n, targetList){ if(n === targetList.length) return makedList.map((m)=&gt;m.join('')); var curList = [...makedList]; makedList.forEach((l)=&gt;{ var cl = [...l]; cl.push(targetList[n]); curList.push(cl) }) return getComb(curList,n+1,targetList); } infoSet.forEach((info_)=&gt;{ var info_x = info_.pop(); // var info_join = info_.join('') var gc = getComb([[]],0,info_); gc.forEach((gc_)=&gt;{ if(!dividedObj[gc_]) dividedObj[gc_] = [info_x*1]; else dividedObj[gc_].push(info_x*1); }) }) function binarySearch(ls, target){ var start = 0; var end = ls.length -1; var mid; while(start &lt;= end) { mid = Math.floor((start + end) / 2); if(ls[mid] &gt;= target) start = mid + 1; else end = mid - 1; } return end; } var answer = query.map((q)=&gt;{ var conditions = q.split(' ').filter((w)=&gt;w!=='and' &amp; w!=='-'); var x = conditions.pop()*1; var filteredList = dividedObj[conditions.join('')] if(!filteredList) return 0 return binarySearch(filteredList,x) +1; }) return answer; } python (효율성 실패)1234567891011def solution(info, query): answer = [] def query_filter(info_, qs_): for q_ in qs_[:-1]: if q_ not in info_: return False return (int(info_.split(' ')[-1]) &gt;= int(qs_[-1]) ) for q in query: qs = [q_ for q_ in q.split(' ') if q_ != 'and' and q_ != '-'] answer.append(len(list(filter(lambda x: query_filter(x,qs), info)))) return answer python 효율성123456789101112131415161718192021222324252627282930313233from itertools import combinationsdef solution(info, query): answer = [] info_dict = {'all':[]} info = list(map(lambda x: [i for i in x.split(' ')] ,info)) info.sort(key = lambda x:-1*int(x[-1])) def binary_search(a, x): s = 0; e = len(a) -1; m = (s+e) // 2 while s &lt;= e: m = (s+e) // 2 if a[m] &gt;= x: s = m + 1 else: e = m - 1 return e+1 for info_ in info: i_value = info_.pop() for i in range(1,5): for s in list(combinations(info_, i)): key = ''.join(sorted(list(s))) if key in info_dict: info_dict[key].append(int(i_value)) else: info_dict[key] = [int(i_value)] info_dict['all'].append(int(i_value)) for q in query: qs = [s for s in q.split(' ') if s != 'and' and s != '-'] qv = int(qs.pop()) key = ''.join(sorted(qs)) if len(qs) else 'all' answer.append(binary_search(info_dict[key], qv) if key in info_dict else 0) return answer 설명 info 정보들과 query들을 비교해야하는 문제다. python 효율성 실패 코드는 단순 무식하게 이 둘을 비교하는 코드다.info는 최대 50,000의 값을, query는 최대 100,000의 값을 가지므로당연하게도 해당 코드는 효율성 검증을 실패한다. 다른 풀이(javascript, python)는 효율성 검증이 된 코드들인데,모두 dictionary를 이용해 info를 구조화 했다. (효율성 필수 사항) 주목할 점은 정렬의 활용이다. 구조화 전에 info를 점수를 역순으로 정렬했는데,이러면 dictionary에 담길 점수 list도 점수 크기의 역순으로 담긴다. key값은 단순 배열의 합을 이용했다.이 때 비트 연산을 활용한 풀이를 봤는데, 정말 괜찮은 방법이라 생각된다.시간이 나면 그 방법으로 다시 풀어봐야겠다. 어쨌든 info의 각 요소들을 결합한 키값은 이렇게 된다.1dict = { 'cppbackendjuniorpizza':[150,120,100,90], ... } 위에서 'cppbackendjuniorpizza':[150] 값에 해당하는 데이터는cpp, backend, junior, pizza, 150점을 가진 데이터다. 그런데 이 데이터는 모든 키값을 붙인 cppbackendjuniorpizza 뿐만 아니라,'cpp,junior', 'backend,pizza' 등에도 포함되어야 하는 값이다. 따라서 각 요소들의 조합을 구하는 코드를 활용했다.이 때 조합의 결과값은 순서가 보장되지 않으므로 별도로 정렬해야 했다.(이 과정에서 효율이 매우 떨어지는 것 같다. 비트연산 짱짱맨..) 모든 조합을 dictionary에 담고난 뒤에는 query값을 단순 검색하면 된다.이 때, query에 해당 key값으로 불러온 점수 리스트는 역순 정렬 되어있다. 따라서 같거나 작은 값을 찾았을때 index 값으로 결과를 얻을 수 있다.즉, [150,120,100,50,20]의 리스트에서 100 이상 값의 개수는100의 인덱스(2) + 1 로 간단히 구할 수 있다. 따라서 검색만 가장 효율적으로 하면 되고, 이 때 이진검색 방법을 활용했다. 여기서 보통과는 다르게 end 값을 return 하는데(보통은 m을 리턴),같거나 ‘작은’값을 찾아야 하기 때문이다.","link":"/2021/06/30/8ab5e1fa479e/"},{"title":"[프로그래머스] (LV2) 스킬 트리","text":"스킬 트리Javascript, Python 문제 설명선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다. 예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다. 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다. 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요. 제한 조건 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다. 예를 들어, C → B → D 라면 “CBD”로 표기합니다 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다. skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다. 입출력 예 skill skill_trees return &quot;CBD&quot; [&quot;BACDE&quot;, &quot;CBADF&quot;, &quot;AECB&quot;, &quot;BDA&quot;] 2 입출력 예 설명 “BACDE”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. “CBADF”: 가능한 스킬트리입니다. “AECB”: 가능한 스킬트리입니다. “BDA”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다. 스킬 트리: 유저가 스킬을 배울 순서 ↩ 풀이 javascript1234567891011121314151617181920212223function solution(skill, skill_trees) { var answer = 0; var skills = skill.split('') answer = skill_trees.filter((s)=&gt;{ var count = 0; var current_s = s.split('') for(let s_ of current_s){ var i = skills.indexOf(s_); if(i &gt; -1){ if(count === i) count++; else return false; } } return true; }).length return answer;} python12def solution(skill, skill_trees): return len(list(filter(lambda st:skill.find(''.join([s for s in list(st) if s in skill]))==0, skill_trees))) 설명 python 풀이 과정 순서는 다음과 같다. &gt; skill_tree 문자열에서 skill에 포함하는 문자만 찾아 추려낸다. 추려낸 문자들을 이어붙인다. 이어붙인 문자열을 skill이 포함하는지 검색한다. 이때 포함된 index가 0이면 옳은 스킬트리다. 위 과정을 filtering하여 옳은 스킬트리의 갯수만 return한다. 구체적으로 예를 들자면 skill_tree : 'ACBEFG'skill : 'CBD' 일때, ACBEDF에서 CBD에 속한 문자만 추려내면 'CB'가 된다.이걸 다시 skill에서 find 하면, 첫번째 인덱스인 0을 반환한다. 즉, 'ACBEDF' 는 옳은 스킬트리인 것이다.","link":"/2021/06/30/3f58d87774a8/"},{"title":"[프로그래머스] (LV2) 올바른 괄호","text":"올바른 괄호 Python 문제 설명괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어 “()()” 또는 “(())()” 는 올바른 괄호입니다. “)()(“ 또는 “(()(“ 는 올바르지 않은 괄호입니다. ‘(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요. 제한사항 문자열 s의 길이 : 100,000 이하의 자연수 문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다. 입출력 예 s answer “()()” true “(())()” true “)()(“ false “(()(“ false 입출력 예 설명입출력 예 #1,2,3,4\\문제의 예시와 같습니다. 풀이 python12345678def solution(s): count = 0 char_value = {'(':1,')':-1} for c in s: count += char_value[c] if count &lt; 0: return False return count == 0 설명 대기업을 비롯한 여러 코딩테스트에서 마주쳤던 괄호 유형의 기본 문제다. 매우 기본적인 문제라 스택을 굳이 사용할 필요가 없었다. 핵심은 여는괄호( ‘(‘ ) 에서는 +값을, 닫히는 괄호( ‘)’ )에서는 -값을 더해서 한 번이라도 count 값이 0보다 낮아지면 올바른 괄호가 아니라는 것이다.","link":"/2021/06/30/d0d869aeccaf/"},{"title":"[프로그래머스] (LV2) 가장 큰 수","text":"가장 큰 수JavaScript, Python 문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 입출력 예 numbers return [6, 10, 2] “6210” [3, 30, 34, 5, 9] “9534330” 풀이 javascript12345678function solution(numbers) { const sortFunc = (a,b) =&gt; { return ((b+'') + (a+''))*1 - ((a+'')+(b+''))*1 } var answer = numbers.sort(sortFunc).join(''); return answer*1 ? answer : &quot;0&quot;} python12345678910from functools import cmp_to_keydef solution(numbers): def sort_func(a,b): if int(a+b) &gt; int(b+a) : return -1 else : return 1 return str(int(''.join(sorted([str(i) for i in numbers],key=cmp_to_key(sort_func))))) 설명 문자열 그대로 합친숫자(ex: 6+10 = 610)를 기준으로 정렬하여 풀었다. 자바스크립트에서는 정렬 기준 비교 함수를 직접 지정할 수 있지만, 파이썬에서는 기본함수에서 이를 제공하지 않는다. 따라서 functools 패키지의 cpm_to_key함수를 써야한다.","link":"/2021/06/30/0b0ef57c568e/"},{"title":"[프로그래머스] (LV2) 가장 큰 정사각형 찾기","text":"가장 큰 정사각형 찾기JavaScript, Python 문제 설명1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.) 예를 들어 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 있다면 가장 큰 정사각형은 1 2 3 4 0 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다. 제한사항 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다. 입출력 예 board answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]] 9 [[0,0,1,1],[1,1,1,1]] 4 입출력 예 설명입출력 예 #1\\위의 예시와 같습니다. 입출력 예 #2\\| 0 | 0 | 1 | 1 |\\| 1 | 1 | 1 | 1 |\\로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다. 풀이 javascript123456789101112131415161718function solution(board) { var answer = 0; answer = board.filter((b)=&gt;b.filter((v)=&gt;v===1).length).length &gt; 0 ? 1 : 0 for (let y = 1; y &lt; board.length; y++) { for (let x = 1; x &lt; board[0].length; x++) { if (board[y][x] === 1) { board[y][x] = (Math.min(board[y][x - 1], board[y - 1][x - 1], board[y - 1][x])) + 1; if (board[y][x] &gt; answer) { answer = board[y][x]; } } } } return answer * answer;} python123456789101112def solution(board): answer = 0 if sum([sum(b) for b in board]) == 0 else 1 for i in range(1,len(board)): for j in range(1,len(board[i])): if board[i][j]: board[i][j] = min(board[i][j-1],board[i-1][j-1],board[i-1][j]) + 1 if board[i][j] &gt; answer: answer = board[i][j] return answer ** 2 설명 배열의 정사각형 부분을 간략히 표현하기 위한 방법을 고민했다. 가장 단순하게 각 점마다 사각형을 확인해보는 함수는 O(N4)까지 효율성이 떨어졌기 때문에, 되도록 O(N2)을 이용하는 방법을 고민했다. 각 열 혹은 행의 합을 이용해서 풀이할 수 있는 방법이 있을까 생각해봤다(스도쿠). 그러나 각 라인 값의 합 만으로는 정사각형을 특정할 수 없었고 결국 배열을 다시 확인하는 작업이 수반되어야 했다. 그러던 중 탐색해 나아갈때마다 값을 누적하는 방식의 풀이를 접하게 되었고, 현재 탐색 점 기준 왼쪽 위로 2x2 사각형의 값을 누적하는 방식의 풀이법을 알게 되었다. 이 때, 3영역의 값 중 최소값을 불러오는데, 이는 사각형을 온전히 이루고 있는지 판단하기 위한 방법이다. 시작 1 1 1 1 1 1 1 1 1 1단계 (1,1)(1,1) -&gt; [ 상단 : 1 , 좌측 : 1 , 좌측 상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 1 1 1 1 2단계 (1,2)(1,2) -&gt; [ 상단 : 1 ,좌측 : 1 ,좌측상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 2 1 1 1 3단계 (2,1)(2,1) -&gt; [ 상단 : 1 ,좌측 : 1 ,좌측상단 : 1 ] 이므로 -&gt; 2 1 1 1 1 2 2 1 2 1 4단계 (2,2)(2,2) -&gt; [ 상단 : 2 ,좌측 : 2 ,좌측상단 : 2 ] 이므로 -&gt; 3 1 1 1 1 2 2 1 2 3 이 과정에서 탐색 값 중 0의 값이 포함되어 있다면 현재 값은 오직 1을 갖는다. 따라서 해당 방법으로 (i,j)가 온전한 사각형인지, 만약 그렇다면 얼만큼의 크기를 갖는지 알 수 있다.","link":"/2021/06/30/7a56708568fb/"},{"title":"[프로그래머스] (LV2) 거리두기 확인하기","text":"거리두기 확인하기Python3 문제 설명개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다. 코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼\\아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다. 대기실은 5개이며, 각 대기실은 5x5 크기입니다. 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요. 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다. 예를 들어, 위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다. 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다. 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다. 응시자가 앉아있는 자리(P)를 의미합니다. 빈 테이블(O)을 의미합니다. 파티션(X)을 의미합니다. 5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 제한사항 places의 행 길이(대기실 개수) = 5 places의 각 행은 하나의 대기실 구조를 나타냅니다. places의 열 길이(대기실 세로 길이) = 5 places의 원소는 P,O,X로 이루어진 문자열입니다. places 원소의 길이(대기실 가로 길이) = 5 P는 응시자가 앉아있는 자리를 의미합니다. O는 빈 테이블을 의미합니다. X는 파티션을 의미합니다. 입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다. return 값 형식 1차원 정수 배열에 5개의 원소를 담아서 return 합니다. places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다. 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다. 입출력 예 places result [[&quot;POOOP&quot;, &quot;OXXOX&quot;, &quot;OPXPX&quot;, &quot;OOXOX&quot;, &quot;POXXP&quot;], [&quot;POOPX&quot;, &quot;OXPXP&quot;, &quot;PXXXO&quot;, &quot;OXXXO&quot;, &quot;OOOPP&quot;], [&quot;PXOPX&quot;, &quot;OXOXP&quot;, &quot;OXPOX&quot;, &quot;OXXOP&quot;, &quot;PXPOX&quot;], [&quot;OOOXX&quot;, &quot;XOOOX&quot;, &quot;OOOXX&quot;, &quot;OXOOX&quot;, &quot;OOOOO&quot;], [&quot;PXPXP&quot;, &quot;XPXPX&quot;, &quot;PXPXP&quot;, &quot;XPXPX&quot;, &quot;PXPXP&quot;]] [1, 0, 1, 1, 1] 입출력 예 설명입출력 예 #1 첫 번째 대기실 No. 0 1 2 3 4 0 P O O O P 1 O X X O X 2 O P X P X 3 O O X O X 4 P O X X P 모든 응시자가 거리두기를 지키고 있습니다. 두 번째 대기실 No. 0 1 2 3 4 0 P O O P X 1 O X P X P 2 P X X X O 3 O X X X O 4 O O O P P (0, 0) 자리의 응시자와 (2, 0) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (1, 2) 자리의 응시자와 (0, 3) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (4, 3) 자리의 응시자와 (4, 4) 자리의 응시자가 거리두기를 지키고 있지 않습니다. 세 번째 대기실 No. 0 1 2 3 4 0 P X O P X 1 O X O X P 2 O X P O X 3 O X X O P 4 P X P O X 모든 응시자가 거리두기를 지키고 있습니다. 네 번째 대기실 No. 0 1 2 3 4 0 O O O X X 1 X O O O X 2 O O O X X 3 O X O O X 4 O O O O O 대기실에 응시자가 없으므로 거리두기를 지키고 있습니다. 다섯 번째 대기실 No. 0 1 2 3 4 0 P X P X P 1 X P X P X 2 P X P X P 3 X P X P X 4 P X P X P 모든 응시자가 거리두기를 지키고 있습니다. 두 번째 대기실을 제외한 모든 대기실에서 거리두기가 지켜지고 있으므로, 배열 [1, 0, 1, 1, 1]을 return 합니다. 제한시간 안내 정확성 테스트 : 10초 두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 입니다. ↩ 풀이 python1234567891011121314151617181920212223242526272829303132333435363738def solution(places): answer = [] for place in places: # add person per = [] for row,t in enumerate(place): for col,p in enumerate(t): if p == 'P': per.append([row,col]) def calcBetweenLength(p1,p2): return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) def calcIsRight(arr_p): if len(arr_p) &lt;= 1 : return True new_arr = arr_p[:] cur = new_arr.pop(0) for p in new_arr: c = calcBetweenLength(cur,p) if c == 1: return False elif c == 2: min_r = min(cur[0],p[0]) min_c = min(cur[1],p[1]) if cur[0] == p[0] and place[min_r][min_c + 1] == 'X': continue elif cur[1] == p[1] and place[min_r + 1][min_c] == 'X': continue if cur[0] != p[0] and cur[1] != p[1]: if place[min_r][min_c] == 'P' and place[min_r+1][min_c] == 'X' and \\ place[min_r][min_c+1] == 'X': continue elif place[min_r][min_c+1] == 'P' and place[min_r][min_c] == 'X' and \\ place[min_r+1][min_c+1] == 'X': continue return False return calcIsRight(new_arr) answer.append(1 if calcIsRight(per) else 0) return answer 설명 구현 능력을 묻는 카카오 인턴쉽 2번째 문제다. 지도가 주어지고, 이를 해석하며 풀어야하는 문제로 풀이 난이도 자체는 크게 어렵지 않으나 간단하게 풀리지 않는 경우가 많은 유형의 문제다. 따라서 문제의 요구사항에 집중하며 풀어야 하는데, 나는 이 문제를 bfs처럼 풀이했다. 우선 사람들의 위치만을 인식하여 per 배열에 담고, 이들 서로간의 거리를 계산하며 문제를 풀었다. 따라서 사람의 등장에 따라 효율성이 떨어질 수 있지만, 주어진 맵의 크기가 작아 크게 상관 없었다. 단순히 5x5 크기의 map을 돌며 풀 수 있는 풀이로 개선해봐야겠다. python 풀이 개선 추가123456789101112131415161718192021def solution(places): answer = [] dx = [0,1,1,0,2,1] dy = [1,0,1,2,0,-1] def sol(place): for r, row in enumerate(place): for c, p in enumerate(row): if p == 'P': for i in range(6): if -1 &lt; r+dx[i] &lt; 5 and -1 &lt; c+dy[i] &lt; 5 and place[r+dx[i]][c+dy[i]] == 'P': if i &lt; 2 : return 0 elif i == 2 and (place[r+1][c] != 'X' or place[r][c+1] != 'X'): return 0 elif i == 3 and place[r][c+1] != 'X': return 0 elif i == 4 and place[r+1][c] != 'X': return 0 elif i == 5 and (place[r][c-1] != 'X' or place[r+1][c] != 'X'): return 0 return 1 for p in places: answer.append(sol(p)) return answer","link":"/2021/07/14/607c8167d984/"},{"title":"[프로그래머스] (LV2) 뉴스 클러스터링","text":"[1차] 뉴스 클러스터링Python3 문제 설명 뉴스 클러스터링여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다. 개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 “카카오 신입 개발자 공채” 관련 기사를 검색해보았다. 카카오 첫 공채..’블라인드’ 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.. “코딩 실력만 본다” 카카오 “코딩 능력만으로 2018 신입 개발자 뽑는다” 기사의 제목을 기준으로 “블라인드 전형”에 주목하는 기사와 “코딩 테스트”에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다. 유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 “자카드 유사도”라는 방법을 찾아냈다. 자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 A, B 사이의 자카드 유사도 J(A, B)는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다. 예를 들어 집합 A = {1, 2, 3}, 집합 B = {2, 3, 4}라고 할 때, 교집합 A ∩ B = {2, 3}, 합집합 A ∪ B = {1, 2, 3, 4}이 되므로, 집합 A, B 사이의 자카드 유사도 J(A, B) = 2/4 = 0.5가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 J(A, B) = 1로 정의한다. 자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 “1”을 3개 가지고 있고, 다중집합 B는 원소 “1”을 5개 가지고 있다고 하자. 이 다중집합의 교집합 A ∩ B는 원소 “1”을 min(3, 5)인 3개, 합집합 A ∪ B는 원소 “1”을 max(3, 5)인 5개 가지게 된다. 다중집합 A = {1, 1, 2, 2, 3}, 다중집합 B = {1, 2, 2, 4, 5}라고 하면, 교집합 A ∩ B = {1, 2, 2}, 합집합 A ∪ B = {1, 1, 2, 2, 3, 4, 5}가 되므로, 자카드 유사도 J(A, B) = 3/7, 약 0.42가 된다. 이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 “FRANCE”와 “FRENCH”가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 J(&quot;FRANCE&quot;, &quot;FRENCH&quot;) = 2/8 = 0.25가 된다. 입력 형식 입력으로는 str1과 str2의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다. 입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 “ab+”가 입력으로 들어오면, “ab”만 다중집합의 원소로 삼고, “b+”는 버린다. 다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. “AB”와 “Ab”, “ab”는 같은 원소로 취급한다. 출력 형식입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다. 예제 입출력 str1 str2 answer FRANCE french 16384 handshake shake hands 65536 aa1+aa2 AAAA12 43690 E=M*C^2 e=m*c^2 65536 해설 보러가기 풀이 python1234567891011def solution(str1, str2): split = lambda x:[x[i:i+2].lower() for i in range(len(x)-1) if x[i:i+2].isalpha()] summary = lambda arr: {i:arr.count(i) for i in arr} a_sum, b_sum = summary(split(str1)), summary(split(str2)) if len(a_sum) + len(b_sum) == 0 : return 65536; intersection = sum([min(a_sum[a],b_sum[a]) for a in a_sum if a in b_sum]); union = sum(a_sum.values()) + sum(b_sum.values()) - intersection; return int(intersection/union * 65536); 설명 풀이 전략 문제의 조건을 구현할 수 있는 피지컬을 요하는 구현 문제다. 문제는 크게 2가지 과정으로 풀이 된다. 주어진 두 배열을 각각 2글자로 이루어진 원소의 집합으로 만들기 두 집합으로 교집합과 합집합 계산 및 결과 반환하기 2글자 집합 만들기 문제의 조건대로 2글자씩 배열을 나눈 뒤, 이를 알파벳인지 검사한다. 이 때 python 내장함수 isalpha()를 사용한다. 만약 알파벳이 맞다면 lower() 함수를 이용해 소문자 단어로 변환하여 배열에 저장한다. 결과적으로 소문자 2개로 이루어진 원소들을 가지는 집합이 된다. 예시 : [fr, ra, an, nc, ce, fr, re, en, nc, ch] 여기서 각 단어 개수를 카운팅하여 dictionary로 저장한다. 이때 count 함수를 활용한다. 예시 : {fr:2, nc:2, ra:1,an:1 , …} 교집합 (intersection) 1intersection = sum([min(a_sum[a],b_sum[a]) for a in a_sum if a in b_sum]) 두 집합에 동시에 속한 단어가 있다면 해당 단어 counting의 최소 값을 모아 합산 한다. 합집합 (union) 1union = sum(a_sum.values()) + sum(b_sum.values()) - intersection 합집합은 두 집합의 전체 값 - 교집합으로 계산할 수 있다. 따라서 각 집합 결과의 sum을 더해 앞서 계산한 교집합 값을 빼면 된다. 이후, 교집합 값과 합집합 값을 문제 조건대로 계산하여 반환하면 된다.","link":"/2021/08/13/dec5e25d4d7a/"},{"title":"[프로그래머스] (LV2) 더 맵게","text":"더 맵게Python3 문제 설명매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다. 12섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\\Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요. 제한 사항 scoville의 길이는 2 이상 1,000,000 이하입니다. K는 0 이상 1,000,000,000 이하입니다. scoville의 원소는 각각 0 이상 1,000,000 이하입니다. 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. 입출력 예 scoville K return [1, 2, 3, 9, 10, 12] 7 2 입출력 예 설명 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\\새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\\가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12] 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\\새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\\가진 음식의 스코빌 지수 = [13, 9, 10, 12] 모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다. 풀이 python12345678910import heapq as hdef solution(scoville, K): answer = 0 h.heapify(scoville) while scoville[0] &lt; K: if len(scoville) == 1: return -1 v = h.heappop(scoville) + h.heappop(scoville) * 2 h.heappush(scoville, v) answer += 1 return answer 설명 heap을 사용하면 매우 간단히 풀 수 있는 문제다. scoville 지수를 정렬한 뒤, 최소 값을 계산하여 이를 다시 갱신해야 한다. 이 때 heap 자료구조를 사용하면 빠르게 문제를 풀 수 있다.","link":"/2021/07/13/32d615d6d313/"},{"title":"[프로그래머스] (LV2) 상호 평가","text":"상호 평가Python3 문제 설명 대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다. No. 0 1 2 3 4 0 100 90 98 88 65 1 50 45 99 85 77 2 47 88 95 80 67 3 61 57 100 80 65 4 24 90 94 75 65 평균 45.5 81.25 97.2 81.6 67.8 학점 F B A B D 위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다. 0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다. 0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다. 2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다. 2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다. 당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.\\만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다. 0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다. 0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다. 4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다. 4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다. 제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다. 평균 학점 90점 이상 A 80점 이상 90점 미만 B 70점 이상 80점 미만 C 50점 이상 70점 미만 D 50점 미만 F 학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ scores의 행의 길이(학생 수) ≤ 10 scores의 열의 길이 = scores의 행의 길이 즉, scores는 행과 열의 길이가 같은 2차원 배열입니다. 0 ≤ scores의 원소 ≤ 100 return 값 형식 0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다. 입출력 예 scores result [[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]] &quot;FBABD&quot; [[50,90],[50,87]] &quot;DA&quot; [[70,49,90],[68,50,38],[73,31,100]] &quot;CFD&quot; 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 No. 0 1 0 50 90 1 50 87 평균 50 90 학점 D A 1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다. 입출력 예 #3 No. 0 1 2 0 70 49 90 1 68 50 38 2 73 31 100 평균 70.33… 40 64 학점 C F D 1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다. 2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다. 풀이 python1234567891011121314def solution(scores): scores = [[score[r] for score in scores] for r in range(len(scores))] grade = [(90,'A'),(80,'B'),(70,'C'),(50,'D'),(0,'F')] grading = lambda x: next(v[1] for i,v in enumerate(grade) if x &gt;= v[0]) answer = '' for idx, score in enumerate(scores): without_self = [s for i,s in enumerate(score) if i != idx] if score[idx] &gt; max(without_self) or score[idx] &lt; min(without_self): answer += grading(sum(without_self) / len(without_self)) else: answer += grading(sum(score) / len(score)) return answer 설명 풀이 과정 행열 전환 성적 산출 함수 구현 결과 도출 풀이 설명[ 행열 전환하기 (행 &lt;-&gt; 열) ] 1scores = [[score[r] for score in scores] for r in range(len(scores))] [ 성적 산출 ] 12grade = [(90,'A'),(80,'B'),(70,'C'),(50,'D'),(0,'F')]grading = lambda x: next(v[1] for i,v in enumerate(grade) if x &gt;= v[0]) python의 tuple을 이용해 성적 산출을 리스트로 구현했다. [ 결과 도출 ] 1234567answer = ''for idx, score in enumerate(scores): without_self = [s for i,s in enumerate(score) if i != idx] if score[idx] &gt; max(without_self) or score[idx] &lt; min(without_self): answer += grading(sum(without_self) / len(without_self)) else: answer += grading(sum(score) / len(score)) 자신의 점수를 제외한 without_self 리스트를 만든다. 현재 값이 without_self의 최대값보다 크거나 최소값보다 작으면 제외한다. 자신의 점수가 제외된 without_self로 평균 점수와 성적을 산출한다. 그게 아니면 전체 값으로 성적을 산출한다.","link":"/2021/08/16/5a27c5948dfc/"},{"title":"[프로그래머스] (LV2) 숫자의 표현","text":"Python3 문제 설명 Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다. 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요. 제한사항 n은 10,000 이하의 자연수 입니다. 입출력 예 n result 15 4 입출력 예 설명입출력 예#1\\문제의 예시와 같습니다. 풀이 python123456789101112def solution(n): answer = 0 for i in range(1,n+1): count = 0 for j in range(i,n+1): count += j if count == n: answer += 1 break elif count &gt; n: break return answer 설명 O(N^2)으로도 풀리는 간단한 문제지만, 자료구조를 이용하면 더 빠르게 풀 수 있다.","link":"/2021/08/27/fcb225688f00/"},{"title":"[프로그래머스] (LV2) 영어 끝말잇기","text":"영어 끝말잇기JavaScript, Python 문제 설명1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다. 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다. 다음은 3명이 끝말잇기를 하는 상황을 나타냅니다. tank → kick → know → wheel → land → dream → mother → robot → tank 위 끝말잇기는 다음과 같이 진행됩니다. 1번 사람이 자신의 첫 번째 차례에 tank를 말합니다. 2번 사람이 자신의 첫 번째 차례에 kick을 말합니다. 3번 사람이 자신의 첫 번째 차례에 know를 말합니다. 1번 사람이 자신의 두 번째 차례에 wheel을 말합니다. (계속 진행) 끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다. 사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요. 제한 사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return 해주세요. 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요. 입출력 예 n words result 3 [“tank”, “kick”, “know”, “wheel”, “land”, “dream”, “mother”, “robot”, “tank”] [3,3] 5 [“hello”, “observe”, “effect”, “take”, “either”, “recognize”, “encourage”, “ensure”, “establish”, “hang”, “gather”, “refer”, “reference”, “estimate”, “executive”] [0,0] 2 [“hello”, “one”, “even”, “never”, “now”, “world”, “draw”] [1,3] 입출력 예 설명입출력 예 #1\\3명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : tank, wheel, mother 2번 사람 : kick, land, robot 3번 사람 : know, dream, tank 와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다. 입출력 예 #2\\5명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, recognize, gather 2번 사람 : observe, encourage, refer 3번 사람 : effect, ensure, reference 4번 사람 : take, establish, estimate 5번 사람 : either, hang, executive 와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다. 입출력 예 #3\\2명의 사람이 끝말잇기에 참여하고 있습니다. 1번 사람 : hello, even, now, draw 2번 사람 : one, never, world 와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 ‘r’로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다 풀이 javascript12345678910111213function solution(n, words) { let dict = {} dict[words[0]] = true const isRight = (a,b)=&gt;{return a[a.length-1] !== b[0]} for(let i = 1; i &lt; words.length; i++){ if(dict[words[i]] || isRight(words[i-1], words[i])){ return [(i % n)+1,Math.ceil((i+1) / n)] } else dict[words[i]] = true } return [0,0]} python12345678910import mathdef solution(n, words): dict_ = {} dict_[words[0]] = 0 for i in range(1,len(words)): if words[i-1][-1] != words[i][0] or words[i] in dict_: return [(i % n)+1, math.ceil((i+1)/n)] else: dict_[words[i]] = 0 return [0, 0] 설명 Dictionary를 사용하면 손쉽게 풀 수 있는 문제다. javascript에서는 a, b 를 비교하는 reduce 형식으로 풀었고, 파이썬은 이러한 기능이 있긴 하지만 인덱스로 처리하는 편이 더 편하고 깔끔했다. 하지만 이 때 이전 인덱스와 비교해야 하므로 첫 노드는 건너뛰어야 한다. 그래서 word의 첫 값을 미리 Dict에 넣어 두어야 한다.","link":"/2021/06/30/316bd20cfd3a/"},{"title":"[프로그래머스] (LV2) 예상 대진표","text":"예상 대진표JavaScript, Python 문제 설명△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, … , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다. 이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다. 제한사항 N : 21 이상 220 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.) A, B : N 이하인 자연수 (단, A ≠ B 입니다.) 입출력 예 N A B answer 8 4 7 3 입출력 예 설명입출력 예 #1\\첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다. 항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다. 두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다. 항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다. 세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다. 풀이 javascript12345678910function solution(n,a,b){ let answer = 0; while(a !== b){ a = Math.ceil(a/2) b = Math.ceil(b/2) answer++; } return answer} python12345678def solution(n,a,b): answer = 0 while a != b: answer += 1 a, b = ((a+1) // 2, (b+1) // 2) return answer 설명 math의 ceil함수로 올림을 사용하면 더 편리하지만, 패키지의 사용을 최소화 하려 노력하고 있기 때문에 a 와 b에 1을 더해서 내부 내림 연산 (//)을 사용했다. 비트를 이용한 풀이도 존재한다. 12def solution(n,a,b): return ((a-1)^(b-1)).bit_length() bit_length 함수는 정수를 2진법으로 표현할 때 필요한 비트 수를 반환한다. 즉, 두 정수 a-1,b-1이 xor 연산을 통해 서로의 최대 자리수 차이를 구하고 이 값의 표현에 필요한 비트 수를 통해 총 필요한 경기수를 알 수 있다. 가깝게 대진표가 잡힌다면 적은 경기 수를, 대진표가 서로 멀리 잡힌다면 비교적 많은 경기 수를 필요로 하게 된다. a = 1, b = 3 이라면(a-1)^(b-1) = 00 ^ 10 = 10 이고,이진법 10의 필요 비트 수는 2 이므로 2번의 경기를 통해 만날 수 있다. a = 1, b = 8 이라면(a-1)^(b-1) = 0000 ^ 1000 = 1000 이고,이진법 1000의 필요 비트 수는 4 이므로 총 4번의 경기를 통해 만날 수 있다.","link":"/2021/06/30/21fb616de1a4/"},{"title":"[프로그래머스] (LV2) 오픈채팅방","text":"오픈채팅방JavaScript, Python3 문제 설명카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다. 신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다. “[닉네임]님이 들어왔습니다.” 채팅방에서 누군가 나가면 다음 메시지가 출력된다. “[닉네임]님이 나갔습니다.” 채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다. 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다. 채팅방에서 닉네임을 변경한다. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다. 예를 들어, 채팅방에 “Muzi”와 “Prodo”라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다. “Muzi님이 들어왔습니다.”\\“Prodo님이 들어왔습니다.” 채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다. “Muzi님이 들어왔습니다.”\\“Prodo님이 들어왔습니다.”\\“Muzi님이 나갔습니다.” Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다. “Prodo님이 들어왔습니다.”\\“Prodo님이 들어왔습니다.”\\“Prodo님이 나갔습니다.”\\“Prodo님이 들어왔습니다.” 채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다. “Prodo님이 들어왔습니다.”\\“Ryan님이 들어왔습니다.”\\“Prodo님이 나갔습니다.”\\“Prodo님이 들어왔습니다.” 채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라. 제한사항 record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다. 다음은 record에 담긴 문자열에 대한 설명이다. 모든 유저는 [유저 아이디]로 구분한다. [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - “Enter [유저 아이디] [닉네임]” (ex. “Enter uid1234 Muzi”) [유저 아이디] 사용자가 채팅방에서 퇴장 - “Leave [유저 아이디]” (ex. “Leave uid1234”) [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - “Change [유저 아이디] [닉네임]” (ex. “Change uid1234 Muzi”) 첫 단어는 Enter, Leave, Change 중 하나이다. 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다. 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다. 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다. 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다. 입출력 예 record result [&quot;Enter uid1234 Muzi&quot;, &quot;Enter uid4567 Prodo&quot;,&quot;Leave uid1234&quot;,&quot;Enter uid1234 Prodo&quot;,&quot;Change uid4567 Ryan&quot;] [&quot;Prodo님이 들어왔습니다.&quot;, &quot;Ryan님이 들어왔습니다.&quot;, &quot;Prodo님이 나갔습니다.&quot;, &quot;Prodo님이 들어왔습니다.&quot;] 입출력 예 설명입출력 예 #1\\문제의 설명과 같다. 풀이 javascript123456789101112131415function solution(record) { var nicknames = {}; var answer = []; record.forEach((r)=&gt;{ const rs = r.split(' ') if(rs[0] !== 'Leave') nicknames[rs[1]] = rs[2] if(rs[0] !== 'Change') answer.push({id:rs[1],type:rs[0]}) }) return answer.map((a)=&gt;a.type === 'Enter' ? (nicknames[a.id]+'님이 들어왔습니다.') : (nicknames[a.id]+'님이 나갔습니다.') );} python12345678910111213141516def solution(record): answer = [] ids = {} command = {'Enter':'님이 들어왔습니다.', 'Leave':'님이 나갔습니다.'} for r in record: r_split = r.split(' ') if r_split[0] in ['Enter', 'Change']: ids[r_split[1]] = r_split[2] for r in record: r_split = r.split(' ') if r_split[0] != 'Change': answer.append(ids[r_split[1]] + command[r_split[0]]) return answer 설명 딕셔너리 자료구조를 사용하면 쉽게 풀 수 있는 문제다. Python풀이에서 split()대신 unpack과 rest 개념을 이용해 할당해 보고 싶어졌다. 1234567891011121314151617def solution(record): answer = [] ids = {} command = {'Enter':'님이 들어왔습니다.', 'Leave':'님이 나갔습니다.'} setVar = lambda *x: x if len(x) == 3 else [*x,''] for r in record: command_, id_, nickname_ = setVar(r.split(' ')) if command_ in ['Enter', 'Change']: ids[id_] = nickname_ for r in record: command_, id_, nickname_ = setVar(r.split(' ')) if command_ != 'Change': answer.append(ids[id_] + command[command_]) return answer 이외에도 아래 처럼 Python에서 rest parameter 를 사용할 수 있다.","link":"/2021/06/30/26a28c26db07/"},{"title":"[프로그래머스] (LV2) 위장","text":"위장JavaScript, Python3 문제 설명스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]] 5 [[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]] 3 입출력 예 설명예제 #1\\headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. 123456&gt;1\\. yellow_hat&gt;2. blue_sunglasses&gt;3. green_turban&gt;4. yellow_hat + blue_sunglasses&gt;5. green_turban + blue_sunglasses 예제 #2\\face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. 1234&gt;1\\. crow_mask&gt;2. blue_sunglasses&gt;3. smoky_makeup 출처 풀이 javascript12345678910111213function solution(clothes) { var hash = [] var answer = 1; for(let i in clothes){ hash[clothes[i][1]] = (hash[clothes[i][1]]|0)+1; } for(let i in hash){ answer *= (hash[i]+1) } return answer - 1;} python12345678def solution(clothes): clothes_ = {} answer = 1 for [cloth,type_] in clothes: clothes_[type_] = 1 if type_ not in clothes_ else clothes_[type_] + 1 for c in clothes_.values(): answer *= (c + 1) return answer - 1 설명 부분 집합의 개수를 계산하기 위해서는 전체 원소수만큼 2를 거듭 제곱한 후 1을 빼는 계산을 수행하면 된다. 2^n-1 &nbsp; 여기서 2를 거듭 곱하는 이유는 각 원소가 (포함하는 경우)와 (포함하지 않는 경우)를 계산한 것으로, 전체 결과에는 공집합(어떤 원소도 포함되지 않음)이 포함되어 있다. 해당 문제는 여기서 한 발짝 더 나아가 같은 종류 내에서도 여러 아이템이 존재할 수 있고 그 중 하나를 골라야 한다. 따라서 다음과 같은 계산 절차를 수행해야 한다. 종류별 아이템 개수를 계산하여 배열에 저장 위 배열에 저장된 아이템 개수에 1을 더하여 모두 곱함 결과값에서 1을 뺌 2번에서 1을 더하는 이유는 모든 각 종류에 해당하는 아이템들 중 어떠한 아이템도 선택하지 않는 경우도 경우의 수로 포함해야 하기 때문이다. 3번에서 1을 빼는 이유는 앞서 말한 것처럼 모든 경우의 수를 더했을때 최종적으로 공집합(아무런 옷도 입지 않는 경우)을 제외해야 하기 때문이다.","link":"/2021/06/30/020fc0e1da65/"},{"title":"[프로그래머스] (LV2) 전화번호 목록","text":"전화번호 목록Python3 문제 설명전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.\\전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다. 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요. 제한 사항 phone_book의 길이는 1 이상 1,000,000 이하입니다. 각 전화번호의 길이는 1 이상 20 이하입니다. 같은 전화번호가 중복해서 들어있지 않습니다. 입출력 예제 phone_book return [“119”, “97674223”, “1195524421”] false [“123”,”456”,”789”] true [“12”,”123”,”1235”,”567”,”88”] false 입출력 예 설명입출력 예 #1\\앞에서 설명한 예와 같습니다. 입출력 예 #2\\한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다. 입출력 예 #3\\첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다. 알림 2021년 3월 4일, 테스트 케이스가 변경되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다. 출처 풀이 python123456def solution(phone_book): phone_book.sort() for i in range(1,len(phone_book)): if phone_book[i].find(phone_book[i-1]) == 0: return False return True 설명 해시 카테고리의 문제이나, 언뜻 생각할 수 있는 풀이 방법은 다양하다. 그러나 문제의 제한사항에서 phone_book의 길이가 최대 100만이므로, $O(N^2)$ 이상은 효율성에서 실패할 것이다. 그러므로 최소한 $O(NlogN)$ 이하의 효율성을 보이는 풀이가 필요하다. hash를 이용해서도 문제를 풀 수 있다. 한 번의 반복문으로 모든 번호를 hash에 넣고, 다시 한 번 배열을 돌며 각 번호의 부분집합이 dict에 포함되어있는지 비교하면 된다. 전화번호의 길이가 최대 20이므로, 총 계산은 $O(21N)$이 되어 아슬아슬하게 풀이에 통과된다. 그러나 가장 간단한 풀이는, 위 코드처럼 번호를 ‘문자’를 기준으로 정렬했을 때다. 이때 접두사가 포함된 문자는 반드시 접두사 문자 바로 뒤에 정렬되기 때문에 간단히 O(N) 비용으로 문제를 풀 수 있다.","link":"/2021/07/18/157c8079359d/"},{"title":"[프로그래머스] (LV2) 조이스틱","text":"조이스틱Python 문제 설명조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\\ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 12345&gt;▲ - 다음 알파벳&gt;▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)&gt;◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)&gt;▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 “JAZ”를 만들 수 있습니다. 12345&gt;- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.&gt;- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.&gt;- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.&gt;따라서 11번 이동시켜 &quot;JAZ&quot;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 name return “JEROEN” 56 “JAN” 23 출처 풀이 python12345678910111213141516171819def solution(name): answer = 0 n = len(name) num_char = [i for i in range(14)] + [j for j in range(12, 0, -1)] change_num_char = lambda char: num_char[ord(char) - ord('A')] for c in name: answer += change_num_char(c) move = n - 1 for i in range(n): next_i = i + 1 while (next_i &lt; n) and (name[next_i] == 'A'): next_i += 1 distance = min(i, n - next_i) move = min(move, i + n - next_i + distance) answer += move return answer 설명 탐욕법을 이용한 풀이 과정은 다음과 같다. 문자열의 바꿔야할 거리를 미리 계산한다. 주어진 문자열의 반복문을 돌며 매 문자 기준에서 정방향과 역방향의 최소값을 계산한다. 정방향으로 이동하는 경우는 n-1로 고정되어있다. 만약 어떤 노드에서 연속되는 A의 길이를 만나 역방향으로의 이동이 더 거리가 짧다면, 해당 역방향 거리 이동값이 move에 갱신된다. 해당 풀이는 다른 선택들에 영향을 끼치지 않고 반복되므로 탐욕법 풀이방법이다.","link":"/2021/06/30/1395b99f321c/"},{"title":"[프로그래머스] (LV2) 주식가격","text":"Python3 문제 설명초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요. 제한사항 prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. prices의 길이는 2 이상 100,000 이하입니다. 입출력 예 prices return [1, 2, 3, 2, 3] [4, 3, 1, 1, 0] 입출력 예 설명 1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다. 2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다. 3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다. 4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다. 5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다. ※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다. 풀이 python123456789def solution(prices): n = len(prices) answer = [0]*n for i, price in enumerate(prices): for j in range(i+1, n): answer[i] += 1 if price &gt; prices[j]: break return answer 설명 문제 설명이 애매한 편이지만, 차분하게 풀면 O(N^2)의 효율성 만으로도 풀 수 있는 문제다.","link":"/2021/08/25/752f5e69183a/"},{"title":"[프로그래머스] (LV2) 직업군 추천하기","text":"Python3 문제 설명 개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다. 아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다. 점수 SI CONTENTS HARDWARE PORTAL GAME 5 JAVA JAVASCRIPT C JAVA C++ 4 JAVASCRIPT JAVA C++ JAVASCRIPT C# 3 SQL PYTHON PYTHON PYTHON JAVASCRIPT 2 PYTHON SQL JAVA KOTLIN C 1 C# C++ JAVASCRIPT PHP JAVA 예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다. SQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다. 직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다. 개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요. 총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요. 제한사항 table의 길이 = 5 table의 원소는 &quot;직업군 5점언어 4점언어 3점언어 2점언어 1점언어&quot;형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다. table은 모든 테스트케이스에서 동일합니다. 1 ≤ languages의 길이 ≤ 9 languages의 원소는 &quot;JAVA&quot;, &quot;JAVASCRIPT&quot;, &quot;C&quot;, &quot;C++&quot; ,&quot;C#&quot; , &quot;SQL&quot;, &quot;PYTHON&quot;, &quot;KOTLIN&quot;, &quot;PHP&quot; 중 한 개 이상으로 이루어져 있습니다. languages의 원소는 중복되지 않습니다. preference의 길이 = languages의 길이 1 ≤ preference의 원소 ≤ 10 preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다. return 할 문자열은 &quot;SI&quot;, &quot;CONTENTS&quot;, &quot;HARDWARE&quot;, &quot;PORTAL&quot;, &quot;GAME&quot; 중 하나입니다. 입출력 예 table languages preference result [&quot;SI JAVA JAVASCRIPT SQL PYTHON C#&quot;, &quot;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++&quot;, &quot;HARDWARE C C++ PYTHON JAVA JAVASCRIPT&quot;, &quot;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP&quot;, &quot;GAME C++ C# JAVASCRIPT C JAVA&quot;] [&quot;PYTHON&quot;, &quot;C++&quot;, &quot;SQL&quot;] [7, 5, 5] &quot;HARDWARE&quot; [&quot;SI JAVA JAVASCRIPT SQL PYTHON C#&quot;, &quot;CONTENTS JAVASCRIPT JAVA PYTHON SQL C++&quot;, &quot;HARDWARE C C++ PYTHON JAVA JAVASCRIPT&quot;, &quot;PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP&quot;, &quot;GAME C++ C# JAVASCRIPT C JAVA&quot;] [&quot;JAVA&quot;, &quot;JAVASCRIPT&quot;] [7, 5] &quot;PORTAL&quot; 입출력 예 설명입출력 예 #1 각 직업군 별로 점수를 계산해보면 아래와 같습니다. 아래 사진은 개발자 언어 선호도 나타낸 표입니다. 아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다. 따라서 점수 총합이 41로 가장 높은 &quot;HARDWARE&quot;를 return 해야 합니다. 입출력 예 #2 각 직업군 별로 점수를 계산해보면 아래와 같습니다. 아래 사진은 개발자 언어 선호도 나타낸 표입니다. 아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다. \\점수 총합이 55로 가장 높은 직업군은 “SI” 와 “PORTAL”입니다.\\따라서 사전 순으로 먼저 오는 &quot;PORTAL&quot;을 return 해야 합니다. 풀이 python123456789101112import heapq as hdef solution(table, languages, preference): answer = [] table_hash = {} for i in range(len(table)): t_s = table[i].split(' ') table_hash[t_s[0]] = {t:5-i for i,t in enumerate(t_s[1:])} for t in table_hash.items(): h.heappush(answer,(-sum(t[1][l]*preference[l_i] for l_i, l in enumerate(languages) if l in t[1]),t[0])) return h.heappop(answer)[1]","link":"/2021/08/23/f67283951ab9/"},{"title":"[프로그래머스] (LV2) 짝지어 제거하기","text":"짝지어 제거하기JavaScript 문제 설명짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다. 예를 들어, 문자열 S = baabaa 라면 b aa baa → bb aa → aa → 의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다. 제한사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 입출력 예 s result baabaa 1 cdcd 0 입출력 예 설명입출력 예 #1\\위의 예시와 같습니다.\\입출력 예 #2\\문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다. ※ 공지 - 2020년 6월 8일 테스트케이스가 추가되었습니다. 풀이 javascript1234567891011function solution(s){ let stack = [] for(let i = 0 ; i &lt; s.length; i++){ if(stack.length &gt; 0 &amp;&amp; stack[stack.length-1] === s[i]) stack.pop() else stack.push(s[i]) } return stack.length === 0 ? 1 : 0} 설명 stack 자료구조를 연습하기 좋은 기본 문제다. 문자의 앞에서부터 stack의 마지막 문자(Last In)와 비교하는 행위를 반복한다. 같은 문자라면 pop을 시켜 두 문자를 넘기고, 만약 다른 문자라면 stack에 push한다. 마지막에 stack에 문자가 남으면 실패, 안남으면 성공이다.","link":"/2021/06/30/6b4f99a78f45/"},{"title":"[프로그래머스] (LV2) 카펫","text":"JavaScript, Python3 문제 설명Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예 brown yellow return 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 출처 ※ 공지 - 2020년 2월 3일 테스트케이스가 추가되었습니다.\\※ 공지 - 2020년 5월 11일 웹접근성을 고려하여 빨간색을 노란색으로 수정하였습니다. 풀이 javascript123456789101112function solution(brown, yellow) { for(let y_width = yellow; y_width &gt;= yellow/y_width; y_width--){ const y_height = yellow/y_width if(!Number.isInteger(y_height)){ continue; } if(brown === ((y_width + y_height)*2 + 4)) return [y_width+2,y_height+2] }} python1234def solution(brown, yellow): for i in range (1, int(yellow ** (1/2)) + 1): if yellow % i == 0 and brown == (i*2 + yellow/i*2 + 4): return [(yellow/i)+2 , i+2] 설명 풀이 전략완전탐색의 원리대로 모든 경우의 수를 찾으며 푸는 문제. 풀이 설명[Python 풀이 기준] 노란블럭 개수 = y 갈색블럭 개수 = b 노란블럭의 가로의 길이를 i로 가정하고 1부터 y의 제곱근(정사각형일 경우)까지 반복문을 시행한다. 이때 y &amp; i != 0인 경우는 포함될 수 없으므로 제외한다. b의 개수가 i(가로) * 2 + y/i(세로) * 2 + 4(모서리)가 된다면 [y/i+2,i+2]를 반환하고 종료한다.","link":"/2021/06/30/d5d427311d47/"},{"title":"[프로그래머스] (LV2) 큰 수 만들기","text":"큰 수 만들기JavaScript 문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다. 입출력 예 number k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 출처 풀이 javascript12345678910111213141516171819202122232425function solution(number, k) { var nNumSize = number.length - k; var arrRet = Array.from(Array(nNumSize),()=&gt;null); var nPos = 0; var idx = 0; while(nNumSize &gt; 0){ var chMax = 0; for(let i = nPos; i &lt;= number.length - nNumSize; ++i){ if(number[i] &gt; chMax){ chMax = number[i]; nPos = i; if(chMax === &quot;9&quot;) break; } } ++nPos; --nNumSize; arrRet[idx++] = chMax; } return arrRet.join('');} python123456789def solution(number, k): stack = [] n = len(number) for i in range(n): while stack and k &gt; 0 and stack[-1] &lt; number[i]: stack.pop() k -=1 stack.append(number[i]) return ''.join(stack[:n-k]) 설명 탐욕법이 사용 가능하며, 어느정도 구현 능력을 요구하는 문제다. 언뜻 간단히 k * n의 풀이 시간이 필요한 것처럼 보이는데, 여기서 문자열을 다루는 함수를 사용시 O(N)이 추가되어 O(N^2)가 되버리고, 효율성 측면에서 풀이에 실패한다. 스택 자료구조를 이용해 탐욕법으로 풀이를 한다면 O(N)의 풀이가 가능하다(python 풀이). 0부터 number의 길이까지 반복문을 돌며 현재 스택의 마지막 값보다 값이 크면 스택에서 pop()을 반복적으로 수행한다. 이를 통해 스택에는 큰수부터 작은수대로 나열된다. 수의 크기를 결정짓는 부분은 앞쪽이므로 앞 숫자들을 최대화 하는 알고리즘이다. 스택이 아닌 인덱싱을 통해서도 O(NlogN) 풀이가 가능하다(javascript 풀이). 스택을 사용하지 않을 뿐, 값 비교와 인덱싱을 통해 결과를 저장하는 메커니즘은 동일하다.","link":"/2021/06/30/ce24844deb05/"},{"title":"[프로그래머스] (LV2) 타겟 넘버","text":"타겟 넘버JavaScript, Python3 문제 설명n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다. 12345-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 주어지는 숫자의 개수는 2개 이상 20개 이하입니다. 각 숫자는 1 이상 50 이하인 자연수입니다. 타겟 넘버는 1 이상 1000 이하인 자연수입니다. 입출력 예 numbers target return [1, 1, 1, 1, 1] 3 5 입출력 예 설명문제에 나온 예와 같습니다. 풀이 javascript123456789101112131415161718function solution(numbers, target) { var answer = 0; var returnArray = [] function calc(i=0,curArray=[]){ if(i === numbers.length){ if(curArray.reduce((a,b)=&gt;a+b,0) === target) answer++; return; } calc(i+1,[numbers[i], ...curArray]) calc(i+1,[-1*numbers[i], ...curArray]) } calc() return answer} python DFS123def solution(numbers, target): n = len(numbers) return len([ i for i in range(1&lt;&lt;n) if sum(map(lambda x: [1,-1][int(x[1])]*numbers[x[0]], enumerate(list(bin(i)[2:].zfill(n))))) == target ]) python recursion1234567def solution(numbers, target): if not numbers and target == 0: return 1 elif not numbers: return 0 else: return solution(numbers[1:], target - numbers[0]) + solution(numbers[1:], target+numbers[0]) 설명 DFS 풀이 (javascript, python) 카운트를 세는 방식의 재귀함수 DFS 풀이다. 가장 일반적으로 떠올릴 수 있는 풀이 방법으로, numbers의 길이만큼 재귀함수의 뎁스를 가진다. 매 재귀함수마다 늘어나는 계산은 2가지 (-1을 곱할때와 +1을 곱할때) 이므로 2배씩 늘어난다. 따라서 numbers의 길이가 n 일때 모든 time complexity는 1 + 2 + 4 + 8 + 2^{n} = \\sum_{k=1}^{n} {2^k} 이므로 등비수열의 합이 된다. 따라서 이를 계산하면 2(2^{n}-1)이 되고, O(2^n)을 뜻한다. DFS + bit_mask (python) 재귀함수 대신 비트마스크를 이용한 반복문으로 풀이하는 방법. i에 1 ~ 1&lt;&lt;n (numbers의 길이 n 만큼의 비트를 가지는 값 / ex: n = 4 ? 1&lt;&lt;n = 16) 까지 반복문을 돌며 값을 할당한다. 할당된 i값을 비트화 한다. n=4 일때, { 0000, 0001, 0010, 0011, &nbsp; … &nbsp; , 1111 } 의 값을 가진다. 비트화된 i값을 리스트로 나누어 0일땐 +1을, 1일땐 -1을 곱한뒤 이 값들을 모두 더하고, 더한 값이 target과 같은 것들을 필터링 한다. 비트마스크를 이용한 풀이를 연습하려고 의도적으로 사용했고, 코드를 돌리면 첫 번째 풀이보다도 효율성이 떨어지는 결과를 얻는다. 위 모든 과정에서 최소 O(nlog_{2}{n})이 소요되는데, 특히나 3번 과정은 리스트를 나누고 값을 곱한뒤 더하는 계산으로 최소 O(n^3)의 복잡도를 보인다. 전체 계산은 대략 O(n^5log_{2}{n})이 된다. 여기서 재미있는 점은, 사실 아래 풀이의 효율성이 위 문제보다 좋다는 것이다. 문제에서 주어진 n의 조건은 20 이하다. 이 조건 내에서 위 O(2^n)에 접목시키면 대략 100만번의 풀이가 나온다. 아래 식에 20을 접목시키면 대략 2000만번의 풀이가 나온다. 해당 조건에서 아래 풀이가 더 효율성이 떨어지지만, 지수함수와 다항함수의 차이는 그 값이 커질수록 기하급수적으로 차이가 난다. n의 제한이 40까지만 되도 위 식의 풀이는 1조번 이상의 시간이 소요된다. 그러나 아래식은 대략 10억번의 시간으로 풀이가 가능하다. 풀이 시간 뿐만 아니라 DFS 풀이에서 반복되는 재귀함수의 stack 점유는 제한 조건이 조금만 상향되도 문제로 다가올 것이다. 따라서 이런 점으로 미루어보아, 주어진 문제의 제한사항을 꼼꼼히 확인할 필요가 있다. 특히나 이 문제처럼 다소 가벼운 조건의 문제라면 시간복잡도가 높은 풀이 방법이 오히려 좋은 효율을 보일 수 있기 때문이다.","link":"/2021/08/09/9bb8d3343a89/"},{"title":"[프로그래머스] (LV2) 튜플","text":"튜플Javascript, Python3 문제 설명셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, …, an) 튜플은 다음과 같은 성질을 가지고 있습니다. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다. 원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다. {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}} 예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} 와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}} {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}} {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}} 는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다. 특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요. [제한사항] s의 길이는 5 이상 1,000,000 이하입니다. s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다. 숫자가 0으로 시작하는 경우는 없습니다. s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다. s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다. return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다. [입출력 예] s result &quot;{{2},{2,1},{2,1,3},{2,1,3,4}}&quot; [2, 1, 3, 4] &quot;{{1,2,3},{2,1},{1,2,4,3},{2}}&quot; [2, 1, 3, 4] &quot;{{20,111},{111}}&quot; [111, 20] &quot;{{123}}&quot; [123] &quot;{{4,2,3},{3},{2,3,4,1},{2,3}}&quot; [3, 2, 4, 1] 입출력 예에 대한 설명입출력 예 #1문제 예시와 같습니다. 입출력 예 #2문제 예시와 같습니다. 입출력 예 #3(111, 20)을 집합 기호를 이용해 표현하면 {{111}, {111,20}}이 되며, 이는 {{20,111},{111}}과 같습니다. 입출력 예 #4(123)을 집합 기호를 이용해 표현하면 {{123}} 입니다. 입출력 예 #5(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다. 풀이 javascript123456789function solution(s) { return s.replace(&quot;{{&quot;,'') .replace(&quot;}}&quot;,'') .split(&quot;},{&quot;) .map(x=&gt;x.split(',')) .sort((a,b)=&gt;a.length-b.length) .reduce((list,cur)=&gt;[...new Set(list.concat(cur))]) .map(x=&gt;x*1)} python12345678import redef solution(s): answer = [] for c in sorted([i.split(',') for i in re.split('{{|}}|},{',s)[1:-1]],key=len): for d in c: if int(d) not in answer: answer.append(int(d)) return answer 설명 다음과 같은 풀이 과정을 따른다. 주어진 문자열을 2차원 배열로 정제한다. 배열 안의 내부 배열들을 각 길이의 오름차순으로 정렬한다. 반복문을 돌며 다음 배열에서 현재 배열에 없는 값을 현재 배열에 추가한다. 1번의 과정은 정규표현식을 통해 간략화 할 수 있다.3번의 과정은 reduce 함수와 Set 자료구조를 통해 쉽게 표현 할 수 있다.","link":"/2021/08/10/4ee95b87b24f/"},{"title":"[프로그래머스] (LV2) 프린터","text":"프린터JavaScript, Python3 문제 설명일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 1234&gt;1\\. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.&gt;2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.&gt;3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 제한사항 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다. 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다. location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다. 입출력 예 priorities location return [2, 1, 3, 2] 2 1 [1, 1, 9, 1, 1, 1] 0 5 입출력 예 설명예제 #1 문제에 나온 예와 같습니다. 예제 #2 6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다. 출처 풀이 javascript123456789101112131415161718function solution(priorities, location) { var answer = 0; var currentIndex = location; var n = priorities.length while(true){ answer++; var max = priorities.indexOf(Math.max.apply(null,priorities)) if(max === currentIndex) return answer; priorities[max] = 0; var head = priorities.splice(0, max) max &lt; currentIndex ? currentIndex -= max : currentIndex += (n-max); priorities.push.apply(priorities,head); }} python12345678910111213def solution(priorities, location): queue = [] while priorities: p_max = max(priorities) while priorities[0] != p_max: priorities.append(priorities.pop(0)) location = len(priorities)-1 if location == 0 else location-1 if location == 0: return len(queue) +1 else: queue.append(priorities.pop(0)) location -= 1; 설명 queue 자료구조를 활용하여 푸는 시물레이션 문제다. 문제에서 주어진 조건의 함수를 queue를 활용해 구현하면 쉽게 풀 수 있다.","link":"/2021/08/11/539b25284767/"},{"title":"[프로그래머스] (LV2) 피보나치 수","text":"피보나치 수JavaScript 문제 설명피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다. 예를들어 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 와 같이 이어집니다. 2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요. 제한 사항 n은 1이상, 100000이하인 자연수입니다. 입출력 예 n return 3 2 5 5 입출력 예 설명피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, … 와 같이 이어집니다. 풀이 javascript123456function solution(n) { let answer = [0,1]; for(let i = 2; i &lt;= n; i++) answer.push( (answer[i-1] + answer[i-2]) % 1234567 ) return answer[n];} python12345def solution(n): pbnc_list = [0,1] for i in range(2,n+1): pbnc_list.append( (pbnc_list[i-2] + pbnc_list[i-1]) % 1234567 ) return pbnc_list[-1]; 설명 피보나치 수열 문제를 풀 수 있는 가장 쉬운 방법은 재귀(recursion)일 것이다. 123456function pibonacci(n){ if(n===1 || n===2) return 1; else return pibonacci(n-2) + pibonacci(n-1);} 그러나 위 풀이에는 많은 계산들이 중복되어 효율성이 매우 떨어진다. 이 때, 배열을 이용한 동적계획법 (Dynamic Programming)을 활용해 풀 수 있다. 배열에 저장하며 사용하면 중복되는 계산없이 풀 수 있고, 이때 복잡도는 O(N)을 따른다.","link":"/2021/08/12/b5f9f208b449/"},{"title":"[프로그래머스] (LV2) 행렬 테두리 회전하기","text":"행렬 테두리 회전하기Python3 문제 설명rows x columns 크기인 행렬이 있습니다. 행렬에는 1부터 rows x columns까지의 숫자가 한 줄씩 순서대로 적혀있습니다. 이 행렬에서 직사각형 모양의 범위를 여러 번 선택해, 테두리 부분에 있는 숫자들을 시계방향으로 회전시키려 합니다. 각 회전은 (x1, y1, x2, y2)인 정수 4개로 표현하며, 그 의미는 다음과 같습니다. x1 행 y1 열부터 x2 행 y2 열까지의 영역에 해당하는 직사각형에서 테두리에 있는 숫자들을 한 칸씩 시계방향으로 회전합니다. 다음은 6 x 6 크기 행렬의 예시입니다. 이 행렬에 (2, 2, 5, 4) 회전을 적용하면, 아래 그림과 같이 2행 2열부터 5행 4열까지 영역의 테두리가 시계방향으로 회전합니다. 이때, 중앙의 15와 21이 있는 영역은 회전하지 않는 것을 주의하세요. 행렬의 세로 길이(행 개수) rows, 가로 길이(열 개수) columns, 그리고 회전들의 목록 queries가 주어질 때, 각 회전들을 배열에 적용한 뒤, 그 회전에 의해 위치가 바뀐 숫자들 중 가장 작은 숫자들을 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 rows는 2 이상 100 이하인 자연수입니다. columns는 2 이상 100 이하인 자연수입니다. 처음에 행렬에는 가로 방향으로 숫자가 1부터 하나씩 증가하면서 적혀있습니다. 즉, 아무 회전도 하지 않았을 때, i 행 j 열에 있는 숫자는 ((i-1) x columns + j)입니다. queries의 행의 개수(회전의 개수)는 1 이상 10,000 이하입니다. queries의 각 행은 4개의 정수 [x1, y1, x2, y2]입니다. x1 행 y1 열부터 x2 행 y2 열까지 영역의 테두리를 시계방향으로 회전한다는 뜻입니다. 1 ≤ x1 &lt; x2 ≤ rows, 1 ≤ y1 &lt; y2 ≤ columns입니다. 모든 회전은 순서대로 이루어집니다. 예를 들어, 두 번째 회전에 대한 답은 첫 번째 회전을 실행한 다음, 그 상태에서 두 번째 회전을 실행했을 때 이동한 숫자 중 최솟값을 구하면 됩니다. 입출력 예시 rows columns queries result 6 6 [[2,2,5,4],[3,3,6,6],[5,1,6,3]] [8, 10, 25] 3 3 [[1,1,2,2],[1,2,2,3],[2,1,3,2],[2,2,3,3]] [1, 1, 5, 3] 100 97 [[1,1,100,97]] [1] 입출력 예 설명입출력 예 #1 회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다. 입출력 예 #2 회전을 수행하는 과정을 그림으로 표현하면 다음과 같습니다. 입출력 예 #3 이 예시에서는 행렬의 테두리에 위치한 모든 칸들이 움직입니다. 따라서, 행렬의 테두리에 있는 수 중 가장 작은 숫자인 1이 바로 답이 됩니다. 풀이 python1234567891011121314151617181920212223242526def solution(rows, columns, queries): square = [i for i in range(1,rows*columns+1)] answer = [] for [r1,c1,r2,c2] in queries: r1-=1;c1-=1;r2-=1;c2-=1; min_ = 10000 temp = None for i in range(c1+1,c2+1): if temp: temp, square[columns*r1 + i] = (square[columns*r1 + i], temp) else: temp, square[columns*r1 + i] = (square[columns*r1 + i], square[columns*r1 + i - 1]) if min_ &gt; temp: min_ = temp for i in range(r1+1,r2+1): temp, square[columns*i + c2] = (square[columns*i + c2], temp) if min_ &gt; temp: min_ = temp for i in range(c2-1,c1-1,-1): temp, square[columns*r2 + i] = (square[columns*r2 + i], temp) if min_ &gt; temp: min_ = temp for i in range(r2-1,r1-1,-1): temp, square[columns*i + c1] = (square[columns*i + c1], temp) if min_ &gt; temp: min_ = temp answer.append(min_) return answer 설명 ‘구현’ 능력이 필요한 문제다. 풀이에선 회전을 위해 4번의 for문을 사용하는데, 각 회전때마다 현재(temp)값과 배열값을 비교하여 교환한다. 이를 통해 이전 값을 한 칸씩 앞으로 이동시킬 수 있다.","link":"/2021/06/30/588dedd8ea95/"},{"title":"[프로그래머스] (LV1) 2016년","text":"2016년JavaScript, Python 문제 설명2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT 입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요. 제한 조건 2016년은 윤년입니다. 2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다) 입출력 예 a b result 5 24 “TUE” 풀이 javascript1234567891011function solution(a, b) { var daysOfMonth = [31,29,31,30,31,30,31,31,30,31,30,31] var days = [&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot;,&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;] var getDaySum = (index)=&gt;{ let result = 0 for(let i = 0; i &lt; index; i++) result += daysOfMonth[i] return result } return days[ (getDaySum(a-1) + b-1) % 7]} Date 클래스 이용 풀이1234function solution(a, b) { var date = new Date(2016, (a - 1), b); return date.toString().slice(0, 3).toUpperCase();} python12345import datetimedef solution(a, b): d = datetime.datetime(2016,a,b) - datetime.datetime(2016,1,1) return ('FRI','SAT','SUN','MON','TUE','WED','THU')[d.days % 7] 설명 기본적인 Date 객체 활용 문제다. 해당 문제는 실제 날짜를 활용했기 때문에 가볍게 Date 객체를 활용하여 풀 수 있다.(2번째, 3번째 풀이) 그러나 가끔 등장하는 가상의 날짜를 이용한 문제를 맞이하면 단순히 Date 객체를 활용하여 문제를 풀기 어려울 수 있다. (30일로만 이루어진 달, 가상의 윤달 및 윤년 설정 등) 따라서 직접 달마다 날짜 수를 설정해 문제를 푸는 방법을 연습해둬야 한다(javascript 풀이)","link":"/2021/06/18/4e692568222f/"},{"title":"[프로그래머스] (LV1) 3진법 뒤집기","text":"3진법 뒤집기JavaScript, Python 문제 설명자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 n은 1 이상 100,000,000 이하인 자연수입니다. 입출력 예 n result 45 7 125 229 입출력 예 설명입출력 예 #1 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 45 1200 0021 7 따라서 7을 return 해야 합니다. 입출력 예 #2 답을 도출하는 과정은 다음과 같습니다. n (10진법) n (3진법) 앞뒤 반전(3진법) 10진법으로 표현 125 11122 22111 229 따라서 229를 return 해야 합니다. 풀이 javascript12345678910111213141516171819202122function solution(n) { var answer = 0; function toBaseThree(num){ var value = '' var maxPow = 1 while( num/(maxPow*3) &gt;= 1) maxPow *= 3 for(let i = maxPow; i&gt;=1; i/=3){ var val = Math.floor(num / i) value += val num %= i } return value } toBaseThree(n).split('').forEach((v,i)=&gt;{ answer += (v * Math.pow(3,i)) }) return answer} python1234567def solution(n): answer = '' while n &gt;= 1: n, d = divmod(n,3) answer += str(d) answer = int(answer,3) return answer 설명 문제에서 요구되는 능력은 사용하는 언어의 진법 표현 방법을 아느냐(python 풀이)와 진법 변환을 직접 구현할 수 있느냐(javascript 풀이)이다. 자바스크립트로 풀때는 직접 진법 변환을 구현해보고 싶어서 위와같이 풀었고, 파이썬에서는 내장 함수를 이용했다. javascript 또한 toString() 함수를 이용해 진법을 표현할 수 있다.","link":"/2021/06/18/324ac54ff99a/"},{"title":"[프로그래머스] (LV1) k번째 수","text":"K번째수JavaScript, Python 문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 array commands return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.\\[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.\\[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 출처 풀이 javascript12345678910111213function solution(array, commands) { var answer = []; const compare = (a,b)=&gt;a-b for(let i =0; i &lt; commands.length; i ++){ // 입력값 검증 if((commands[i][1] - commands[i][0] + 1) &lt; commands[i][2]) continue; var divided = array.slice(commands[i][0]-1,commands[i][1]).sort(compare) answer.push(divided[commands[i][2]-1]) } return answer;} python12def solution(array, commands): return [sorted(array[i-1:j])[k-1] for [i,j,k] in commands] 설명 자르고, 정렬하고, 인덱싱하면 되는 간단한 문제다. javascript 풀이의 경우 따로 문제에서 언급하지 않은 입력값 검증을 추가했다.","link":"/2021/06/18/7b9a5ec9b927/"},{"title":"[프로그래머스] (LV1) x만큼 간격이 있는 n개의 숫자","text":"x만큼 간격이 있는 n개의 숫자JavaScript, Python 문제 설명함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요. 제한 조건 x는 -10000000 이상, 10000000 이하인 정수입니다. n은 1000 이하인 자연수입니다. 입출력 예 x n answer 2 5 [2,4,6,8,10] 4 3 [4,8,12] -4 2 [-4, -8] 풀이 javascript123function solution(x, n) { return Array.from(Array(n), (a,i) =&gt; (i+1)*x);} python12def solution(x, n): return [i*x for i in range(1,n+1)] 설명 반복되는 배열의 인덱스를 활용하는 문제다.","link":"/2021/08/04/a5a552938e29/"},{"title":"[프로그래머스] (lv1) 가운데 글자 가져오기","text":"가운데 글자 가져오기JavaScript, Python 문제 설명단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요. 단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다. 제한사항 s는 길이가 1 이상, 100이하인 스트링입니다. 입출력 예 s return “abcde” “c” “qwer” “we” 풀이 javascript123function solution(s) { return s.substr(Math.ceil(s.length/2)-1,s.length % 2 ===0?2:1)} python12def solution(s): return s[int(len(s)/2 - 0.5) : int(len(s)/2)+1] 설명 배열의 인덱스 관리 능력을 묻는 문제다.","link":"/2021/08/04/7c673b240a2d/"},{"title":"[프로그래머스] (LV1) 같은 숫자는 싫어","text":"같은 숫자는 싫어JavaScript, Python 문제 설명배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면, arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다. arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다. 배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요. 제한사항 배열 arr의 크기 : 1,000,000 이하의 자연수 배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수 입출력 예 arr answer [1,1,3,3,0,1,1] [1,3,0,1] [4,4,4,3,3] [4,3] 입출력 예 설명입출력 예 #1,2\\문제의 예시와 같습니다. 풀이 javascript123function solution(arr){ return arr.filter((val,index) =&gt; val !== arr[index+1]);} python123456def solution(arr): answer = [] for c in arr: if (len(answer) == 0) or (answer[-1] != c): answer.append(c) return answer 설명 배열에서 현재 원소가 다음 순서의 원소와 같지 않은 것들만 모아 반환하면 된다.","link":"/2021/08/04/07cd43fd4779/"},{"title":"[프로그래머스] (LV1) 나누어 떨어지는 숫자 배열","text":"나누어 떨어지는 숫자 배열JavaScript 문제 설명array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.\\divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요. 제한사항 arr은 자연수를 담은 배열입니다. 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다. divisor는 자연수입니다. array는 길이 1 이상인 배열입니다. 입출력 예 arr divisor return [5, 9, 7, 10] 5 [5, 10] [2, 36, 1, 3] 1 [1, 2, 3, 36] [3,2,6] 10 [-1] 입출력 예 설명입출력 예#1\\arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다. 따라서 [5, 10]을 리턴합니다. 입출력 예#2\\arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다. 입출력 예#3\\3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다. 풀이 javascript1234function solution(arr, divisor) { arr = arr.filter(a=&gt;a%divisor === 0) return arr.length? arr.sort((a,b)=&gt;a-b) : [-1]} 설명 % 연산을 통해 나누어 떨어지는 값을 구하고 정렬을 하면 된다.","link":"/2021/08/04/a91f47434df7/"},{"title":"[프로그래머스] (LV1) 내적","text":"내적JavaScript 문제 설명길이가 같은 두 1차원 정수 배열 a, b가 매개변수로 주어집니다. a와 b의 내적을 return 하도록 solution 함수를 완성해주세요. 이때, a와 b의 내적은 a[0]*b[0] + a[1]*b[1] + ... + a[n-1]*b[n-1] 입니다. (n은 a, b의 길이) 제한사항 a, b의 길이는 1 이상 1,000 이하입니다. a, b의 모든 수는 -1,000 이상 1,000 이하입니다. 입출력 예 a b result [1,2,3,4] [-3,-1,0,2] 3 [-1,0,1] [1,0,-1] -2 입출력 예 설명입출력 예 #1 a와 b의 내적은 1*(-3) + 2*(-1) + 3*0 + 4*2 = 3 입니다. 입출력 예 #2 a와 b의 내적은 (-1)*1 + 0*0 + 1*(-1) = -2 입니다. 풀이 python12def solution(a, b): return sum([ x*y for x,y in zip(a, b)]) javascript1234function solution(a, b) { var index = 0; return a.reduce((sum_,a_)=&gt;sum_+=a_*b[index++],0)} 설명 구현 능력(피지컬)을 묻는 문제. 두 배열에서 같은 인덱스를 가지는 원소 값들을 서로 곱해서 반납하면 된다.","link":"/2021/08/04/5ab78b48f0cb/"},{"title":"[프로그래머스] (LV1) 다트게임","text":"다트 게임JavaScript, Python 문제 설명 카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~ 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다.\\갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다. 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다. 옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다. 스타상(*)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(*)의 점수만 2배가 된다. (예제 4번 참고) 스타상(*)의 효과는 다른 스타상(*)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고) 스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고) Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다. 스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다. 0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라. 입력 형식“점수|보너스|[옵션]”으로 이루어진 문자열 3세트.\\예) 1S2D*3T 점수는 0에서 10 사이의 정수이다. 보너스는 S, D, T 중 하나이다. 옵선은 *이나 # 중 하나이며, 없을 수도 있다. 출력 형식3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.\\예) 37 입출력 예제 예제 dartResult answer 설명 1 1S2D*3T 37 11 2 + 22 2 + 33 2 1D2S#10S 9 12 + 21 * (-1) + 101 3 1D2S0T 3 12 + 21 + 03 4 1S*2T*3S 23 11 2 2 + 23 * 2 + 31 5 1D#2S*3S 5 12 (-1) 2 + 21 * 2 + 31 6 1T2D3D# -4 13 + 22 + 32 * (-1) 7 1D2S3T* 59 12 + 21 2 + 33 2 해설 보러가기 풀이 javascript12345678910111213141516171819202122232425262728293031function solution(dartResult) { var words = [], word = '', answer = []; dartResult.split(/(\\d+)/).forEach((d)=&gt;{ if(!isNaN(d*1) &amp;&amp; word){ words.push(word) word = d }else if(d !== '') word += d }) words.push(word); words.forEach((a,i)=&gt;{ var s = a.split(/(\\d+)/) var num = s[1]*1, bonus = s[2][0], option = s[2].length === 2? s[2][1] : null answer.push(Math.pow(num,bonus === 'S'? 1 : (bonus==='D' ? 2 : 3))) if(option === '*'){ answer[i] *= 2 if(i !== 0) answer[i-1] *= 2 } else if (option === '#') answer[i] *= -1 }) return answer.reduce((sum,cur)=&gt;sum+cur,0);} 정규표현식 풀이 (javascript)1234567891011121314151617function solution(dartResult) { const bonus = { 'S': 1, 'D': 2, 'T': 3 }, options = { '*': 2, '#': -1, undefined: 1 }; let darts = dartResult.match(/\\d.?\\D/g); for (let i = 0; i &lt; darts.length; i++) { let split = darts[i].match(/(^\\d{1,})(S|D|T)(\\*|#)?/), score = Math.pow(split[1], bonus[split[2]]) * options[split[3]]; if (split[3] === '*' &amp;&amp; darts[i - 1]) darts[i - 1] *= options['*']; darts[i] = score; } return darts.reduce((a, b) =&gt; a + b);} python12345678910import redef solution(dartResult): point_bonus = {'S':1, 'D':2, 'T':3} point_option = {'':1,'*':2,'#':-1} p = re.findall('(\\d+)([SDT])([*#]?)',dartResult) for i, v in enumerate(p): if v[2] == '*' and i &gt; 0: p[i-1] *= 2 p[i] = int(v[0]) ** point_bonus[v[1]] * point_option[v[2]] return sum(p) 설명 심심찮게 출제되는 문자열 문제다. 정규표현식 을 활용하면 매우 간단히 문제를 풀 수 있다. 또한 딕셔너리를 활용하면 코드 길이를 줄일 수 있다.","link":"/2021/08/04/b74ddfbefce8/"},{"title":"[프로그래머스] (LV1) 두 개 뽑아서 더하기","text":"두 개 뽑아서 더하기Python3 문제 설명정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers의 길이는 2 이상 100 이하입니다. numbers의 모든 수는 0 이상 100 이하입니다. 입출력 예 numbers result [2,1,3,4,1] [2,3,4,5,6,7] [5,0,2,7] [2,5,7,9,12] 입출력 예 설명입출력 예 #1 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다. 4 = 1 + 3 입니다. 5 = 1 + 4 = 2 + 3 입니다. 6 = 2 + 4 입니다. 7 = 3 + 4 입니다. 따라서 [2,3,4,5,6,7] 을 return 해야 합니다. 입출력 예 #2 2 = 0 + 2 입니다. 5 = 5 + 0 입니다. 7 = 0 + 7 = 5 + 2 입니다. 9 = 2 + 7 입니다. 12 = 5 + 7 입니다. 따라서 [2,5,7,9,12] 를 return 해야 합니다. 풀이 python12345678910def solution(numbers): answer = [] for i in range(len(numbers)): for j in range(len(numbers)): if i != j : value = numbers[i] + numbers[j]; if value not in answer: answer.append(value); answer.sort(); return answer 설명 두 번의 반복문을 돌며 배열의 다른 값의 합을 넣으면 된다.","link":"/2021/08/04/6cb7b325dd3b/"},{"title":"[프로그래머스] (LV1) 두 정수 사이의 합","text":"두 정수 사이의 합JavaScript, Python3 문제 설명두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.\\예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다. 제한 조건 a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요. a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다. a와 b의 대소관계는 정해져있지 않습니다. 입출력 예 a b return 3 5 12 3 3 3 5 3 12 풀이 javascript1234function solution(a, b) { var max = a&gt;b ? a: b, min = a&gt;b ? b : a; return max*(max+1)/2 - ((min-1)*min/2)} python12def solution(a, b): return sum(range(min(a,b),max(a,b)+1)) 설명 python에서는 range를 활용하면 간단히 풀 수 있다. 그 외에도 \\displaystyle \\sum_{k=1}^n k = \\frac{n(n+1)}{2}를 이용해 풀 수 있다.","link":"/2021/08/04/4a0c1f396dde/"},{"title":"[프로그래머스] (LV1) 로또의 최고 순위와 최저 순위","text":"로또의 최고 순위와 최저 순위JavaScript, Python 문제 설명로또 6/45(이하 ‘로또’로 표기)는 1부터 45까지의 숫자 중 6개를 찍어서 맞히는 대표적인 복권입니다. 아래는 로또의 순위를 정하는 방식입니다. 1 순위 당첨 내용 1 6개 번호가 모두 일치 2 5개 번호가 일치 3 4개 번호가 일치 4 3개 번호가 일치 5 2개 번호가 일치 6(낙첨) 그 외 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.\\알아볼 수 없는 번호를 0으로 표기하기로 하고, 민우가 구매한 로또 번호 6개가 44, 1, 0, 0, 31 25라고 가정해보겠습니다. 당첨 번호 6개가 31, 10, 45, 1, 6, 19라면, 당첨 가능한 최고 순위와 최저 순위의 한 예는 아래와 같습니다. 당첨 번호 31 10 45 1 6 19 결과 최고 순위 번호 31 0→10 44 1 0→6 25 4개 번호 일치, 3등 최저 순위 번호 31 0→11 44 1 0→7 25 2개 번호 일치, 5등 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다. 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다. 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다. 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다. 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다. 민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요. 제한사항 lottos는 길이 6인 정수 배열입니다. lottos의 모든 원소는 0 이상 45 이하인 정수입니다. 0은 알아볼 수 없는 숫자를 의미합니다. 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다. lottos의 원소들은 정렬되어 있지 않을 수도 있습니다. win_nums은 길이 6인 정수 배열입니다. win_nums의 모든 원소는 1 이상 45 이하인 정수입니다. win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다. win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다. 입출력 예 lottos win_nums result [44, 1, 0, 0, 31, 25] [31, 10, 45, 1, 6, 19] [3, 5] [0, 0, 0, 0, 0, 0] [38, 19, 20, 40, 15, 25] [1, 6] [45, 4, 35, 20, 3, 9] [20, 9, 3, 45, 4, 35] [1, 1] 입출력 예 설명입출력 예 #1\\문제 예시와 같습니다. 입출력 예 #2\\알아볼 수 없는 번호들이 아래와 같았다면, 1등과 6등에 당첨될 수 있습니다. 당첨 번호 20 9 3 45 4 35 결과 최고 순위 번호 0→20 0→9 0→3 0→45 0→4 0→35 6개 번호 일치, 1등 최저 순위 번호 0→21 0→22 0→23 0→24 0→25 0→26 0개 번호 일치, 6등 입출력 예 #3\\민우가 구매한 로또의 번호와 당첨 번호가 모두 일치하므로, 최고 순위와 최저 순위는 모두 1등입니다. 실제로 사용되는 로또 순위의 결정 방식과는 약간 다르지만, 이 문제에서는 지문에 명시된 대로 로또 순위를 결정하도록 합니다. ↩ 풀이 javascript123456789101112131415161718192021222324function solution(lottos, win_nums) { var count = 0 var empty = 0 lottos.forEach((l)=&gt;{ if(l === 0) empty++; else if(win_nums.includes(l)) count++; }) function calcRank(c){ switch(c){ case 6: return 1 case 5: return 2 case 4: return 3 case 3: return 4 case 2: return 5 default: return 6 } } return [calcRank(count+empty),calcRank(count)];} python1234567891011def solution(lottos, win_nums): z = 0 r = 0 for l in lottos: if l == 0: z+=1 elif l in win_nums: r+=1 answer = [7-(r+z) if r+z&gt;1 else 6, 7-(r) if r&gt;1 else 6] return answer 설명 배열을 이용해 풀 수 있는 간단한 문제다. switch 말고도 7에서 당첨 개수를 빼서 순위를 책정할 수 있다.","link":"/2021/08/04/47fb502358bd/"},{"title":"[프로그래머스] (LV1) 모음 사전","text":"Python3 문제 설명사전에 알파벳 모음 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 “A”이고, 그다음은 “AA”이며, 마지막 단어는 “UUUUU”입니다. 단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요. 제한사항 word의 길이는 1 이상 5 이하입니다. word는 알파벳 대문자 ‘A’, ‘E’, ‘I’, ‘O’, ‘U’로만 이루어져 있습니다. 입출력 예 word result &quot;AAAAE&quot; 6 &quot;AAAE&quot; 10 &quot;I&quot; 1563 &quot;EIO&quot; 1189 입출력 예 설명입출력 예 #1 사전에서 첫 번째 단어는 “A”이고, 그다음은 “AA”, “AAA”, “AAAA”, “AAAAA”, “AAAAE”, … 와 같습니다. “AAAAE”는 사전에서 6번째 단어입니다. 입출력 예 #2 “AAAE”는 “A”, “AA”, “AAA”, “AAAA”, “AAAAA”, “AAAAE”, “AAAAI”, “AAAAO”, “AAAAU”의 다음인 10번째 단어입니다. 입출력 예 #3 “I”는 1563번째 단어입니다. 입출력 예 #4 “EIO”는 1189번째 단어입니다. 풀이 python12345678910111213def solution(word): basic = list('AEIOU') book = set(basic) temp = [] for i in range(4): for word_ in book: for apb in basic: temp.append(word_+apb) book.update(temp) temp=[] return sorted(list(book)).index(word) + 1 설명 복잡하게 생각하면 오히려 난이도가 높아지는 문제다. 나도 처음에는 단어가 배열되는 규칙을 찾아 값이 나오는 함수를 구현하려 했는데, 문득 수학 문제를 풀고있는 것이 아닌가란 생각이 들었다. 코딩 문제란 것을 잊지 않으면, 사전 자체를 만들어버리는 생각을 떠올리는 것은 간단하다. 사전 단어들은 기존 단어에 A E I O U의 모음 단어 하나씩 오른쪽에 더하는 과정을 4번 반복하면 된다.","link":"/2021/08/30/ef36d4eaefde/"},{"title":"[프로그래머스] (LV1) 모의고사","text":"모의고사JavaScript, Python 문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …\\2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …\\3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다. 풀이 python1234567891011def solution(answers): rank = [0,0,0] patterns = ([1,2,3,4,5], [2,1,2,3,2,4,2,5], [3,3,1,1,2,2,4,4,5,5]) for i,v in enumerate(answers): for j in range(3): p = patterns[j] if p[i % len(p)] == v: rank[j]+=1 return [i+1 for i in range(3) if rank[i] == max(rank)] javascript12345678910111213141516171819202122function solution(answers) { var first = (i) =&gt; i%5 +1 var second = (i) =&gt; i%2 === 0 ? 2 : [1,3,4,5][((i-1)/2)%4] var third = (i) =&gt; [3,1,2,4,5][Math.floor(i/2)%5] var rights = [0,0,0] var answer = [] for(let i in answers){ const value = answers[i] if(value === first(i)) rights[0]++ if(value === second(i)) rights[1]++ if(value === third(i)) rights[2]++ } var max = Math.max(...rights) for(let i = 0 ; i &lt; 3 ; i++){ if(rights[i] === max) answer.push(i+1) } return answer;} 설명 반복되는 패턴을 어떻게 구현하는지 묻는 구현 문제다. 반복되는 패턴을 배열에 저장하여 풀 수 있다.","link":"/2021/08/04/6827b00d16a4/"},{"title":"[프로그래머스] (LV1) 문자열 내 p와 y의 개수","text":"문자열 내 p와 y의 개수JavaScript 문제 설명대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다. 예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다. 제한사항 문자열 s의 길이 : 50 이하의 자연수 문자열 s는 알파벳으로만 이루어져 있습니다. 입출력 예 s answer “pPoooyY” true “Pyy” false 입출력 예 설명입출력 예 #1\\‘p’의 개수 2개, ‘y’의 개수 2개로 같으므로 true를 return 합니다. 입출력 예 #2\\‘p’의 개수 1개, ‘y’의 개수 2개로 다르므로 false를 return 합니다. 풀이 javascript12345function solution(s){ const split_s = s.toLowerCase().split('') return split_s.filter((w)=&gt;w==='p').length === split_s.filter((w)=&gt;w==='y').length} 설명 toLowerCase, toUpperCase 함수와 filtering 문법을 활용하면 풀 수 있다.","link":"/2021/08/04/b71624f6b4eb/"},{"title":"[프로그래머스] (LV1) 문자열 내 마음대로 정렬하기","text":"문자열 내 마음대로 정렬하기JavaScript, Python3 문제 설명문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다. 제한 조건 strings는 길이 1 이상, 50이하인 배열입니다. strings의 원소는 소문자 알파벳으로 이루어져 있습니다. strings의 원소는 길이 1 이상, 100이하인 문자열입니다. 모든 strings의 원소의 길이는 n보다 큽니다. 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다. 입출력 예 strings n return [“sun”, “bed”, “car”] 1 [“car”, “bed”, “sun”] [“abce”, “abcd”, “cdx”] 2 [“abcd”, “abce”, “cdx”] 입출력 예 설명입출력 예 1\\“sun”, “bed”, “car”의 1번째 인덱스 값은 각각 “u”, “e”, “a” 입니다. 이를 기준으로 strings를 정렬하면 [“car”, “bed”, “sun”] 입니다. 입출력 예 2\\“abce”와 “abcd”, “cdx”의 2번째 인덱스 값은 “c”, “c”, “x”입니다. 따라서 정렬 후에는 “cdx”가 가장 뒤에 위치합니다. “abce”와 “abcd”는 사전순으로 정렬하면 “abcd”가 우선하므로, 답은 [“abcd”, “abce”, “cdx”] 입니다. 풀이 javascript123function solution(strings, n) { return strings.sort((a,b)=&gt;a[n]&gt;b[n] ? 1 : (a[n]&lt;b[n] ? -1 : (a&gt;b ? 1 : ( a===b ? 0 : -1))))} python12def solution(strings, n): return sorted(strings,key=lambda s:s[n]+s) 설명 lambda를 활용해 정렬을 구현하는 문제. n번째 글자가 같을 경우를 대비해 s를 뒤에 붙여 풀 수 있다. 단, 자바스크립틔 sort함수에서 문자열 a,b를 비교할때 단순히 뺄셈으로 계산할 수 없다는걸 주의해야 한다.","link":"/2021/08/04/932efb50a37a/"},{"title":"[프로그래머스] (LV1) 문자열 내림차순으로 배치하기","text":"문자열 내림차순으로 배치하기JavaScript, Python 문제 설명문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요.\\s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다. 제한 사항 str은 길이 1 이상인 문자열입니다. 입출력 예 s return “Zbcdefg” “gfedcbZ” 풀이 javascript123function solution(s) { return s.split('').sort().reverse().join('')} python12def solution(s): return ''.join(sorted(s,reverse=True)) 설명 언어의 정렬 문법을 활용할 수 있는지 물어보는 문제다.","link":"/2021/08/04/dce5c9d29cb8/"},{"title":"[프로그래머스] (LV1) 문자열 다루기 기본","text":"문자열 다루기 기본JavaScript, Python 문제 설명문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다. 제한 사항 s는 길이 1 이상, 길이 8 이하인 문자열입니다. 입출력 예 s return “a234” false “1234” 풀이 javascript123function solution(s) { return !s.split('').some((i)=&gt;isNaN(i*1)) &amp;&amp; [4,6].includes(s.length)} python12345678def solution(s): def isInt(str_): try : int(str_) return True except ValueError: return False return isInt(s) and (len(s) == 4 or len(s) == 6) 설명 문자열 다루기 피지컬을 요하는 문제다.","link":"/2021/08/04/2815502c9b7d/"},{"title":"[프로그래머스] (LV1) 문자열을 정수로 바꾸기","text":"문자열을 정수로 바꾸기JavaScript, Python 문제 설명문자열 s를 숫자로 변환한 결과를 반환하는 함수, solution을 완성하세요. 제한 조건 s의 길이는 1 이상 5이하입니다. s의 맨앞에는 부호(+, -)가 올 수 있습니다. s는 부호와 숫자로만 이루어져있습니다. s는 “0”으로 시작하지 않습니다. 입출력 예예를들어 str이 “1234”이면 1234를 반환하고, “-1234”이면 -1234를 반환하면 됩니다.\\str은 부호(+,-)와 숫자로만 구성되어 있고, 잘못된 값이 입력되는 경우는 없습니다. 풀이 javascript123function solution(s) { return s*1} python12def solution(s): return int(s) 설명 정수화(to int) 문제.","link":"/2021/08/04/c0fed9445917/"},{"title":"[프로그래머스] (LV1) 부족한 금액 계산하기","text":"부족한 금액 계산하기Python3 문제 설명 새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.\\놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.\\단, 금액이 부족하지 않으면 0을 return 하세요. 제한사항 놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수 처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수 놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수 입출력 예 price money count result 3 20 4 10 입출력 예 설명입출력 예 #1\\이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다. 풀이 python12def solution(price, money, count): return max(0, (price * count * (count+1) / 2) - money )","link":"/2021/08/16/ce5d6cfa269c/"},{"title":"[프로그래머스] (LV1) 비밀지도","text":"비밀지도JavaScript, Python 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 “지도 1”과 “지도 2”라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다. “지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다. 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라. 입력 형식입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다. 1 ≦ n ≦ 16 arr1, arr2는 길이 n인 정수 배열로 주어진다. 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다. 출력 형식원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라. 입출력 예제 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [&quot;#####&quot;,&quot;# # #&quot;, &quot;### #&quot;, &quot;# ##&quot;, &quot;#####&quot;] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [&quot;######&quot;, &quot;### #&quot;, &quot;## ##&quot;, &quot; #### &quot;, &quot; #####&quot;, &quot;### # &quot;] 해설 보러가기 풀이 javascript123function solution(n, arr1, arr2) { return arr1.map((a,i)=&gt;(a|arr2[i]).toString(2).padStart(n,0).replace(/0/g,' ').replace(/1/g,'#'))} python12def solution(n, arr1, arr2): return [ format(arr1[i] | arr2[i],'b').zfill(n).replace('1','#').replace('0',' ') for i in range(n)] 설명 bit 연산을 연습하기 좋은 문제다. 각 언어에서 binary 형태로 정수를 변환하는 문법을 연습할 수 있다. 참고 javascript 비트 연산자 padStart 함수 padEnd 함수","link":"/2021/08/04/2195fd129e8a/"},{"title":"[프로그래머스] (LV1) 서울에서 김서방 찾기","text":"서울에서 김서방 찾기JavaScript, Python 문제 설명String형 배열 seoul의 element중 “Kim”의 위치 x를 찾아, “김서방은 x에 있다”는 String을 반환하는 함수, solution을 완성하세요. seoul에 “Kim”은 오직 한 번만 나타나며 잘못된 값이 입력되는 경우는 없습니다. 제한 사항 seoul은 길이 1 이상, 1000 이하인 배열입니다. seoul의 원소는 길이 1 이상, 20 이하인 문자열입니다. “Kim”은 반드시 seoul 안에 포함되어 있습니다. 입출력 예 seoul return [“Jane”, “Kim”] “김서방은 1에 있다” 풀이 javascript123function solution(seoul) { return `김서방은 ${seoul.indexOf(&quot;Kim&quot;)}에 있다`;} python12def solution(seoul): return f&quot;김서방은 {seoul.index('Kim')}에 있다&quot; 설명 index finding을 묻는 기본 문제.","link":"/2021/08/04/5d20d74dd5c1/"},{"title":"[프로그래머스] (LV1) 소수 만들기","text":"소수 만들기JavaScript, Python 문제 설명주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다. nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다. 입출력 예 nums result [1,2,3,4] 1 [1,2,7,6,4] 4 입출력 예 설명입출력 예 #1\\[1,2,4]를 이용해서 7을 만들 수 있습니다. 입출력 예 #2\\[1,2,4]를 이용해서 7을 만들 수 있습니다.\\[1,4,6]을 이용해서 11을 만들 수 있습니다.\\[2,4,7]을 이용해서 13을 만들 수 있습니다.\\[4,6,7]을 이용해서 17을 만들 수 있습니다. 풀이 javascript1234567891011121314151617181920212223242526272829function solution(nums) { var answer = 0; function isPrime(n){ for(let i = 2, s= Math.sqrt(n); i &lt;= s; i++) if(n % i === 0) return false; return n &gt; 1; } function get(value,count,arr){ if(count === 2){ arr.forEach((a)=&gt;{ var currentValue = value+a if(isPrime(currentValue)){ answer++; } }) }else{ arr.forEach((a,i)=&gt;{ var newArr = JSON.parse(JSON.stringify(arr)).slice(i+1) get(value+a,count+1,newArr) }) } } get(0,0,nums); return answer;} python12345678910111213141516from itertools import combinationsdef solution(nums): answer = 0 def isPrime(n): if n &lt; 2: return False for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return False return True for v in list(combinations(nums, 3)): if isPrime(sum(v)): answer+=1; return answer 설명 BFS 방법으로 3개를 골라 소수 확인을 하면 된다. javascript 풀이는 재귀함수를 이용해 3번을 반복했다. python 풀이는 itertools 패키지의 combinations 함수를 사용해 조합을 구했다.","link":"/2021/08/04/f4ce7dc56d33/"},{"title":"[프로그래머스] (LV1) 소수 찾기","text":"소수 찾기JavaScript, Python 문제 설명1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.\\(1은 소수가 아닙니다.) 제한 조건 n은 2이상 1000000이하의 자연수입니다. 입출력 예 n result 10 4 5 3 입출력 예 설명입출력 예 #1\\1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환 입출력 예 #2\\1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환 풀이 javascript1234567891011121314function solution(n) { var answer = 0; const isPrime = (num) =&gt; { // 짝수는 판별할 필요가 없으므로 홀수만 진행 for(let i = 2; i &lt;= Math.sqrt(num); i === 2? i++ : i+=2) if(num % i === 0) return false; return true; } for(let i = 2; i &lt;= n; i++) if(isPrime(i)) answer++; return answer;} python12345678910def solution(n): # 짝수를 제외한 셋 num_set = set(range(3,n+1,2)) for i in range(3,n+1,2): if i in num_set: num_set -= set(range(2*i,n+1,i)) return len(num_set) + 1 # add '2' 설명 소수 확인 알고리즘을 1부터 n까지 반복하여 풀이한다.","link":"/2021/08/04/a9b1d54388ff/"},{"title":"[프로그래머스] (LV1) 수박수박수박수","text":"수박수박수박수박수박수?JavaScript, Python 문제 설명길이가 n이고, “수박수박수박수….”와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요. 예를들어 n이 4이면 “수박수박”을 리턴하고 3이라면 “수박수”를 리턴하면 됩니다. 제한 조건 n은 길이 10,000이하인 자연수입니다. 입출력 예 n return 3 “수박수” 4 “수박수박” 풀이 javascript123456function solution(n) { let answer = ''; for( let i = 0; i &lt; n; i++) answer += [&quot;수&quot;,&quot;박&quot;][i % 2] return answer} python12def solution(n): return (lambda s:s[:n]) ('수박'*n) 설명 반복되는 문자열의 인덱싱을 연습할 수 있는 문제다.","link":"/2021/08/04/290025cc5fda/"},{"title":"[프로그래머스] (LV1) 숫자 문자열과 영단어","text":"숫자 문자열과 영단어Python3 문제 설명 네오와 프로도가 숫자놀이를 하고 있습니다. 네오가 프로도에게 숫자를 건넬 때 일부 자릿수를 영단어로 바꾼 카드를 건네주면 프로도는 원래 숫자를 찾는 게임입니다. 다음은 숫자의 일부 자릿수를 영단어로 바꾸는 예시입니다. 1478 → “one4seveneight” 234567 → “23four5six7” 10203 → “1zerotwozero3” 이렇게 숫자의 일부 자릿수가 영단어로 바뀌어졌거나, 혹은 바뀌지 않고 그대로인 문자열 s가 매개변수로 주어집니다. s가 의미하는 원래 숫자를 return 하도록 solution 함수를 완성해주세요. 참고로 각 숫자에 대응되는 영단어는 다음 표와 같습니다. 숫자 영단어 0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 제한사항 1 ≤ s의 길이 ≤ 50 s가 “zero” 또는 “0”으로 시작하는 경우는 주어지지 않습니다. return 값이 1 이상 2,000,000,000 이하의 정수가 되는 올바른 입력만 s로 주어집니다. 입출력 예 s result &quot;one4seveneight&quot; 1478 &quot;23four5six7&quot; 234567 &quot;2three45sixseven&quot; 234567 &quot;123&quot; 123 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 문제 예시와 같습니다. 입출력 예 #3 “three”는 3, “six”는 6, “seven”은 7에 대응되기 때문에 정답은 입출력 예 #2와 같은 234567이 됩니다. 입출력 예 #2와 #3과 같이 같은 정답을 가리키는 문자열이 여러 가지가 나올 수 있습니다. 입출력 예 #4 s에는 영단어로 바뀐 부분이 없습니다. 제한시간 안내 정확성 테스트 : 10초 풀이 python12345def solution(s): numbers = {0:'zero',1:'one',2:'two',3:'three',4:'four',5:'five',6:'six',7:'seven',8:'eight',9:'nine'} for k,v in numbers.items(): s = s.replace(v,str(k)) return int(s) 설명 카카오 채용연계 인턴십에서 풀었던 첫 번째 문제. 문자열에서 영단어를 숫자로 변환하면 되는 간단한 문제다.","link":"/2021/07/13/1dd194db05c3/"},{"title":"[프로그래머스] (LV1) 시저 암호","text":"시저 암호JavaScript, Python 문제 설명어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요. 제한 조건 공백은 아무리 밀어도 공백입니다. s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다. s의 길이는 8000이하입니다. n은 1 이상, 25이하인 자연수입니다. 입출력 예 s n result “AB” 1 “BC” “z” 1 “a” “a B z” 4 “e F d” 풀이 javascript12345678function solution(s, n) { const wordSet = 'abcdefghijklmnopqrstuvwxyz' const upperSet = wordSet.toUpperCase() return s.split('').map((c)=&gt;{ const set = c.toLowerCase() === c ? wordSet : upperSet return c === ' ' ? c : set[(set.indexOf(c) + n) % set.length] }).join('')} python123456789101112def solution(s, n): small = 'abcdefghijklmnopqrstuvwxyz' big = small.upper() answer = '' for c in s: if c in small: answer += small[(small.find(c)+n) % len(small)] elif c in big: answer += big[(big.find(c)+n) % len(big)] else: answer += c return answer 설명 문자열의 인덱싱 능력을 묻는 피지컬 문제다. upper case set과 lower case set을 따로 두고 인덱싱을 활용해 풀면 된다.","link":"/2021/08/04/88922836dc26/"},{"title":"[프로그래머스] (LV1) 신규 아이디 추천","text":"신규 아이디 추천Python3 문제 설명카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.\\다음은 카카오 아이디의 규칙입니다. 아이디의 길이는 3자 이상 15자 이하여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다. 단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다. “네오”는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.\\신규 유저가 입력한 아이디가 new_id 라고 한다면, 123456781단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.4단계 new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.5단계 new_id가 빈 문자열이라면, new_id에 &quot;a&quot;를 대입합니다.6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다. 예를 들어, new_id 값이 “…!@BaT#*..y.abcdefghijklm” 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다. 1단계 대문자 ‘B’와 ‘T’가 소문자 ‘b’와 ‘t’로 바뀌었습니다.\\&quot;...!@BaT#*..y.abcdefghijklm&quot; → &quot;...!@bat#*..y.abcdefghijklm&quot; 2단계 ‘!’, ‘@’, ‘#’, ‘‘ 문자가 제거되었습니다.\\`”…!@bat#..y.abcdefghijklm”→“…bat..y.abcdefghijklm”` 3단계 ‘…’와 ‘..’ 가 ‘.’로 바뀌었습니다.\\&quot;...bat..y.abcdefghijklm&quot; → &quot;.bat.y.abcdefghijklm&quot; 4단계 아이디의 처음에 위치한 ‘.’가 제거되었습니다.\\&quot;.bat.y.abcdefghijklm&quot; → &quot;bat.y.abcdefghijklm&quot; 5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.\\&quot;bat.y.abcdefghijklm&quot; → &quot;bat.y.abcdefghijklm&quot; 6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.\\&quot;bat.y.abcdefghijklm&quot; → &quot;bat.y.abcdefghi&quot; 7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.\\&quot;bat.y.abcdefghi&quot; → &quot;bat.y.abcdefghi&quot; 따라서 신규 유저가 입력한 new_id가 “…!@BaT#*..y.abcdefghijklm”일 때, 네오의 프로그램이 추천하는 새로운 아이디는 “bat.y.abcdefghi” 입니다. [문제]신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요. [제한사항]newid는 길이 1 이상 1,000 이하인 문자열입니다.\\new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.\\new_id에 나타날 수 있는 특수문자는 `-.~!@#$%^&amp;*()=+[{]}:?,&lt;&gt;/` 로 한정됩니다. [입출력 예] no new_id result 예1 &quot;...!@BaT#*..y.abcdefghijklm&quot; &quot;bat.y.abcdefghi&quot; 예2 &quot;z-+.^.&quot; &quot;z--&quot; 예3 &quot;=.=&quot; &quot;aaa&quot; 예4 &quot;123_.def&quot; &quot;123_.def&quot; 예5 &quot;abcdefghijklmn.p&quot; &quot;abcdefghijklmn&quot; 입출력 예에 대한 설명 입출력 예 #1\\문제의 예시와 같습니다. 입출력 예 #2\\7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다.\\2단계 &quot;z-+.^.&quot; → &quot;z-..&quot;\\3단계 &quot;z-..&quot; → &quot;z-.&quot;\\4단계 &quot;z-.&quot; → &quot;z-&quot;\\5단계 변화 없습니다.\\6단계 변화 없습니다.\\7단계 &quot;z-&quot; → &quot;z--&quot; 입출력 예 #3\\7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다.\\2단계 &quot;=.=&quot; → &quot;.&quot;\\3단계 변화 없습니다.\\4단계 &quot;.&quot; → &quot;&quot; (new_id가 빈 문자열이 되었습니다.)\\5단계 &quot;&quot; → &quot;a&quot;\\6단계 변화 없습니다.\\7단계 &quot;a&quot; → &quot;aaa&quot; 입출력 예 #4\\1단계에서 7단계까지 거치는 동안 newid(“123.def”)는 변하지 않습니다. 즉, new_id가 처음부터 카카오의 아이디 규칙에 맞습니다. 입출력 예 #5\\1단계 변화 없습니다.\\2단계 변화 없습니다.\\3단계 변화 없습니다.\\4단계 변화 없습니다.\\5단계 변화 없습니다.\\6단계 &quot;abcdefghijklmn.p&quot; → &quot;abcdefghijklmn.&quot; → &quot;abcdefghijklmn&quot;\\7단계 변화 없습니다. 풀이 python123456789101112131415161718192021222324from re import subdef solution(new_id): str = new_id str = str.lower() str = sub(&quot;[^a-z0-9-_.]&quot;,&quot;&quot;,str) str = sub(&quot;\\.+&quot;,&quot;.&quot;,str) if len(str) &gt; 0 and str[0] == '.': str = str[1:] if len(str) &gt; 0 and str[-1] == '.': str = str[:-1] str = str if str != '' else 'a' if len(str) &gt;= 16: str = str[:15] if str[14] != '.' else str[:14] if len(str) &lt;= 2: while len(str) &lt;= 2: str = str + str[-1] return str 설명 7단계를 나누어 풀이하는 구현 문제다.","link":"/2021/08/04/a99c53b33282/"},{"title":"[프로그래머스] (LV1) 실패율","text":"실패율JavaScript, Python 문제 설명 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라. 제한사항 스테이지의 개수 N은 1 이상 500 이하의 자연수이다. stages의 길이는 1 이상 200,000 이하이다. stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다. 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다. 입출력 예 N stages result 5 [2, 1, 2, 6, 2, 4, 3, 3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 입출력 예 설명입출력 예 #1\\1번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다. 1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다. 3 번 스테이지 실패율 : 2/4 4번 스테이지 실패율 : 1/2 5번 스테이지 실패율 : 0/1 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다. [3,4,2,1,5] 입출력 예 #2 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다. [4,1,2,3] 풀이 javascript1234567891011121314151617function solution(N, stages) { var dict = Array(N+1).fill(0); var answer = Array(N).fill(0) stages.forEach((a)=&gt;{ dict[a-1]++; }) dict.reverse().reduce((sum,cur,index)=&gt;{ sum += cur; if(N-index !== N) answer[N-index] = [sum === 0 ? 0 : cur/sum,N-index] return sum },0) return answer.sort((a,b)=&gt;b[0]-a[0]).map((a)=&gt;a[1]+1)} python123456789def solution(N, stages): p = [0]*N challenge = len(stages) for s in stages: if s != N+1: p[s-1]+=1 for i in range(N): p[i], challenge = (p[i]/challenge if challenge != 0 else 0, challenge-p[i]) return sorted(range(1,N+1), key=lambda k:p[k-1],reverse=True) 설명 lv1 치고는 다소 간단하지 않은 문제며, 구현 능력을 묻는다.","link":"/2021/08/04/f0fe79387717/"},{"title":"[프로그래머스] (LV1) 약수의 개수와 덧셈","text":"약수의 개수와 덧셈JavaScript, Python 문제 설명두 정수 left와 right가 매개변수로 주어집니다. left부터 right까지의 모든 수들 중에서, 약수의 개수가 짝수인 수는 더하고, 약수의 개수가 홀수인 수는 뺀 수를 return 하도록 solution 함수를 완성해주세요. 제한사항 1 ≤ left ≤ right ≤ 1,000 입출력 예 left right result 13 17 43 24 27 52 입출력 예 설명입출력 예 #1 다음 표는 13부터 17까지의 수들의 약수를 모두 나타낸 것입니다. 수 약수 약수의 개수 13 1, 13 2 14 1, 2, 7, 14 4 15 1, 3, 5, 15 4 16 1, 2, 4, 8, 16 5 17 1, 17 2 따라서, 13 + 14 + 15 - 16 + 17 = 43을 return 해야 합니다. 입출력 예 #2 다음 표는 24부터 27까지의 수들의 약수를 모두 나타낸 것입니다. 수 약수 약수의 개수 24 1, 2, 3, 4, 6, 8, 12, 24 8 25 1, 5, 25 3 26 1, 2, 13, 26 4 27 1, 3, 9, 27 4 따라서, 24 - 25 + 26 + 27 = 52를 return 해야 합니다. 풀이 javascript1234567891011121314151617function solution(left, right) { var answer = 0; function findDivisor(n){ let ans = 1; // n for(let i = 1 ; i &lt;= n/2 ; i++) if(n % i === 0) ans++; return n &gt; 1 ? ans : 1 } for(let i = left; i &lt;= right; i++){ let divisor = findDivisor(i) answer += (divisor % 2 === 0? i : -i) } return answer} python123456789101112def solution(left, right): def getDividerLen(n): counter = 0 for i in range(1,n+1): if n%i == 0: counter+=1 return counter answer = 0 for i in range(left, right+1): answer += (i if getDividerLen(i) % 2 == 0 else -i) return answer 설명 약수의 개수를 구하는 함수를 구현하여 이를 반복하며 계산한다.","link":"/2021/08/04/966f081474ec/"},{"title":"[프로그래머스] (LV1) 예산","text":"예산JavaScript, Python 문제 설명S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다. 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다. 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요. 제한사항 d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다. d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다. budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다. 입출력 예 d budget result [1,3,2,5,4] 9 3 [2,2,3,3] 10 4 입출력 예 설명입출력 예 #1\\각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다. 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다. 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다. 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다. 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다. 입출력 예 #2\\모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다. 풀이 javascript12345678910111213function solution(d, budget) { var answer = 0; /** javascript의 기본 sort()는 * 숫자 기준이 아닌 문자 기준으로 정렬된다 */ d.sort((a,b)=&gt;a-b) for(let d_ of d){ if(budget &gt;= d_){ budget-=d_ answer++; } else break; } return answer;} python123456789def solution(d, budget): answer = 0 for d_ in sorted(d): if budget &gt;= d_: budget -= d_ answer+=1 else: break return answer 설명 주어진 리스트를 오름차순 정렬하고, budget에서 차례대로 값을 빼 계산하면 된다. javascript에서는 기본 sort() 함수가 숫자 기준이 아닌 문자 기준으로 정렬되는 점을 주의해야 한다.","link":"/2021/08/04/7c5d667d3a05/"},{"title":"[프로그래머스] (LV1) 약수의 합","text":"약수의 합JavaScript, Python 문제 설명정수 n을 입력받아 n의 약수를 모두 더한 값을 리턴하는 함수, solution을 완성해주세요. 제한 사항 n은 0 이상 3000이하인 정수입니다. 입출력 예 n return 12 28 5 6 입출력 예 설명입출력 예 #1\\12의 약수는 1, 2, 3, 4, 6, 12입니다. 이를 모두 더하면 28입니다. 입출력 예 #2\\5의 약수는 1, 5입니다. 이를 모두 더하면 6입니다. 풀이 javascript1234567function solution(n) { var answer = 0; for(let i = 1; i &lt;= n; i++) if(n % i === 0) answer += i; return answer;} python12def solution(n): return sum([i for i in range(1,int(n/2)+1) if n % i == 0]) + n 설명 모든 약수(n % i == 0)를 구하는 간단한 문제다.","link":"/2021/08/04/dc56cfcac3fe/"},{"title":"[프로그래머스] (LV1) 완주하지 못한 선수","text":"완주하지 못한 선수Python3, Javascript 문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participant completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” 입출력 예 설명예제 #1\\“leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2\\“vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3\\“mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 풀이 python123456789def solution(participant, completion): completion.sort() participant.sort() for i in range(len(participant)): if i == len(participant) -1: return participant[-1] else: if participant[i] != completion[i]: return participant[i] javascript1234567891011121314151617181920function solution(participant, completion) { var answer var dictionary = {}; completion.forEach((name)=&gt;{ if(!dictionary[name]) dictionary[name] = 1 else dictionary[name] += 1; }) participant.forEach((name)=&gt;{ if(dictionary[name] &gt; 0) dictionary[name] -= 1; else{ answer = name } }) return answer;} 설명 기본적으로 해시 자료구조를 활용하여 풀 수 있는 문제다. 하지만 단 한명만 찾는 문제이므로 python 풀이처럼 창의적으로 풀 수 있다.","link":"/2021/08/04/98aea5d2db4f/"},{"title":"[프로그래머스] (LV1) 이상한 문자 만들기","text":"이상한 문자 만들기JavaScript, Python3 문제 설명문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요. 제한 사항 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다. 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다. 입출력 예 s return “try hello world” “TrY HeLlO WoRlD” 입출력 예 설명“try hello world”는 세 단어 “try”, “hello”, “world”로 구성되어 있습니다. 각 단어의 짝수번째 문자를 대문자로, 홀수번째 문자를 소문자로 바꾸면 “TrY”, “HeLlO”, “WoRlD”입니다. 따라서 “TrY HeLlO WoRlD” 를 리턴합니다. 풀이 javascript123function solution(s) { return s.split(' ').map((w)=&gt;w.split('').map((w_,i)=&gt; i%2===0?w_.toUpperCase():w_.toLowerCase()).join('')).join(' ')} python123def solution(s): cases = [lambda x:x.upper(), lambda x:x.lower()] return ' '.join([''.join([cases[i%2](x) for i,x in enumerate(s_)]) for s_ in s.split(' ')]) 설명 공백으로 구분된 문자열 안에서의 순서를 생각해야 하는게 포인트다. 공백으로 문자를 자르고, 순서상으로 계산 뒤 다시 공백으로 join 한다.","link":"/2021/08/04/12d9949a6d30/"},{"title":"[프로그래머스] (LV1) 자릿수 더하기","text":"자릿수 더하기JavaScript, Python 문제 설명자연수 N이 주어지면, N의 각 자릿수의 합을 구해서 return 하는 solution 함수를 만들어 주세요.\\예를들어 N = 123이면 1 + 2 + 3 = 6을 return 하면 됩니다. 제한사항 N의 범위 : 100,000,000 이하의 자연수 입출력 예 N answer 123 6 987 24 입출력 예 설명입출력 예 #1\\문제의 예시와 같습니다. 입출력 예 #2\\9 + 8 + 7 = 24이므로 24를 return 하면 됩니다. 풀이 javascript123function solution(n){ return (n+'').split('').reduce((a,b)=&gt;a*1+b*1,0)} python12def solution(n): return sum([int(i) for i in str(n)]) 설명 정수화(to int) 기본 문제.","link":"/2021/08/04/4dfb8b0b0d00/"},{"title":"[프로그래머스] (LV1) 음양 더하기","text":"음양 더하기JavaScript, Python 문제 설명어떤 정수들이 있습니다. 이 정수들의 절댓값을 차례대로 담은 정수 배열 absolutes와 이 정수들의 부호를 차례대로 담은 불리언 배열 signs가 매개변수로 주어집니다. 실제 정수들의 합을 구하여 return 하도록 solution 함수를 완성해주세요. 제한사항 absolutes의 길이는 1 이상 1,000 이하입니다. absolutes의 모든 수는 각각 1 이상 1,000 이하입니다. signs의 길이는 absolutes의 길이와 같습니다. signs[i] 가 참이면 absolutes[i] 의 실제 정수가 양수임을, 그렇지 않으면 음수임을 의미합니다. 입출력 예 absolutes signs result [4,7,12] [true,false,true] 9 [1,2,3] [false,false,true] 0 입출력 예 설명입출력 예 #1 signs가 [true,false,true] 이므로, 실제 수들의 값은 각각 4, -7, 12입니다. 따라서 세 수의 합인 9를 return 해야 합니다. 입출력 예 #2 signs가 [false,false,true] 이므로, 실제 수들의 값은 각각 -1, -2, 3입니다. 따라서 세 수의 합인 0을 return 해야 합니다. 풀이 javascript12345function solution(absolutes, signs) { var index = 0 return absolutes.reduce((sum,cur)=&gt; sum + (signs[index++]?1:-1) * cur,0)} python12def solution(absolutes, signs): return sum([a if b else -a for a,b in zip(absolutes,signs)]) 설명 언어의 기본 배열 문법 활용도를 묻는 문제다.","link":"/2021/08/04/e000159dee62/"},{"title":"[프로그래머스] (LV1) 자연수 뒤집어 배열로 만들기","text":"자연수 뒤집어 배열로 만들기JavaScript, Python 문제 설명자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열 형태로 리턴해주세요. 예를들어 n이 12345이면 [5,4,3,2,1]을 리턴합니다. 제한 조건 n은 10,000,000,000이하인 자연수입니다. 입출력 예 n return 12345 [5,4,3,2,1] 풀이 javascript123function solution(n) { return (n+'').split('').reverse().map((w)=&gt;w*1)} python12def solution(n): return list(map(int,reversed(str(n)))) 설명 사용 언어의 reverse 문법과 배열화를 요구하는 문제.","link":"/2021/08/04/3d0a83748415/"},{"title":"[프로그래머스] (LV1) 정수 내림차순으로 배치하기","text":"정수 내림차순으로 배치하기JavaScript, Python 문제 설명함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다. 제한 조건 n은 1이상 8000000000 이하인 자연수입니다. 입출력 예 n return 118372 873211 풀이 javascript123function solution(n) { return (n+'').split('').sort((a,b)=&gt;b-a).join('')*1} python12def solution(n): return int(''.join(sorted(str(n),reverse=True))) 설명 문자열의 배열화와 정렬을 요구하는 문제.","link":"/2021/08/04/3ddc1571025e/"},{"title":"[프로그래머스] (LV1) 정수 제곱근 판별","text":"정수 제곱근 판별JavaScript, Python 문제 설명임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다.\\n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요. 제한 사항 n은 1이상, 50000000000000 이하인 양의 정수입니다. 입출력 예 n return 121 144 3 -1 입출력 예 설명입출력 예#1\\121은 양의 정수 11의 제곱이므로, (11+1)를 제곱한 144를 리턴합니다. 입출력 예#2\\3은 양의 정수의 제곱이 아니므로, -1을 리턴합니다. 풀이 javascript1234function solution(n) { const sqrt = Math.sqrt(n) return sqrt === Math.floor(sqrt) ? Math.pow(sqrt+1,2) : -1} python12def solution(n): return (n**(1/2) + 1)**2 if (n**(1/2)) % 1 == 0 else -1 설명 거듭제곱과 제곱근을 표현할 수 있는지 요구하는 문제.","link":"/2021/08/04/4c3aaa5ac592/"},{"title":"[프로그래머스] (LV1) 제일 작은 수 제거하기","text":"제일 작은 수 제거하기JavaScript, Python 문제 설명정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다. 제한 조건 arr은 길이 1 이상인 배열입니다. 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다. 입출력 예 arr return [4,3,2,1] [4,3,2] [10] [-1] 풀이 javascript1234function solution(arr) { arr.splice(arr.indexOf(Math.min(...arr)),1) return arr.length ? arr : [-1];} python123def solution(arr): arr.remove(min(arr)) return arr if len(arr) &gt; 0 else [-1] 설명 배열의 최소값을 찾는 방법과 원소 제거를 묻는 문제.","link":"/2021/08/04/878e976003b6/"},{"title":"[프로그래머스] (LV1) 직사각형 별찍기","text":"직사각형 별찍기JavaScript 문제 설명이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다.\\별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요. 제한 조건 n과 m은 각각 1000 이하인 자연수입니다. 예시입력 15 3 출력 123*************** 풀이 javascript123456789101112process.stdin.setEncoding('utf8');process.stdin.on('data', data =&gt; { const n = data.split(&quot; &quot;); const a = Number(n[0]), b = Number(n[1]); var answer = '' for(let i = 0; i &lt; b; i++){ for(let j = 0; j &lt; a; j++) answer += '*' answer += '\\n' } console.log(answer)}); python123a, b = map(int, input().strip().split(' '))for i in range(1, b+1): print('*'*a) 설명 입출력을 요구하는 문제. python의 간결한 풀이를 느낄 수 있다.","link":"/2021/08/04/7251c3110aa9/"},{"title":"[프로그래머스] (LV1) 짝수와 홀수","text":"짝수와 홀수JavaScript, Python 문제 설명정수 num이 짝수일 경우 “Even”을 반환하고 홀수인 경우 “Odd”를 반환하는 함수, solution을 완성해주세요. 제한 조건 num은 int 범위의 정수입니다. 0은 짝수입니다. 입출력 예 num return 3 “Odd” 4 “Even” 풀이 javascript123function solution(num) { return [&quot;Even&quot;,&quot;Odd&quot;][Math.abs(num) % 2]} python12def solution(num): return [&quot;Even&quot;,&quot;Odd&quot;][num%2] 설명 짝수와 홀수의 매끄러운 표현을 연습할 수 있다.","link":"/2021/08/04/dd24d032d52b/"},{"title":"[프로그래머스] (LV1) 체육복","text":"체육복Python3 문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve return 5 [2, 4] [1, 3, 5] 5 5 [2, 4] [3] 4 3 [3] [1] 2 입출력 예 설명예제 #1\\1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #2\\3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 출처 ※ 공지 - 2019년 2월 18일 지문이 리뉴얼되었습니다.\\※ 공지 - 2019년 2월 27일, 28일 테스트케이스가 추가되었습니다. 풀이 python1234567891011121314def solution(n, lost, reserve): answer = 0 for idx, std in enumerate(tuple(lost)): if std in reserve: lost.remove(std) reserve.remove(std) elif std-1 in reserve: lost.remove(std) reserve.remove(std-1) elif (std+1 in reserve) and (std+1 not in lost): lost.remove(std) reserve.remove(std+1) answer = n-len(lost) return answer 설명 풀이 전략탐욕법을 사용하여 간단하게 해결할 수 있는 기본 문제다. 풀이 설명문제의 조건대로 lost의 배열을 조회하며 lost와 reserve를 수정한다. lost 배열의 반복문을 돌며 lost 배열을 수정하면 반복문에 문제가 생기므로 tuple을 통해 값을 복사하여 반복문을 시행해야 한다. 각 for문의 선택이 다른 선택에 관여하지 않으므로, 탐욕법 풀이가 가능한 문제다.","link":"/2021/07/22/63a696571dde/"},{"title":"[프로그래머스] (LV1) 최대공약수와 최소공배수","text":"최대공약수와 최소공배수JavaScript, Python 문제 설명두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다. 제한 사항 두 수는 1이상 1000000이하의 자연수입니다. 입출력 예 n m return 3 12 [3, 12] 2 5 [1, 10] 입출력 예 설명입출력 예 #1\\위의 설명과 같습니다. 입출력 예 #2\\자연수 2와 5의 최대공약수는 1, 최소공배수는 10이므로 [1, 10]을 리턴해야 합니다. 풀이 javascript1234567891011function solution(n, m) { let div = 1; let index = 2; while( !(index % n === 0 &amp;&amp; index % m === 0)){ if( index &lt;= n || index &lt;= m) if(n % index === 0 &amp;&amp; m % index === 0) div = index index++; } return [div,index]} python1234567891011def solution(n, m): max_ = 1 min_ = max(n,m) for i in range(1, max(n,m)+1): if n % i == 0 and m % i == 0 and i &gt; max_: max_ = i while True: if min_ % n == 0 and min_ % m == 0: return [max_,min_] min_ += max(n,m) 설명 최대 공약수와 최소 공배수를 구하는 문제.","link":"/2021/08/04/83f4e3b5ec17/"},{"title":"[프로그래머스] (LV1) 콜라츠 추측","text":"콜라츠 추측JavaScript, Python 문제 설명1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다. 1234&gt;1-1. 입력된 수가 짝수라면 2로 나눕니다.&gt;1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.&gt;2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 —1을 반환해 주세요. 제한 사항 입력된 수, num은 1 이상 8000000 미만인 정수입니다. 입출력 예 n result 6 8 16 4 626331 -1 입출력 예 설명입출력 예 #1\\문제의 설명과 같습니다. 입출력 예 #2\\16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 이되어 총 4번만에 1이 됩니다. 입출력 예 #3\\626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다. 풀이 javascript123456789101112131415function solution(num) { var answer = 0; while(num !== 1){ if(answer === 500) return -1 answer++; if(num % 2 === 0) num /= 2 else num = (3*num + 1) } return answer;} python123456789101112def solution(num): answer = 0 while answer &lt; 500: if num == 1: return answer if num % 2 == 0: num /= 2 else: num = num * 3 + 1 answer += 1 return -1 설명 문제의 요구사항을 코드로 구현할 수 있는지 평가하는 문제다.","link":"/2021/08/04/4546321b444a/"},{"title":"[프로그래머스] (LV1) 크레인 인형뽑기 게임","text":"크레인 인형뽑기 게임Python3 문제 설명게임개발자인 “죠르디”는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.\\“죠르디”는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다. 게임 화면은 “1 x 1” 크기의 칸들로 이루어진 “N x N” 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 “5 x 5” 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 “1 x 1” 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다. 크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음) 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요. [제한사항] board 배열은 2차원 배열로 크기는 “5 x 5” 이상 “30 x 30” 이하입니다. board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다. 0은 빈 칸을 나타냅니다. 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다. moves 배열의 크기는 1 이상 1,000 이하입니다. moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다. 입출력 예 board moves result [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4 입출력 예에 대한 설명입출력 예 #1 인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다. 풀이 python1234567891011121314def solution(board, moves): basket = [] answer = 0 for i in moves: for b in board: if b[i-1] != 0: if len(basket) == 0 or basket[-1] != b[i-1]: basket.append(b[i-1]) else: answer+=2 basket.pop() b[i-1] = 0 break; return answer 설명 기초적인 구현능력을 요구하는 기본적인 문제.","link":"/2021/08/04/3228039715dd/"},{"title":"[프로그래머스] (LV1) 키패드 누르기","text":"[카카오 인턴] 키패드 누르기JavaScript, Python 문제 설명스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다. 이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.\\맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다. 오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다. 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.\\4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다. 순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요. [제한사항] numbers 배열의 크기는 1 이상 1,000 이하입니다. numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다. hand는 &quot;left&quot; 또는 &quot;right&quot; 입니다. &quot;left&quot;는 왼손잡이, &quot;right&quot;는 오른손잡이를 의미합니다. 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요. 입출력 예 numbers hand result [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] &quot;right&quot; &quot;LRLLLRLLRRL&quot; [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] &quot;left&quot; &quot;LRLLRRLLLRR&quot; [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] &quot;right&quot; &quot;LLRLLRLLRL&quot; 입출력 예에 대한 설명입출력 예 #1 순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다. 왼손 위치 오른손 위치 눌러야 할 숫자 사용한 손 설명 * # 1 L 1은 왼손으로 누릅니다. 1 # 3 R 3은 오른손으로 누릅니다. 1 3 4 L 4는 왼손으로 누릅니다. 4 3 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 3 8 L 왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다. 8 3 2 R 왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다. 8 2 1 L 1은 왼손으로 누릅니다. 1 2 4 L 4는 왼손으로 누릅니다. 4 2 5 R 왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. 4 5 9 R 9는 오른손으로 누릅니다. 4 9 5 L 왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5 9 - - 따라서 &quot;LRLLLRLLRRL&quot;를 return 합니다. 입출력 예 #2 왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 &quot;LRLLRRLLLRR&quot;이 됩니다. 입출력 예 #3 오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 &quot;LLRLLRLLRL&quot;이 됩니다. 풀이 javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function solution(numbers, hand) { var answer = ''; var left = 10, right=12 function calcDist(n,h){ var num = n === 0? 11 : n, h_num = h === 0? 11 : h; var n_row = Math.floor((num-1)/3), h_row = Math.floor((h_num-1)/3) var n_col = (num-1) % 3, h_col = (h_num-1) % 3 return Math.abs(h_row - n_row) + Math.abs(h_col - n_col) } numbers.forEach((num)=&gt;{ if(num === 1 | num === 4 | num === 7){ answer += 'L' left = num } else if(num === 3 | num === 6 | num === 9){ answer += 'R' right = num } else{ var l_d = calcDist(num,left), r_d = calcDist(num,right) if(l_d &lt; r_d){ answer += 'L' left = num } else if (l_d &gt; r_d){ answer += 'R' right = num } else{ if(hand === 'left'){ answer += 'L' left = num }else{ answer += 'R' right = num } } } }) return answer} python1234567891011121314151617181920212223242526272829303132333435363738394041l = 10r = 12def solution(numbers, hand): l_n = [1,4,7] r_n = [3,6,9] def calc_length(h, n): return abs((h-1)%3 - (n-1)%3) + abs((h-1)//3 - (n-1)//3) def find_hand(n): global l global r if n == 0: n = 11 if n in l_n: l = n return 'L' elif n in r_n: r = n return 'R' else: lh = calc_length(l,n) rh = calc_length(r,n) if lh &lt; rh: l = n return 'L' elif lh &gt; rh: r = n return 'R' else: if hand == 'left': l = n return 'L' else: r = n return 'R' return ''.join(map(find_hand ,numbers)) 설명 LV1 문제 치고는 다소 까다로운 구현 문제다. 문제 요구사항의 핵심 부분은 거리 계산과","link":"/2021/08/04/96c1090e6be6/"},{"title":"[프로그래머스] (LV1) 평균 구하기","text":"평균 구하기JavaScript, Python 문제 설명정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요. 제한사항 arr은 길이 1 이상, 100 이하인 배열입니다. arr의 원소는 -10,000 이상 10,000 이하인 정수입니다. 입출력 예 arr return [1,2,3,4] 2.5 [5,5] 5 풀이 javascript123function solution(arr) { return arr.reduce((a,b)=&gt;a+b,0) / arr.length} python12def solution(arr): return sum(arr)/len(arr) 설명 기본 문법 구현능력을 묻는 문제.","link":"/2021/08/04/5dfc7194bace/"},{"title":"[프로그래머스] (LV1) 폰켓몬","text":"폰켓몬JavaScript, Python 문제 설명당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다.\\홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다. 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다. 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택 두 번째(1번), 세 번째(2번) 폰켓몬을 선택 두 번째(1번), 네 번째(3번) 폰켓몬을 선택 세 번째(2번), 네 번째(3번) 폰켓몬을 선택 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다. 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다.\\당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다. N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요. 제한사항 nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다. 입출력 예 nums result [3,1,2,3] 2 [3,3,3,2,2,4] 3 [3,3,3,2,2,2] 2 입출력 예 설명입출력 예 #1\\문제의 예시와 같습니다. 입출력 예 #2\\6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\\가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리, 2번 폰켓몬 한 마리, 4번 폰켓몬 한 마리를 고르면 되며, 따라서 3을 return 합니다. 입출력 예 #3\\6마리의 폰켓몬이 있으므로, 3마리의 폰켓몬을 골라야 합니다.\\가장 많은 종류의 폰켓몬을 고르기 위해서는 3번 폰켓몬 한 마리와 2번 폰켓몬 두 마리를 고르거나, 혹은 3번 폰켓몬 두 마리와 3번 폰켓몬 한 마리를 고르면 됩니다. 따라서 최대 고를 수 있는 폰켓몬 종류의 수는 2입니다. 풀이 javascript12345678910111213function solution(nums) { var answer = 0; const dict = {} nums.forEach((n)=&gt;{ if(!dict[n]){ dict[n]=true answer++; } }) return Math.min(nums.length/2,answer);} python12def solution(nums): return min(len(set(nums)), len(nums)/2) 설명 최대 종류 개수와 nums의 절반 중 최소 값을 반환하면 된다. 최대 종류 개수를 위해서는 set 자료구조를 이용한다.","link":"/2021/08/04/a0c0c53fcfa3/"},{"title":"[프로그래머스] (LV1) 하샤드 수","text":"하샤드 수JavaScript, Python 문제 설명양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요. 제한 조건 x는 1 이상, 10000 이하인 정수입니다. 입출력 예 arr return 10 true 12 true 11 false 13 false 입출력 예 설명입출력 예 #1\\10의 모든 자릿수의 합은 1입니다. 10은 1로 나누어 떨어지므로 10은 하샤드 수입니다. 입출력 예 #2\\12의 모든 자릿수의 합은 3입니다. 12는 3으로 나누어 떨어지므로 12는 하샤드 수입니다. 입출력 예 #3\\11의 모든 자릿수의 합은 2입니다. 11은 2로 나누어 떨어지지 않으므로 11는 하샤드 수가 아닙니다. 입출력 예 #4\\13의 모든 자릿수의 합은 4입니다. 13은 4로 나누어 떨어지지 않으므로 13은 하샤드 수가 아닙니다. 풀이 javascript123function solution(x) { return x % (x+'').split('').reduce((a,b)=&gt;a*1+b*1,0) === 0} python12def solution(x): return x % sum(map(int,str(x))) == 0 설명 숫자를 문자열을 나누고, 이를 다시 정수형으로 변환하여 자릿수 합을 구한다. 이를 원래 값에 나누어 정답 결과를 반환한다.","link":"/2021/08/04/a35ac8d3f93b/"},{"title":"[프로그래머스] (LV1) 핸드폰 번호 가리기","text":"핸드폰 번호 가리기JavaScript, Python 문제 설명프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다.\\전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요. 제한 조건 s는 길이 4 이상, 20이하인 문자열입니다. 입출력 예 phone_number return “01033334444” “*4444” “027778888” “*8888” 풀이 javascript123function solution(phone_number) { return phone_number.split('').reverse().map((n,i)=&gt;i&lt;4?n:'*').reverse().join('')} python12def solution(phone_number): return '*'*(len(phone_number)-4) + phone_number[-4:] 설명 문자열 반복 구현 방법을 묻는 문제.","link":"/2021/08/04/5106f0ee5223/"},{"title":"[프로그래머스] (LV1) 행렬의 덧셈","text":"행렬의 덧셈JavaScript, Python 문제 설명행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요. 제한 조건 행렬 arr1, arr2의 행과 열의 길이는 500을 넘지 않습니다. 입출력 예 arr1 arr2 return [[1,2],[2,3]] [[3,4],[5,6]] [[4,6],[7,9]] [[1],[2]] [[3],[4]] [[4],[6]] 풀이 javascript123function solution(arr1, arr2) { return arr1.map((a1,i)=&gt;a1.map((a1_,i_)=&gt;a1_+arr2[i][i_]))} python12def solution(arr1, arr2): return [ [c+d for c,d in zip(a,b)] for a, b in zip(arr1,arr2)] 설명 두 배열의 연산 능력을 묻는 문제.","link":"/2021/08/04/6c54e9ab7bc7/"},{"title":"[프로그래머스] (LV4) 도둑질","text":"도둑질Python3 문제 설명도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다. 각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요. 제한사항 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다. money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다. 입출력 예 money return [1, 2, 3, 1] 4 풀이 python123456789101112131415def solution(money): f = [0] * len(money) f[0] = f[1] = money[0] for i in range(2, len(money)-1): f[i] = max(f[i-2] + money[i], f[i-1]) s = [0] * len(money) s[1] = money[1] for i in range(2, len(money)): s[i] = max(s[i-2] + money[i], s[i-1]) return max(f+s) 설명 동적계획법(Dynamic Programming) 유형의 꽤나 깊은 생각을 요하는 문제다. 반복문을 돌며 현재 집을 기준으로 지난 집들의 최댓값을 누적시키는 것이 포인트다. 여기까지는 기본적인 DP의 유형을 따르지만, 첫 번째 집이 선택되는 경우와 그렇지 못한 경우에 따라 마지막 집을 선택할 수 있는지에대한 여부가 갈리기 때문에 이를 신경 쓰는 과정에서 다소 시간이 걸렸다. 또한, 직전 집의 최댓값을 바로 다음 인덱스의 집에서도 적용할 수 있다는 생각은 처음에 떠오르지 않았다. 몇 번의 시행착오를 거듭한 끝에 답을 구할 수 있었고, 아이러니하게도 풀이를 계속 고민할 수록 코드의 길이는 짧아졌다. DP는 풀이에 도달하기 까지 깊은 생각을 요하지만, 막상 풀이는 매우 짧고 간결한 것 같다. 무언가 DP 유형의 문제를 풀면서 풀이가 지저분하게 길어지고 있다면, 현재 문제를 잘못 접근하고 있다는 생각을 할 필요가 있다.","link":"/2021/07/13/f77dc2a7284a/"},{"title":"[타입스크립트] 타입스크립트의 기본 타입","text":"💡 tl;dr 지원 타입 목록 타입 선언 (Type Declaration) 타입 추론 (Type Inference) 타입 단언 (Type Assertions) 타입 가드 (Type Guards) 지원 타입 목록 Typescript는 Javascript의 타입 외에도 고유의 타입이 추가로 제공된다. Type JS TS Description boolean ✅ ✅ true와 false null ✅ ✅ 값이 없다는 것을 명시 undefined ✅ ✅ 값을 할당하지 않은 변수의 초기값 number ✅ ✅ 숫자(정수와 실수, Infinity, NaN) string ✅ ✅ 문자열 symbol ✅ ✅ 고유하고 수정 불가능한 데이터 타입이며 주로 객체 프로퍼티들의 식별자로 사용(ES6에서 추가) object ✅ ✅ 객체형(참조형) array ✅ 배열 tuple ✅ 고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현 enum ✅ 열거형. 숫자값 집합에 이름을 지정한 것 any ✅ 타입 추론(type inference)할 수 없거나 타입 체크가 필요없는 변수에 사용, var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능 void ✅ 일반적으로 함수에서 반환값이 없을 경우 사용 never ✅ 결코 발생하지 않는 값 타입 선언 (Type Declaration) 타입스크립트는 일반 변수, 매개 변수(Parameter), 객체 속성(Property) 등에 : TYPE과 같은 형태로 타입을 지정할 수 있다. TypeScript는 JavaScript의 모든 데이터 타입을 허용한다. 원시 타입 (primitive type) 123let foo_s: string = 'text' // 문자열let foo_n: number = 0; // 숫자형let foo_b: boolean = true; // 논리형 이 때 만약 지정된 타입이 아닌 다른 타입의 데이터를 할당하려고 시도하면 에러를 발생한다. 123456// 문자열로 선언하고 숫자를 대입하면 에러 발생let foo_s: string = 0; // error// 숫자값이 들어가고 이후에 문자열을 대입하면 에러 발생let foo_n: number = 1;foo_n = 'text'; // error Type 'text' is not assignable to type 'number'. 배열 (Array) 배열은 다음과 같이 두 가지 방법으로 타입을 선언할 수 있다. 1let list: number[] = [1, 2, 3]; 1let list: Array&lt;number&gt; = [1, 2, 3]; 튜플 (Tuple) 튜플 타입을 사용하면, 요소의 타입과 개수가 고정된 배열을 표현할 수 있다. 요소들의 타입이 모두 같을 필요는 없다 1234567891011121314151617// 튜플 타입으로 선언let x: [string, number];// 초기화x = [&quot;hello&quot;, 10]; // 성공// 잘못된 초기화x = [10, &quot;hello&quot;]; // 오류// 정해진 인덱스에 위치한 요소에 접근하면 해당 타입이 나타난다.console.log(x[0].substring(1)); // 성공console.log(x[1].substring(1)); // 오류, 'number'에는 'substring' 이 없다.// 정해진 인덱스 외에 다른 인덱스에 있는 요소에 접근하면, 오류가 발생하며 실패한다.x[3] = &quot;world&quot;; // 오류, '[string, number]' 타입에는 프로퍼티 '3'이 없다.console.log(x[5].toString()); // '[string, number]' 타입에는 프로퍼티 '5'가 없다. 열거형 (Enum) 열거형(enum)은 숫자값 집합에 이름을 지정한 것이다. 1234567891011121314enum Color1 {Red, Green, Blue};let c1: Color1 = Color1.Green;console.log(c1); // 1enum Color2 {Red = 1, Green, Blue};let c2: Color2 = Color2.Green;console.log(c2); // 2enum Color3 {Red = 1, Green = 2, Blue = 4};let c3: Color3 = Color3.Blue;console.log(c3); // 4 모든 타입 (Any) Any는 모든 타입을 의미한다. 일반적인 자바스크립트 변수와 동일하게 어떤 타입의 값도 할당할 수 있다. 외부 자원을 활용해 개발할 때 불가피하게 타입을 단언할 수 없는 경우, 유용할 수 있다. 1234567let any: any = 123;any = 'Hello world';any = {};any = null;// 다양한 값을 포함하는 배열을 나타낼 때에도 사용 가능const list: anyArray[] = [1, true, 'Anything!']; 강한 타입 시스템의 장점을 유지하기 위해 Any 사용을 엄격하게 금지하려면, 컴파일 옵션 &quot;noImplicitAny&quot;: true를 통해 Any 사용 시 에러를 발생시킬 수 있다. 알 수 없는 타입 (Unknown) Any와 같이 최상위 타입인 Unknown은 알 수 없는 타입을 의미한다. Any와 같이 Unknown에는 어떤 타입의 값도 할당할 수 있지만, Unknown을 다른 타입에는 할당할 수 없다. 일반적인 경우 Unknown은 타입 단언(Assertions)이나 타입 가드(Guards)를 필요로 한다. 1234567let a: any = 123;let u: unknown = 123;let v1: boolean = a; // 모든 타입(any)은 어디든 할당할 수 있다.let v2: number = u; // 알 수 없는 타입(unknown)은 모든 타입(any)을 제외한 다른 타입에 할당할 수 없다.let v3: any = u; // OK!let v4: number = u as number; // 타입을 단언하면 할당할 수 있다. 객체 (Object) 기본적으로 typeof 연산자가 &quot;object&quot;로 반환하는 모든 타입 컴파일러 옵션에서 엄격한 타입 검사(strict)를 true로 설정하면, null은 포함하지 않음. object 타입을 쓰면 Object.create 같은 API 가 더 잘 나타난다. 123456789declare function create(o: object | null): void;create({ prop: 0 }); // 성공create(null); // 성공create(42); // 오류create(&quot;string&quot;); // 오류create(false); // 오류create(undefined); // 오류 Void void는 어떤 타입도 존재할 수 없음을 나타내기 때문에, any의 정반대로 작동한다. void는 보통 함수에서 반환 값이 없을 때 반환 타입을 표현하기 위해 쓰인다. 123function warnUser(): void { console.log(&quot;This is my warning message&quot;);} void를 타입 변수를 선언하는 것은 유용하지 않은데, 그 변수에는 null 또는 undefined만 할당할 수 있기 때문이다. ( --strictNullChecks를 사용하지 않을 때만 해당 ) 12let unusable: void = undefined;unusable = null; // 성공 (`--strictNullChecks` 을 사용하지 않을때만) Null과 Undefined 기본적으로 Null과 Undefined는 모든 타입의 하위 타입으로, 다음과 같이 각 타입에 할당할 수 있다. 심지어 서로의 타입에도 할당 가능하다. 12345678let num: number = undefined;let str: string = null;let obj: { a: 1, b: false } = undefined;let arr: any[] = null;let und: undefined = null;let nul: null = undefined;let voi: void = null;// ... 컴파일 옵션 &quot;strictNullChecks&quot;: true를 사용하면 Null과 Undefined가 서로의 타입을 할당할 수 없다. 단, Void에는 Undefined을 할당할 수 있다. 1let voi: void = undefined; // ok Never Never는 절대 발생하지 않을 값을 나타내며, 어떠한 타입도 적용할 수 없다 123function error(message: string): never { throw new Error(message);} 보통 빈 타입 배열을 타입으로 선정할 경우 에러로 볼 수 있다. 123const never: [] = [];never.push(3); // Error - TS2345: // Argument of type '3' is not assignable to parameter of type 'never'. 유니언 (Union) 2개 이상의 타입을 허용하는 경우 |(vertical bar)를 통해 타입을 구분 ()는 선택사항이다. 12345let union: (string | number);union = 'Hello type!';union = 123;union = false; // Error - TS2322: // Type 'false' is not assignable to type 'string | number'. 인터섹션 (Intersection) &amp;(ampersand)를 사용해 2개 이상의 타입을 조합하는 경우 새 타입을 생성하지 않고 기존 타입들을 조합할 수 있어 유용하나, 자주 사용되진 않음. 유니언이 Or라면, 인터섹션은 And에 해당 123456789101112131415161718192021222324252627282930313233// 기존 타입들이 조합 가능하다면 인터섹션을 활용할 수 있다.interface IUser { name: string, age: number}interface IValidation { isValid: boolean}const heropy: IUser = { name: 'Heropy', age: 36, isValid: true // Error - TS2322: // Type '{ name: string; age: number; isValid: boolean; }' // is not assignable to type 'IUser'.};const neo: IUser &amp; IValidation = { name: 'Neo', age: 85, isValid: true};// 혹은 기존 타입(IUser, IValidation)과 비슷하지만, // 정확히 일치하는 타입이 없다면 새로운 타입을 생성해야 한다.interface IUserNew { name: string, age: number, isValid: boolean}const evan: IUserNew = { name: 'Evan', age: 36, isValid: false}; 함수 (Function) 화살표 함수를 이용해 타입을 지정할 수 있다. 인수의 타입과 반환 값의 타입을 입력한다. 1234567891011// myFunc는 2개의 숫자 타입 인수를 가지고, 숫자 타입을 반환하는 함수.let myFunc: (arg1: number, arg2: number) =&gt; number;myFunc = function (x, y) { return x + y;};// 인수가 없고, 반환도 없는 경우.let yourFunc: () =&gt; void;yourFunc = function () { console.log('Hello world~');}; 타입 추론 (Type Inference) 명시적으로 타입 선언이 되어있지 않은 경우, 타입스크립트는 타입을 추론해 제공한다. 타입스크립트가 타입을 추론하는 경우 초기화된 변수 기본값이 설정된 매개 변수 반환 값이 있는 함수 12345678// 초기화된 변수 `num`let num = 12;// 기본값이 설정된 매개 변수 `b`function add(a: number, b: number = 2): number { // 반환 값(`a + b`)이 있는 함수 return a + b;} 타입 추론은 엄격하지 않은 타입 선언( strict: false 등 )과는 다르다. 따라서 타입 추론을 활용하여 ‘모든 곳에 타입 명시’를 피하는 편이 코드 가독성에는 더 좋다. 타입 단언 (Type Assertions) 개발자가 컴파일러보다 값의 유형을 더 잘 알고 있을 때 이를 명시하는 방법 컴파일러에게 내가 뭘 하고 있는지 알아 라고 말하는 것 다른 언어의 타입 변환(캐스팅)과 유사하지만 데이터를 재구성하거나 검사하지 않음 캐스팅 : 이미 선언된 타입이 런타임에서 변하는 것 런타임에 영향을 미치지 않고, 온전히 컴파일러만 사용 타입 스크립트는 개발자가 필요한 어떤 검사를 수행했다고 인지 타입 단언에는 두 가지 형태가 있다. 하나는 “angle-bracket“ 문법이다. 123let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 다른 하나는 as - 문법이다. 123let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 위 두 예제는 동일하므로 기호에 따라 선택하여 사용하다. 그러나 만약 TypeScript를 JSX와 함께 사용할 때는 as - 스타일의 문법만 허용된다. 타입 가드 (Type Guards) 타입을 매번 보장하기 위해 타입 단언을 여러 번 사용해야 하는 경우가 있다. 1234567let pet = getSmallPet();if ((pet as Fish).swim) { (pet as Fish).swim();} else if ((pet as Bird).fly) { (pet as Bird).fly();} 타입 가드는 타입스크립트가 추론 가능한 특정 범위(scope)에서 타입을 보장할 수 있다. NAME is TYPE 형태의 타입 서술어를 반환 타입으로 명시한 함수다. 여기서 NAME은 반드시 현재 함수의 매개변수 이름이어야 한다. 123function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined;} pet is Fish는 위 예제의 타입 서술어다. 이를 활용하여 앞선 예제는 아래와 같이 깔끔해진다 1234567// 이제 'swim'과 'fly'에 대한 모든 호출이 허용된다if (isFish(pet)) { pet.swim();}else { pet.fly();} TypeScript가 pet이 if문 안에서 Fish라는 것을 알고 있을뿐만 아니라, else문 안에서 Fish가 없다는 것을 알고 있으므로, Bird를 반드시 가지고 있어야한다. 위 방식뿐 아니라 제공 가능한 타입가드들이 더 있다.typeof, in, instanceof 연산자를 직접 사용하는 타입 가드다. in 연산자 사용하기 in 연산자는 타입을 좁히는 작용을 한다. n in x에서, n은 문자열 리터럴 혹은 문자열 리터럴 타입이고 x는 유니언 타입이다. “true“ 분기에서는 선택적 혹은 필수 프로퍼티 n을 가지는 타입으로 좁힌다. “false“ 분기에서는 선택적 혹은 누락된 프로퍼티 n을 가지는 타입으로 좁혀진다. 123456function move(pet: Fish | Bird) { if (&quot;swim&quot; in pet) { return pet.swim(); } return pet.fly();} typeof 타입 가드 유니언 타입을 사용하는 버전의 padLeft 코드 예제다. 1234567891011121314151617function isNumber(x: any): x is number { return typeof x === &quot;number&quot;;}function isString(x: any): x is string { return typeof x === &quot;string&quot;;}function padLeft(value: string, padding: string | number) { if (isNumber(padding)) { return Array(padding + 1).join(&quot; &quot;) + value; } if (isString(padding)) { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`);} 그러나 타입이 원시 값인지 확인하는 함수를 정의하는 것은 너무나 귀찮은 일이다. 다행히도 TypeScript는 typeof를 타입 가드로 인식하기 때문에 typeof x === &quot;number&quot;를 함수로 추상할 필요가 없다. 즉, 타입 검사를 인라인으로 작성할 수 있다. 123456789function padLeft(value: string, padding: string | number) { if (typeof padding === &quot;number&quot;) { return Array(padding + 1).join(&quot; &quot;) + value; } if (typeof padding === &quot;string&quot;) { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`);} typeof 타입 가드는 두 가지 다른 형식인 typeof v === &quot;typename&quot; 와 typeof v !== &quot;typename&quot;이 있다. 여기서 typename은 “number“, “string“, “boolean“, “symbol“ 중 하나여야 한다. TypeScript에서 위에 없는 다른 문자열과 비교하는 것을 막지는 않지만, 타입 가드의 표현식으로 인지되지 않는다. instanceof 타입 가드 instanceof 타입 가드는 생성자 함수를 사용하여 타입을 좁히는 방법이다. 123456789101112131415161718192021222324252627282930313233interface Padder { getPaddingString(): string}class SpaceRepeatingPadder implements Padder { constructor(private numSpaces: number) { } getPaddingString() { return Array(this.numSpaces + 1).join(&quot; &quot;); }}class StringPadder implements Padder { constructor(private value: string) { } getPaddingString() { return this.value; }}function getRandomPadder() { return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(&quot; &quot;);}// 타입은 'SpaceRepeatingPadder | StringPadder' 다.let padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) { padder; // 타입은 'SpaceRepeatingPadder'으로 좁혀진다.}if (padder instanceof StringPadder) { padder; // 타입은 'StringPadder'으로 좁혀진다.} instanceof의 오른쪽은 생성자 함수여야 하며, TypeScript는 다음과 같이 타입을 좁힌다. 함수의 prototype 프로퍼티 타입이 any가 아닌 경우 타입의 생성자 시그니처에서 반환된 유니언 타입일 경우 위 예제와 같은 순서대로 진행된다. 참고 타입스크립트(TypeScript) 타입 선언 김민태의 프론트엔드 아카데미 한눈에 보는 타입스크립트 - HEROPY TECH TypeScript Korea 정적 타이핑 - Poiema Web","link":"/2021/08/05/f3a2b4b29950/"},{"title":"[네트워크] OSI 7계층과 TCP&#x2F;IP 4계층","text":"💡 tl;dr OSI 7계층과 TCP/IP 4계층 계층별 특징 파악 OSI 7 layers Open System Interconnection Reference Model의 약자 국제표준화기구(ISO)에서 프로토콜과 통신을 계층으로 나누어 설명하기 위해 개발한 모델 TCP/IP 모델과의 시장 점유 싸움에서 밀려 현대 인터넷에 사용되지 않는다. Layered Architecture를 따르는 거대한 네트워크 시스템 구조를 설명하는 것 이 모델은 프로토콜을 기능별로 나눈 것이다. 각 계층은 하위 계층의 기능만을 이용 가능하고 상위 계층에게 기능을 제공한다. 일반적으로 하위 계층들은 하드웨어로, 상위 계층들은 소프트웨어로 구현되어 있다. 계층이 높을 수록 사람(User)과 가깝고, 낮은 계층일수록 기계와 가깝다. 1계층 / 물리 계층 (Physical) 물리 계층은 네트워크의 하드웨어 전송 기술로 구성 고수준의 논리 데이터 구조가 기초로 요구되는 필수 계층 다양한 특징의 하드웨어 기술이 접목되어 있어 OSI 아키텍처에서 가장 복잡한 계층으로 간주 신호로 변환하여 전송하는 계층 모든 파일과 프로그램은 0과 1의 나열 통신이란 간단히 컴퓨터 끼리 0과 1을 주고 받는 것 컴퓨터는 0과 1의 나열을 아날로그 신호로 바꿔 전선으로 전송 (encoding) 아날로그 신호가 들어오면 이를 0과 1의 나열로 해석 (decoding) 물리적으로 연결된 두 컴퓨터가 0과 1의 나열을 주고받을 수 있게 해주는 것은 모듈(module) 이러한 모듈(함수와 같은 역할을 하는 회로)은 하드웨어적(PHY 칩)으로 구현 시스템의 전기적, 물리적 표현 케이블 종류,(802.11 무선 시스템에서와 같은) 무선 주파수 링크는 물론 핀 배치, 전압, 물리 요건 등이 포함 전기적, 기계적 특성을 이용하여, 통신 케이블로 전기적 신호(에너지)를 전송 / 전송 단위 : bit 단지 데이터 전달 역할만을 하고, 알고리즘이나 오류 제어기능은 존재하지 않는다 사용 장비 Hub, Repeater, Cable 프로토콜 Ethernet.RS-232C 2계층 / 데이터 링크 계층 (Data Link) 데이터 링크 계층은 포인트 투 포인트(ex: 컴퓨터 to 컴퓨터)간 신뢰성있는 전송을 보장하기 위한 계층 동일한 네트워크 내에서의 전송을 담당 (이더넷) 에러검출/재전송/흐름제어 프레임에 주소부여(MAC - 물리적주소) 전송 신뢰성 보장 오류없이 한 장치에서 다른 장치로 프레임(Frame, 비트의 모음)을 전달하는 역할 물리 계층에서 발생할 수 있는 오류를 찾아 내고, 이를 수정하는데 필요한 기능 및 절차적 수단을 제공 이를 위해 CRC(Cyclic Redundancy Check) 기반의 오류 제어와 흐름 제어가 필요 오류가 있다면 해당 데이터를 폐기한다 여러 대의 컴퓨터 간의 통신 1계층에 속하는 기술 만으로는 여러 대의 컴퓨터가 통신하도록 만들 수 없다. 여러 컴퓨터에서 동시에 데이터를 전송 받았을 때 그 출처를 알기 힘들다. 그래서 데이터에 특정 비트열을 추가(encode)해서 보내는데, 이를 framing(프레이밍)이라 하고, encode 된 데이터를 frame이라 한다. 여러 데이터를 받고 그 데이터 안에 포함된 특정한 비트열 MAC 주소를 인식하여 어떤 컴퓨터에서 전송된 데이터인지 구별할 수 있다. 하드웨어적 구현 Data-link Layer 기술은 랜카드(네트워크 카드)에 구현되어 있다. 즉, 1계층과 동일하게 하드웨어적 구현으로 되어있다. 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해진다. 사용 장비 Bridge, Switch 프로토콜 MAC, PPP, HDLC, Frame-Relay, FDDI, ATM, etc… 3계층 / 네트워크 계층 (Network) 서로 다른 두 네트워크 간의 데이터 전송을 담당 주소부여(IP) 경로설정(Route) 운영체제 커널에 소프트웨어적으로 구현 논리적 주소 부여 (IP) 각 컴퓨터들이 갖는 고유한 논리적 주소(IP) 부여 네트워크 관리자가 직접 주소를 할당하는 구조 주소는 계층적(hierarchical) 구조를 갖는다. 전송 계층 사이에 네트워크 서비스 데이터 유닛(NSDU)을 교환하는 기능을 제공 네트워크 경로 설정 데이터(패킷,Packet)를 목적지까지 가장 안전하고 빠르게 전달하는 것 - 라우팅 연결되어 있는 수 많은 라우터들 속에서 IP 주소를 이용해서 길을 찾고(routing) 목적지 까지의 경로상 바로 다음 라우터에게 데이터를 넘겨 주는 것(forwarding)을 도착할때까지 반복. 이러한 라우팅을 통해 인터넷이 가능하고, 전 세계의 컴퓨터와 통신이 가능해짐. 사용 장비 Router 프로토콜 IP, ICMP, IGMP 4계층 / 전송 계층 (Transport) Port 번호를 사용하여 최종 도착지인 프로세스까지 데이터가 도달하게 하는 모듈. 서비스를 구분하고 데이터의 전송 방식을 담당하는 계층 보낼 데이터(단위:Segment)의 용량과 속도, 목적지 등을 처리 종단간(ent-to-end) 통신을 다루는 최하위 계층으로, 종단 간에 신뢰성 있고 효율적인 데이터 전송이 가능하게 하여 상위 계층들이 데이터 전달의 유효성이나 효율성에 대한 고민에서 자유롭게 해준다. 종단 간의 에러 복구와 흐름 제어 담당 (TCP/UDP) 운영체제 커널에 소프트웨어적으로 구현 연결 지향적 프로토콜 일부 프로토콜은 상태(stateful) 저장 및 연결 지향적(connection-oriented)인데, 이는 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다. 대표적으로 TCP는 핸드 셰이크 프로세스를 사용하여 발신자와 수신자 간의 연결을 설정한다. 세그멘테이션 상위 계층 데이터를 세그먼트 단위로 나누는 것 전체 데이터를 분할하여 전체 데이터가 100% 전송되기 전까지 기다려야할 대기시간을 줄여준다. 유튜브 영상 버퍼링이 짧은 이유 연결이 중간에 끊겼을때 발생하는 손실율을 줄일 수 있다. 사용 장비 Gateway 프로토콜 TCP, UDP, ARP 5계층 / 세션 계층 (Session) 응용 프로세스 간의 통신을 관리하기 위한 방법을 제공하는 계층. 세션을 열고 닫는(상호작용 및 동기화) 메커니즘 제공 운영체제에 의해 통신을 하기 위한 세션을 확립/유지/중단/복구 현대의 TCP/IP update 모델에서는 응용 프로그램 계층으로 통합됨 세션 (Session) 두 대의 기기, 컴퓨터 또는 서버 간에 대화(Message)를 위한 논리적 연결 세션의 설정 및 조율, 프로세스 연결 해제 및 종료 등의 기능 필요 프로세스들 사이에 메시지 교환을 통해 서로를 인식한 이후부터 통신을 마칠 때까지의 시간 사용 장비 NetBIOS (세션 내 연결관리 및 에러감지, 복구 수행) 프로토콜 SSH, TLS 6계층 / 표현 계층 (Presentation) 데이터(Message)의 변환 작업을 하는 계층 코드 간의 번역을 담당하여 응용 계층의 부담을 덜어줌 현대의 TCP/IP update 모델에서는 응용 프로그램 계층으로 통합됨 데이터 변환 데이터 표현의 차이를 변환(번역)해줌 데이터 표현 차이 : ASCII, JPEG, MPEG 등의 번역 전송하는 데이터의 인코딩, 디코딩, 암호화, 코드 변환 등을 수행 프로토콜 ASCII, MPEG, JPEG, MIDI, EBCDIC 7계층 / 응용 계층 (Application) OSI 7계층 모델 최상위 계층으로, 사용자가 네트워크 자원에 접근하는 방법 제공 최종적으로 사용자가 볼 수 있는 유일한 계층이며 직접적으로 사용자와 상호작용한다. 모든 네트워크 활동의 기반이 되는 인터페이스 제공 네트워크 소프트웨어 UI 사용자의 입출력(I/O) 프로토콜 DHCP, DNS, FTP, HTTP, SMTP, Telnet 암기 방법 [ 알 ] - Application - 응용 계층 (7계층) [ 프 ] - Presentation - 표현 계층 (6계층) [ 스 ] - Session - 세션 계층 (5계층) [ 터 ] - Transport - 전송 계층 (4계층) [ 널 ] - Network - 네트워크 계층 (3계층) [ 돌 ] - Data Link - 데이터 링크 계층 (2계층) [ 파 ] - Physical - 물리 계층 (1계층) TCP/IP 4 layers TCP/IP는 현재의 인터넷에서 컴퓨터들이 서로 정보를 주고받는데 쓰이는 프로토콜의 모음이다. OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모델 네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7 계층 이 이론을 사용하는 인터넷 표준이 TCP/IP 4계층 버전의 구분에 따라 4~5계층으로 나뉜다. (updated Ver. : 5계층) 인터넷 프로토콜 스위트(Internet Protocol Suite)라고도 불린다. 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다. IP는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다. TCP는 IP 위에서 동작하는 프로토콜로, 데이터의 전달 및 순서를 보장한다. HTTP, FTP, SMTP 등 TCP를 기반으로 한 많은 애플리케이션 프로토콜들이 IP 위에서 동작하기 때문에, 묶어서 TCP/IP라고 부른다. 1계층 / 네트워크 연결 계층 (Network Access) OSI 7 Layer의 데이터 링크 계층(2계층), 물리 계층(1계층)의 결합으로 설명되기도 한다. TCP/IP의 계층들은 운용 범위(애플리케이션, 호스트 대 호스트, 네트워크, 링크)의 설명이지, 운용 절차, 데이터 시맨틱, 네트워크 기술의 세부 규정은 아니다. OS의 하드웨어적인 요소(네트워크 카드, 디바이스 드라이버 등)와 관련되는 모든 것을 지원하는 계층 물리적으로 데이터가 네트워크를 통해 어떻게 전송되는지 정의 논리주소(IP 등)가 아닌 물리주소(MAC 등)를 참조해 전송 에러검출 / 패킷의 프레임화(이더넷 프레임) 담당 프레임(Frame) 단위의 데이터 구성 사용 장비 LAN 장비, LAN 드라이버 프로토콜 Ehternet(이더넷), Token Ring, PPP 2계층 / 인터넷 (Internet) OSI 7 Layer의 네트워크 계층에 해당 3계층인 전송 계층으로부터 넘겨받은 데이터에 논리적인 주소인 IP를 할당하여 전송 출발지와 목적지 IP가 담겨있는 IP 패킷 생성 데이터 전송을 위한 주소 지정 통신 노드 간의 IP 패킷을 전송하는 기능 및 라우팅 기능 담당 IP 프로토콜 데이터에 출발지 IP, 목적지 IP 정보를 담은 IP 패킷을 부여 덕분에 원하는 컴퓨터로 라우팅을 반복하여 데이터 전송 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 전송 비신뢰성 : 중간에 사라지거나(패킷 소실), 전달 순서를 보장하지 않음 프로그램 구분 : 같은 IP를 사용하는 서버에서 애플리케이션 구분 불가 우편을 보내는 것에 비유 프로토콜 IP, ARP, RARP, ICMP, OSPF 3계층 / 전송 계층 (Transport) OSI 7 Layer의 전송계층에 해당 통신 노드 간의 연결을 제어하고, 자료의 송수신을 담당 세그먼트 (Segment)단위의 데이타 구성 네트워크 양단의 송수신 호스트 사이에서 신뢰성 있는 전송기능을 제공 TCP (Transmission Control Protocol) 전송 계층에서 사용되는 프로토콜 연결 지향적 양방향 통신(3 way handshake) 프로토콜 데이터의 순차 전송 보장 흐름 제어 (Flow Control) 혼잡 제어 (Congestion Control) 오류 감지 (Error Detection) UDP (User Datagram Protocol) 하얀 도화지에 비유 (기능이 거의 없음) TCP에 비해 단순하고 전송속도가 빠르다. IP와 거의 같지만 PORT와 체크섬 정도가 추가되었다. 애플리케이션에서 추가 작업 필요 데이터 전달 보증 X 순차 전송(순서 보장) X 흐름 제어 X 혼잡 제어 X Connectionless (3 way handshake X) 오류 감지 (Error Detection) 비교적 데이터의 신뢰성이 중요하지 않을 때 사용 (영상 스트리밍 등) 프로토콜 TCP, UDP 4계층 / 응용 계층 (Application) OSI 7 Layer에서 세션, 프레젠테이션, 애플리케이션 계층에 해당(5, 6, 7계층) 응용프로그램의 UI(User Interface) 담당 사용자와 가장 가까운 계층으로 사용자가 소프트웨어 application과 소통할 수 있게 해준다 TCP/IP 기반의 응용 프로그램을 구분할 때 사용한다. TCP/IP 소켓 프로그래밍 운영체제의 Transport Layer에서 제공하는 API를 활용해서 통신 가능한 프로그램을 만드는 것 네트워크 프로그래밍이라고도 불림 소켓 프로그래밍 만으로도 클라이언트, 서버 프로그램을 따로 만들어서 동작 시킬 수 있다. 누구나 자신만의 application layer 인코더 디코더를 만들 수 있음 암호화, 압축, 인코딩, 디코딩, 통신회선 구축 프로토콜 파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등 암기 방법 [ 나이따 ~! ] Network Access - 네트워크 연결 계층 (1계층) Internet - 인터넷 계층 (2계층) Transport - 전송 계층 (3계층) Application - 응용 계층 (4계층) OSI 모델 vs TCP/IP 모델 두 모델 모두 계층형이다. TCP/IP 프로토콜은 OSI 모델보다 먼저 개발되었고, OSI 모델의 계층과 정확히 일치하진 않는다. TCP/IP 프로토콜 그룹에는 세션(Session)과 표현(Presentation)이 없다. OSI 7 Layer가 더 잘 맞는 경우는 SSL이나 TLS를 설명할 때다. 보통 SSL이나 TLS는 TCP의 상위에, HTTP나 SFTP, 그 밖에 stunnel이나 VPN 위에서 동작하는 애플리케이션 보다는 하위에 있는 세션 계층 프로토콜로 쓰인다. TCP/IP는 인터넷 개발 이후 계속 표준화되어 신뢰성이 우수하다 OSI 7 Layer는 표준이 되기는 하지만 실제적으로 구현되는 예가 거의 없어 신뢰성이 저하되어있다. OSI 7 Layer는 장비 개발과 통신의 표준으로 사용되나 실질적인 통신 자체는 TCP/IP를 따른다. 계층 모형 각 계층은 담당하는 위치마다 처리 역할을 구분해 진행함으로써 서로 간의 간섭을 최소화하여 사용 편리성을 높인다. 다른 제조사 장비 간 통신이 가능하도록 호환성을 보장하여 경제적 손실을 줄인다. 문제 해결 용이 : 문제 발생시 계층별 확인이 가능하다. 다른 계층끼리 전달 과정을 알 필요가 없어, 데이터의 캡슐화와 은닉이 가능하다. 참고 OSI 모형 - 위키백과 [10분 테코톡] 히히의 OSI 7 Layer - 우아한Tech Youtube [10분 테코톡] 파즈의 OSI 7 Layer - 우아한Tech Youtube [10분 테코톡] 👨‍🏫르윈의 TCP UDP - 우아한Tech Youtube [초보자 전용 마을] OSI 7계층, TCP/IP 4계층 [人CoDOM] OSI OSI 7계층, 각 계층이 역할 및 대표 프로토콜들 TCP의 헤더에는 어떤 정보들이 담겨있는걸까? - Evans Library OSI 7계층 vs TCP/ICP 4계층 인터넷 프로토콜 슈트 - 위키백과 모든 개발자를 위한 HTTP 웹 기본 지식(김영한) - 인프런","link":"/2021/08/03/05507539566a/"},{"title":"[프로그래머스] (LV4) 미로 탈출","text":"미로 탈출Python3 문제 설명신규 게임 ‘카카오 미로 탈출’이 출시되어, 라이언이 베타테스터로 참가했습니다. 위 예시 그림은 카카오 미로 탈출의 초기 상태를 나타냅니다. 1번부터 3번까지 번호가 붙어있는 3개의 방이 있고, 방과 방 사이를 연결하는 길에는 이동하는데 걸리는 시간이 표시되어 있습니다. 길은 화살표가 가리키는 방향으로만 이동할 수 있습니다. 미로에는 함정이 존재하며, 함정으로 이동하면, 이동한 함정과 연결된 모든 화살표의 방향이 바뀝니다.\\출발지점인 1번 방에서 탈출이 가능한 3번 방까지 이동해야 합니다. 탈출하는데 걸리는 최소 시간을 구하려고 합니다. 그림의 원은 방을 나타내며 원 안의 숫자는 방 번호를 나타냅니다. 방이 n개일 때, 방 번호는 1부터 n까지 사용됩니다. 화살표에 표시된 숫자는 방과 방 사이를 이동할 때 걸리는 시간을 나타냅니다. 화살표가 가리키고 있는 방향으로만 이동이 가능합니다. 즉, 위 그림에서 2번 방에서 1번 방으로는 이동할 수 없습니다. 그림에 표시된 빨간색 방인 2번 방은 함정입니다. 함정 방으로 이동하는 순간, 이동한 함정 방과 연결되어있는 모든 길의 방향이 반대가 됩니다. 위 그림 1번 방에서 2번 방으로 이동하는 순간 1에서 2로 이동할 수 있던 길은 2에서 1로 이동할 수 있는 길로 바뀌고, 3에서 2로 이동할 수 있던 길은 2에서 3으로 이동할 수 있는 길로 바뀝니다. 똑같은 함정 방을 두 번째 방문하게 되면 원래 방향의 길로 돌아옵니다. 즉, 여러 번 방문하여 계속 길의 방향을 반대로 뒤집을 수 있습니다. 미로를 탈출하는데 필요한 최단 시간은 다음과 같습니다. 1→2: 2번 방으로 이동합니다. 이동 시간은 2입니다. 함정 발동: 2번 방과 연결된 모든 길의 방향이 반대가 됩니다. 2→3: 3번 방으로 이동합니다. 이동 시간은 3입니다. 탈출에 성공했습니다. 총 이동시간은 5입니다. 방의 개수를 나타내는 정수 n, 출발 방의 번호 start, 도착 방의 번호 end, 통로와 이동시간을 나타내는 2차원 정수 배열 roads, 함정 방의 번호를 담은 정수 배열 traps이 매개변수로 주어질 때, 미로를 탈출하는데 필요한 최단 시간을 return 하도록 solution 함수를 완성해주세요. 제한사항 2 ≤ n ≤ 1,000 1 ≤ start ≤ n 1 ≤ end ≤ n 1 ≤ roads의 행 길이 ≤ 3,000 roads의 행은 [P, Q, S]로 이루어져 있습니다. P에서 Q로 갈 수 있는 길이 있으며, 길을 따라 이동하는데 S만큼 시간이 걸립니다. 1 ≤ P ≤ n 1 ≤ Q ≤ n P ≠ Q 1 ≤ S ≤ 3,000 서로 다른 두 방 사이에 직접 연결된 길이 여러 개 존재할 수도 있습니다. 0 ≤ traps의 길이 ≤ 10 1 ≤ traps의 원소 ≤ n 시작 방과 도착 방은 함정이 아닙니다. 항상 미로를 탈출할 수 있는 경우만 주어집니다. 입출력 예 n start end roads traps result 3 1 3 [[1, 2, 2], [3, 2, 3]] [2] 5 4 1 4 [[1, 2, 1], [3, 2, 1], [2, 4, 1]] [2, 3] 4 입출력 예 설명입출력 예 #1 문제 예시와 같습니다. 입출력 예 #2 1 → 2 → 3 → 2 → 4 순서로 이동하면 됩니다. 총 이동시간은 4입니다. 제한시간 안내 정확성 테스트 : 10초 풀이 python1234567891011121314151617181920212223242526272829303132333435363738394041import heapq as hdef solution(n, start, end, roads, traps): start -=1; end -=1; INF = float(&quot;inf&quot;); graph = [[] for _ in range(n)] trap_dict = {trap-1:idx for idx, trap in enumerate(traps)}; nodes = []; isVisit = [[False]*n for _ in range(1&lt;&lt;len(traps))] for road in roads: start_i, end_i, cost = road graph[start_i-1].append([end_i-1,cost,0]) graph[end_i-1].append([start_i-1,cost,1]) h.heappush(nodes,(0,start,0)) while nodes: cur_time, cur_node, state = h.heappop(nodes); if cur_node == end : return cur_time; if isVisit[state][cur_node] == True: continue; else: isVisit[state][cur_node] = True; for next_node, next_cost, road_type in graph[cur_node]: next_state = state cur_isTrap = 1 if cur_node in trap_dict else 0; next_isTrap = 1 if next_node in trap_dict else 0; if cur_isTrap == 0 and next_isTrap == 0: if road_type == 1: continue elif (cur_isTrap + next_isTrap) == 1: node_i = cur_node if cur_isTrap == 1 else next_node isTrapOn = (state &amp; (1&lt;&lt;trap_dict[node_i]))&gt;&gt;trap_dict[node_i] if isTrapOn != road_type: continue else: isTrapOn = (state &amp; (1&lt;&lt;trap_dict[cur_node]))&gt;&gt;trap_dict[cur_node] n_isTrapOn = (state &amp; (1&lt;&lt;trap_dict[next_node]))&gt;&gt;trap_dict[next_node] if (isTrapOn ^ n_isTrapOn) != road_type: continue if next_isTrap == 1: next_state = state ^ (1&lt;&lt;trap_dict[next_node]) h.heappush(nodes,(cur_time+next_cost, next_node, next_state)) 설명 🗣 Trash talk 상반기 카카오 인턴 코딩테스트에서 출제된 문제인데, 당시 5번과 더불어 나의 숨을 조여온 기억이 난다. 시험때 4, 5번을 건들지도 못했는데도 테스트에 통과했을 정도니 당시 시험을 본 사람 대부분이 나처럼 체감 난이도가 상당했을 것이다. 해당 문제의 해설은 이곳 에서 친절하게 알려주고 있다. 물론 풀이 코드는 제외하고 말이다. 📌 풀이 전략 요약 dijkstra 알고리즘을 이용하여 두 점 사이 경로를 찾는다. bit mask를 이용하여 함정 노드들의 발동 상태(ON / OFF)를 구분 한다. 방문 확인을 위한 isVisit 배열은 (함정 상태 경우의 수) x (전체 노드의 길이) 만큼의 길이를 갖는다. 이를 이용해 이미 지나온 노드도 다른 상태(전체 함정들의 발동 상태)라면 재방문이 가능하다. heapq를 사용해 최단 거리 경로들부터 확인한다. 따라서 end에 도달하는 순간이 정답이 된다. heapq에는 직전 노드의 상태 정보를 넘긴다. 이 때문에 현재 상태를 따로 저장하고 갱신할 필요가 없다. 🎲 풀이 설명 (Python 기준) 1. 초기화 trap_dict에는 함정들의 정보가 담긴다. key에는 함정인 노드의 번호를 할당한다. value에는 각 함정의 순서를 할당한다. 이는 비트마스크에서 각 함정을 뜻하는 자릿수로 사용된다. isVisit은 dijkstra의 방문노드 구분을 위한 2차원 배열이다. 첫 인덱스는 함정들의 고유 순서(자릿수)를 뜻한다. 두 번째 인덱스는 node번호를 뜻한다. 문제의 제한사항대로 함정 노드는 최대 10개다. 따라서 최대 2^{10} = 1024개의 함정 상태를 구분하면 된다. 함정 노드들의 상태 구분은 문제에서 주어진 traps의 길이를 시프트 연산하여 할당한다(첫 인덱스). 함정 상태의 0은 OFF, 1은 ON 상태를 뜻한다. 만약 위처럼 함정 노드(빨간 테두리 노드)가 2개인 그래프라면, 구분해야할 함정의 길이는 2^2 = 4이므로 4의 길이를 할당하면 되고 이는 [00, 01, 10, 11]의 상태를 뜻한다. 2. 간선정보 할당 간선들의 정보를 할당한다. 이때 정방향과 역방향을 구분하여 넣어준다. append로 할당되는 배열은 [목적지 노드번호, 이동비용, 다리의 방향 ] 이다. start 노드에게는 정방향(0)인 다리를, end 노드에게는 역방향(1)인 다리를 각각 할당한다. 3. heapq의 사용 heapq에는 다음과 같은 3가지 정보를 담은 튜플이 담긴다. next_time: 해당 간선 이동시의 총 비용next_node: 간선 이동시 도착 노드next_state: 간선 이동 후 다음 노드 도착시 함정들의 상태 Python의 heapq 라이브러리는 튜플의 첫 번째 값으로 우선순위를 할당한다. 따라서 총 이동 비용이 최소인 간선들부터 순차적으로 확인할 수 있고, 만약 end 노드에 도착하면 현재 비용이 정답이 된다. 위 예시에서 놓쳐서 안되는 사실은, heapq에는 아직 1번노드 -&gt; 2번노드 경로와 1번노드 -&gt; 4번노드 경로가 남아있다는 것이다. 마찬가지로 오른쪽 이동을 통해 3번노드 -&gt; 1번노드의 경로도 담기게 된다. 따라서 오른쪽 그림의 4번노드로 이동이 끝난 후 다음으로 pop되는 경로는 왼쪽 그림의 1번노드 -&gt; 2번노드가 된다. 4. 현재 노드 검사 이제 시작 노드를 heapq에 넣고 반복문을 시작한다. heappop으로 heapq의 root를 가져온다. cur_time, cur_node, state 정보를 변수에 할당한다. 현재 pop을 통해 가져온 정보는 이론상 최소거리의 간선과 도착 노드다. 만약 현재 도착 노드가 end면 현재 거리 비용을 리턴한다. 현재 노드의 상태(함정 state)를 확인하여 이미 방문한 노드라면 continue 한다. 아래 그림은 각 노드 방문시 isVisit 변수의 변화를 타나내는 예시다. 첫 그림과 마지막 그림에서 둘 다 1번 노드에 방문했지만, 이동할 때마다 state(bit mask)가 달랐기 때문에 isVisit에 할당된 값의 위치도 다르게 구별된다. 따라서 완전히 다른 노드에 방문한 것과 다르지 않다. 이런 메커니즘으로 함정의 발동 여부에 따라 재방문이 필요한 노드를 중복 없이 구별할 수 있다. 현재 노드의 검사 단계에서 문제가 없으면 다음 간선과 도착 노드에 대한 검증을 시작한다. 5. 검증 graph에서 현재 노드와 연결된 모든 간선을 불러와 다음과 같은 검증을 수행한다. 현재 노드와 다음 노드의 종류(함정 여부) 파악 현재 상태(state) 파악 다음 간선의 종류(방향) 파악 이동후의 상태(next_state) 파악 이는 현재 주어진 간선으로 다음 노드로의 이동이 가능한지, 가능하다면 이동 후 상태가 어떻게 바뀔지 알기 위해서 수행하는 작업들이다. 현재 노드의 종류(일반, 함정)와 다음 노드의 종류(일반, 함정)에 따라 크게 4가지 경우의 수가 생긴다. 일반노드 -&gt; 함정노드 함정노드 -&gt; 함정노드 함정노드 -&gt; 일반노드 일반노드 -&gt; 일반노드 각 종류의 이동 패턴은 다음 그림과 같다. 이를 통해 다음과 같은 사실들을 알 수 있다. 일반-&gt;일반 이동이 가능하려면 간선이 반드시 정방향이어야 한다. 일반-&gt;함정 혹은 함정-&gt;일반 이동시 다음 두 가지 상황에서 이동이 가능하다. 함정이 발동한 상태에서 역방향 간선 함정이 발동하지 않은 상태에서 정방향 간선 함정-&gt;함정 노드 이동시 다음 세 가지 상황에서 이동이 가능하다. 두 함정 모두 발동되지 않은 상태에서 정방향 간선 두 함정 모두 발동된 상태에서 정방향 간선 한 함정만 발동된 상태에서 역방향 간선 이는 다음과 같은 코드로 표현된다. isTrapOn은 현재의 상태(state)에 특정 함정의 시프트 연산(&lt;&lt;)과 end(&amp;) 연산을 통해 특정 함정이 작동되어 있는지를 나타낸다. 이를 통해 현재 불러온 간선을 통해 이동이 가능한지 판단할 수 있다. 6. heappush 여기까지 모두 통과하여 도착한다면 이는 다음과 같이 요약할 수 있다. [heapq에서 꺼내온 최단거리 경로 노드]에서 [해당 노드와 연결된 모든 간선 중에 현재 선택된 간선]으로 이동이 가능하다. 이제 마지막으로 이동이 가능한 경로를 다시 heapq에 넣으면 된다. 앞에서 heapq에 담겼던 내용은 next_time, next_node, next_state였다. 이제 이 세가지를 현재 선택된 간선을 기준으로 계산하면 된다. next_time: 현재 이동 비용 + 간선 이동 비용next_node: 간선 이동시 도착 노드next_state: 간선 이동 후 다음 노드 도착시 함정들의 상태 다음 방문할 노드가 함정이 아니라면 현재 state를 넘긴다. 만약 다음 방문할 노드가 함정이라면, 다음 노드의 함정이 작동된 상태를 시프트연산을 통해 갱신하여 넘겨줘야 한다. 이로써 heappush의 과정마저 끝났고, end에 도착할때까지 위 과정을 반복하면 된다. 🔴 질문이나 개선이 필요한 부분 등 적극적인 피드백 환영! 🔴","link":"/2021/07/15/28bed7b50dc1/"}],"tags":[{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/tags/HTML-CSS/"},{"name":"res","slug":"res","link":"/tags/res/"},{"name":"em","slug":"em","link":"/tags/em/"},{"name":"px","slug":"px","link":"/tags/px/"},{"name":"자바스크립트","slug":"자바스크립트","link":"/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","link":"/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"함수 결합","slug":"함수-결합","link":"/tags/%ED%95%A8%EC%88%98-%EA%B2%B0%ED%95%A9/"},{"name":"디버깅","slug":"디버깅","link":"/tags/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"error","slug":"error","link":"/tags/error/"},{"name":"gitalk","slug":"gitalk","link":"/tags/gitalk/"},{"name":"comment","slug":"comment","link":"/tags/comment/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"drive","slug":"drive","link":"/tags/drive/"},{"name":"code-36","slug":"code-36","link":"/tags/code-36/"},{"name":"타입스크립트","slug":"타입스크립트","link":"/tags/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"김민태의 프론트엔드 아카데미","slug":"김민태의-프론트엔드-아카데미","link":"/tags/%EA%B9%80%EB%AF%BC%ED%83%9C%EC%9D%98-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%EC%B9%B4%EB%8D%B0%EB%AF%B8/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"TIL","slug":"TIL","link":"/tags/TIL/"},{"name":"탐욕법","slug":"탐욕법","link":"/tags/%ED%83%90%EC%9A%95%EB%B2%95/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"프로그래머스","slug":"프로그래머스","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"lv4","slug":"lv4","link":"/tags/lv4/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"},{"name":"운영체제","slug":"운영체제","link":"/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"},{"name":"컴퓨터","slug":"컴퓨터","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0/"},{"name":"프로그램","slug":"프로그램","link":"/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/"},{"name":"정보","slug":"정보","link":"/tags/%EC%A0%95%EB%B3%B4/"},{"name":"커널","slug":"커널","link":"/tags/%EC%BB%A4%EB%84%90/"},{"name":"일상","slug":"일상","link":"/tags/%EC%9D%BC%EC%83%81/"},{"name":"카멜마운트","slug":"카멜마운트","link":"/tags/%EC%B9%B4%EB%A9%9C%EB%A7%88%EC%9A%B4%ED%8A%B8/"},{"name":"모니터암","slug":"모니터암","link":"/tags/%EB%AA%A8%EB%8B%88%ED%84%B0%EC%95%94/"},{"name":"후기","slug":"후기","link":"/tags/%ED%9B%84%EA%B8%B0/"},{"name":"tech","slug":"tech","link":"/tags/tech/"},{"name":"UMA-2","slug":"UMA-2","link":"/tags/UMA-2/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"카카오","slug":"카카오","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4/"},{"name":"카카오 인턴","slug":"카카오-인턴","link":"/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4/"},{"name":"lv2","slug":"lv2","link":"/tags/lv2/"},{"name":"파이썬","slug":"파이썬","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"name":"Disjoint Set","slug":"Disjoint-Set","link":"/tags/Disjoint-Set/"},{"name":"Union-Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"시간복잡도","slug":"시간복잡도","link":"/tags/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"lv3","slug":"lv3","link":"/tags/lv3/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"그래프","slug":"그래프","link":"/tags/%EA%B7%B8%EB%9E%98%ED%94%84/"},{"name":"이분탐색","slug":"이분탐색","link":"/tags/%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89/"},{"name":"위클리챌린지","slug":"위클리챌린지","link":"/tags/%EC%9C%84%ED%81%B4%EB%A6%AC%EC%B1%8C%EB%A6%B0%EC%A7%80/"},{"name":"linked list","slug":"linked-list","link":"/tags/linked-list/"},{"name":"N진법","slug":"N진법","link":"/tags/N%EC%A7%84%EB%B2%95/"},{"name":"괄호","slug":"괄호","link":"/tags/%EA%B4%84%ED%98%B8/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"수학","slug":"수학","link":"/tags/%EC%88%98%ED%95%99/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"순열 조합","slug":"순열-조합","link":"/tags/%EC%88%9C%EC%97%B4-%EC%A1%B0%ED%95%A9/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"파이썬 구현","slug":"파이썬-구현","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B5%AC%ED%98%84/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"bit","slug":"bit","link":"/tags/bit/"},{"name":"딕셔너리","slug":"딕셔너리","link":"/tags/%EB%94%95%EC%85%94%EB%84%88%EB%A6%AC/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"완전탐색","slug":"완전탐색","link":"/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"lv1","slug":"lv1","link":"/tags/lv1/"},{"name":"Date","slug":"Date","link":"/tags/Date/"},{"name":"문자열","slug":"문자열","link":"/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"네트워크","slug":"네트워크","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"OSI","slug":"OSI","link":"/tags/OSI/"},{"name":"IP","slug":"IP","link":"/tags/IP/"},{"name":"최단거리","slug":"최단거리","link":"/tags/%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/"}],"categories":[{"name":"HTML&#x2F;CSS","slug":"HTML-CSS","link":"/categories/HTML-CSS/"},{"name":"자바스크립트","slug":"자바스크립트","link":"/categories/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"디버깅","slug":"디버깅","link":"/categories/%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"타입스크립트","slug":"타입스크립트","link":"/categories/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"운영체제","slug":"운영체제","link":"/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"},{"name":"일상","slug":"일상","link":"/categories/%EC%9D%BC%EC%83%81/"},{"name":"네트워크","slug":"네트워크","link":"/categories/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"프로그래머스","slug":"알고리즘/프로그래머스","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"개념","slug":"알고리즘/개념","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B0%9C%EB%85%90/"},{"name":"lv3","slug":"알고리즘/프로그래머스/lv3","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv3/"},{"name":"lv2","slug":"알고리즘/프로그래머스/lv2","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv2/"},{"name":"lv1","slug":"알고리즘/프로그래머스/lv1","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv1/"},{"name":"lv4","slug":"알고리즘/프로그래머스/lv4","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/lv4/"}]}